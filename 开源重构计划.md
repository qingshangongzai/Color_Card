# Color Card 开源重构计划

> **项目名称**: 取色卡 (Color Card)  
> **目标**: 为开源社区准备，重构代码结构，提升可维护性  
> **制定日期**: 2026-02-04  
> **遵循规范**: [开发规范.md](./开发规范.md)

---

## 一、重构目标与原则

### 1.1 核心目标

| 目标 | 说明 | 优先级 |
|:---:|:---|:---:|
| **代码结构优化** | 按功能模块重新组织目录结构，消除混乱 | 最高 |
| **消除代码重复** | 提取公共基类，合并相似组件 | 最高 |
| **统一代码规范** | 遵循 PEP 8 和项目开发规范 | 最高 |
| **提升可读性** | 优化命名、添加文档、整理导入 | 高 |
| **开源文档** | 许可证、README（最后完善） | 低 |
| **CI/CD** | 自动化测试（可选） | 低 |

### 1.2 重构原则

1. **保持功能不变** - 重构过程中不改变现有功能
2. **渐进式重构** - 分阶段进行，每阶段可独立验证
3. **遵循开发规范** - 严格遵循 [开发规范.md](./开发规范.md)
4. **代码清理同步** - 修改代码时同步清理相关重复代码
5. **先整理后重构** - 先规范现有代码，再提取基类，最后重组目录

---

## 二、重构阶段总览

```
阶段一：导入规范整理（1天）
├── 1.1 统一所有文件的导入顺序
├── 1.2 清理未使用的导入
├── 1.3 合并重复导入
└── 1.4 统一导入风格

阶段二：代码清理与优化（1-2天）
├── 2.1 删除未使用的变量和函数
├── 2.2 清理调试代码和注释
├── 2.3 优化重复逻辑
├── 2.4 完善异常处理
└── 2.5 添加类型注解

阶段三：命名规范统一（0.5天）
├── 3.1 统一文件名风格
├── 3.2 统一类名规范
├── 3.3 统一变量命名
└── 3.4 统一私有成员标记

阶段四：文档完善（0.5天）
├── 4.1 完善文档字符串
├── 4.2 添加文件头注释
└── 4.3 添加关键逻辑注释

阶段五：提取画布基类（1-2天）
├── 5.1 分析 ImageCanvas 和 LuminanceCanvas 的公共逻辑
├── 5.2 设计 BaseImageCanvas 基类
├── 5.3 迁移 ImageCanvas
├── 5.4 迁移 LuminanceCanvas
└── 5.5 测试验证

阶段六：提取卡片基类（1天）
├── 6.1 分析 ColorCard 和 LuminanceCard 的公共结构
├── 6.2 设计 BaseCard 基类
├── 6.3 迁移 ColorCard
├── 6.4 迁移 LuminanceCard
└── 6.5 测试验证

阶段七：合并直方图组件（1天）
├── 7.1 分析 histogram_widget.py 和 luminance_histogram.py
├── 7.2 设计 BaseHistogram 基类
├── 7.3 创建 LuminanceHistogram
├── 7.4 创建 RGBHistogram
└── 7.5 测试验证

阶段八：目录结构重组（1-2天）
├── 8.1 创建新目录结构
├── 8.2 迁移核心模块（core/）
├── 8.3 迁移工具模块（utils/）
├── 8.4 迁移 UI 模块（ui/）
├── 8.5 更新导入路径
└── 8.6 全面测试

阶段九：模块拆分（1天）
├── 9.1 拆分 main_window.py
├── 9.2 拆分 icon_utils.py
└── 9.3 更新模块导出

阶段十：开源准备（最后完善）
├── 10.1 添加开源许可证
├── 10.2 完善 README.md
└── 10.3 创建 CHANGELOG.md
```

---

## 三、详细重构任务

### 阶段一：导入规范整理（1天）✅ 已完成

#### 任务 1.1: 统一导入顺序

**目标**: 所有 Python 文件遵循统一的导入顺序

**规范要求**:
```python
# 标准库导入
import os
import sys
from typing import List, Dict, Optional, Tuple

# 第三方库导入
from PySide6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout
from PySide6.QtCore import Qt, Signal, QTimer
from PySide6.QtGui import QPixmap, QImage, QPainter, QColor
from qfluentwidgets import FluentWindow, setTheme, Theme
from PIL import Image

# 项目模块导入
from core.color import get_color_info, rgb_to_hex
from ui.widgets.cards import ColorCard
```

**涉及文件清单**:
| 文件 | 当前导入问题 | 操作 |
|:---|:---|:---|
| `main.py` | 导入顺序不规范 | 重新排序 |
| `color_utils.py` | 缺少 typing 导入 | 添加类型注解 |
| `config_manager.py` | 导入顺序正确 | 检查未使用导入 |
| `version.py` | 导入顺序正确 | 无需修改 |
| `icon_utils.py` | 混合导入 | 重新分组 |
| `widgets/main_window.py` | 导入顺序不规范 | 重新排序 |
| `widgets/image_canvas.py` | 导入较多，需整理 | 重新分组 |
| `widgets/luminance_canvas.py` | 导入较多，需整理 | 重新分组 |
| `widgets/color_card.py` | 检查未使用导入 | 清理 |
| `widgets/luminance_card.py` | 检查未使用导入 | 清理 |
| `widgets/color_picker.py` | 检查未使用导入 | 清理 |
| `widgets/hsb_color_wheel.py` | 检查未使用导入 | 清理 |
| `widgets/histogram_widget.py` | 检查未使用导入 | 清理 |
| `widgets/luminance_histogram.py` | 检查未使用导入 | 清理 |
| `widgets/rgb_histogram_widget.py` | 检查未使用导入 | 清理 |
| `widgets/settings_interface.py` | 检查未使用导入 | 清理 |
| `widgets/about_dialog.py` | 检查未使用导入 | 清理 |
| `widgets/update_dialog.py` | 检查未使用导入 | 清理 |
| `widgets/zoom_viewer.py` | 检查未使用导入 | 清理 |

**执行步骤**:
1. 使用工具检测未使用的导入
2. 按规范重新排序所有导入
3. 合并同一模块的多次导入
4. 删除未使用的导入

**完成状态**: ✅ 已完成
- 所有文件已添加统一格式的文件头注释
- 导入已按规范重新分组排序（标准库 → 第三方库 → 项目模块）
- 导入语句已按字母顺序排序
- 已删除未使用的导入（如 main.py 中的 QAction, QPixmap）
- 所有文件语法检查通过

**修改文件清单**:
- `main.py` - 重新排序导入，添加文件头
- `color_utils.py` - 添加 typing 导入，添加文件头
- `icon_utils.py` - 重新分组导入，添加文件头
- `config_manager.py` - 添加文件头
- `version.py` - 添加文件头
- `widgets/main_window.py` - 重新排序导入，添加文件头
- `widgets/image_canvas.py` - 重新分组导入，添加文件头
- `widgets/luminance_canvas.py` - 重新分组导入，添加文件头
- `widgets/color_card.py` - 重新排序导入，添加文件头
- `widgets/color_picker.py` - 重新排序导入，添加文件头
- `widgets/luminance_card.py` - 重新排序导入，添加文件头
- `widgets/hsb_color_wheel.py` - 重新排序导入，添加文件头
- `widgets/histogram_widget.py` - 重新排序导入，添加文件头
- `widgets/luminance_histogram.py` - 重新排序导入，添加文件头
- `widgets/rgb_histogram_widget.py` - 重新排序导入，添加文件头
- `widgets/settings_interface.py` - 重新排序导入，添加文件头
- `widgets/about_dialog.py` - 重新排序导入，添加文件头
- `widgets/update_dialog.py` - 重新排序导入，添加文件头
- `widgets/zoom_viewer.py` - 重新排序导入，添加文件头

---

#### 任务 1.2: 清理未使用的导入

**检测方法**:
```bash
# 使用 flake8 检测未使用导入
flake8 --select=F401 .

# 或者使用 autoflake
autoflake --remove-unused-variables --remove-all-unused-imports -r .
```

**清理原则**:
- 删除所有未使用的 `import` 语句
- 删除所有未使用的 `from ... import` 语句
- 保留条件导入（如 `if TYPE_CHECKING:` 中的导入）

---

#### 任务 1.3: 合并重复导入

**示例**:
```python
# 修改前
from PySide6.QtWidgets import QWidget
from PySide6.QtWidgets import QVBoxLayout
from PySide6.QtWidgets import QHBoxLayout

# 修改后
from PySide6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout
```

---

### 阶段二：代码清理与优化（1-2天）✅ 已完成

#### 任务 2.1: 删除未使用的变量 ✅

**检测方法**:
```bash
flake8 --select=F841 .  # 检测未使用的变量
```

**常见场景**:
```python
# 修改前
def process_image(self, image_path):
    result = 0  # 未使用的变量
    pixmap = QPixmap(image_path)
    return pixmap

# 修改后
def process_image(self, image_path):
    pixmap = QPixmap(image_path)
    return pixmap
```

---

#### 任务 2.2: 删除未使用的函数和方法 ✅

**检测方法**:
- 手动检查私有方法（以下划线开头）
- 检查公共方法是否被调用

**清理清单**:
| 文件 | 需检查的函数/方法 | 状态 |
|:---|:---|:---:|
| `color_utils.py` | 检查所有函数是否被使用 | ✅ |
| `config_manager.py` | 检查辅助方法 | ✅ |
| `icon_utils.py` | 检查 Windows 相关函数 | ✅ |
| `widgets/*.py` | 检查每个类的私有方法 | ✅ |

**完成说明**:
- 删除了 `config_manager.py` 中未使用的 `os` 导入
- 所有函数和方法均在使用中

---

#### 任务 2.3: 清理调试代码 ✅

**清理内容**:
- ~~删除 `print()` 调试语句~~（**保留**：后续开发调试需要）
- 删除 `console.log` 等前端调试代码
- 删除临时注释掉的代码块
- 删除 `TODO` 和 `FIXME`（或转移到 Issue）

**完成说明**:
- 根据开发规范，保留 `print()` 调试语句用于后续开发调试
- 无临时注释代码块需要清理
- 无 TODO/FIXME 需要处理

**说明**：
根据开发规范，本次重构**保留 `print()` 调试语句**，原因如下：
1. 项目仍处于开发迭代阶段，后续功能修改需要调试支持
2. 调试语句有助于快速定位运行时问题
3. 方便其他开发者理解和调试代码
4. 开源发布时可根据需要决定是否保留（生产环境建议使用 `logging` 模块）

**示例**（保留调试语句）：
```python
# 保留调试语句，便于后续开发调试
def load_image(self, path):
    print(f"Loading image: {path}")  # 调试代码 - 保留
    pixmap = QPixmap(path)
    print(f"Image size: {pixmap.size()}")  # 调试代码 - 保留
    return pixmap
```

---

#### 任务 2.4: 优化重复逻辑 ✅

**当前发现的重复代码**:

1. **图片加载逻辑**（image_canvas.py 和 luminance_canvas.py）
   - ImageLoader 类完全重复
   - 图片加载流程重复
   - ✅ 已提取到 BaseCanvas 基类

2. **坐标转换逻辑**
   - 相对坐标 ↔ 画布坐标转换
   - 边界检查
   - ✅ 已提取到 BaseCanvas 基类

3. **右键菜单创建**
   - 菜单项创建模式相似
   - ✅ 已提取到 BaseCanvas 基类

**优化方案实施**:
- 创建了 `widgets/base_canvas.py` 基类
- `ImageCanvas` 和 `LuminanceCanvas` 现在继承自 `BaseCanvas`
- 消除了约 200 行重复代码

**涉及文件**:
- 新增: `widgets/base_canvas.py` (478 行)
- 修改: `widgets/image_canvas.py` (从 474 行减少到 227 行)
- 修改: `widgets/luminance_canvas.py` (从 668 行减少到 391 行)
- 修改: `widgets/__init__.py` (导出 BaseCanvas 和 ImageLoader)

---

#### 任务 2.5: 完善异常处理 ✅

**当前问题**:
- 部分代码使用裸 `except:`
- 异常信息不够详细

**改进实施**:

| 文件 | 改进内容 |
|:---|:---|
| `icon_utils.py` | 将裸 `except Exception` 改为具体的 `(AttributeError, OSError)` 和 `(RuntimeError, ValueError)` |
| `widgets/base_canvas.py` | ImageLoader 使用 `(IOError, OSError, ValueError)` |

**改进示例**:
```python
# 修改前
try:
    image = Image.open(path)
except:
    pass

# 修改后
try:
    image = Image.open(path)
except (IOError, OSError, ValueError) as e:
    self.error.emit(str(e))
```

---

#### 任务 2.6: 添加类型注解 ✅

**优先级文件**:
| 文件 | 状态 | 说明 |
|:---|:---:|:---|
| `color_utils.py` | ✅ | 所有颜色转换函数添加完整类型注解 |
| `config_manager.py` | ✅ | 配置管理类添加完整类型注解 |
| `version.py` | ✅ | 版本管理类添加完整类型注解 |
| `icon_utils.py` | ✅ | 图标工具函数添加完整类型注解 |
| `widgets/base_canvas.py` | ✅ | 基类添加完整类型注解 |
| `widgets/image_canvas.py` | ✅ | 图片画布添加完整类型注解 |
| `widgets/luminance_canvas.py` | ✅ | 明度画布添加完整类型注解 |

**示例**:
```python
# 修改前
def rgb_to_hsb(r, g, b):
    """将RGB转换为HSB"""
    r, g, b = r / 255.0, g / 255.0, b / 255.0
    h, s, v = colorsys.rgb_to_hsv(r, g, b)
    return h * 360, s * 100, v * 100

# 修改后
def rgb_to_hsb(r: int, g: int, b: int) -> Tuple[float, float, float]:
    """将RGB转换为HSB (Hue, Saturation, Brightness)

    Args:
        r: 红色通道值 (0-255)
        g: 绿色通道值 (0-255)
        b: 蓝色通道值 (0-255)

    Returns:
        tuple: (色相 0-360, 饱和度 0-100, 亮度 0-100)
    """
    r_norm, g_norm, b_norm = r / 255.0, g / 255.0, b / 255.0
    h, s, v = colorsys.rgb_to_hsv(r_norm, g_norm, b_norm)
    return h * 360, s * 100, v * 100
```

---

**阶段二完成总结**:

| 任务 | 状态 | 主要工作 |
|:---|:---:|:---|
| 2.1 删除未使用的变量 | ✅ | 删除 `config_manager.py` 未使用的 `os` 导入 |
| 2.2 删除未使用的函数 | ✅ | 检查并确认所有函数均在使用中 |
| 2.3 清理调试代码 | ✅ | 保留 `print()` 语句，无临时注释代码 |
| 2.4 优化重复逻辑 | ✅ | 创建 `BaseCanvas` 基类，消除约 200 行重复代码 |
| 2.5 完善异常处理 | ✅ | 替换裸 `except`，使用具体异常类型 |
| 2.6 添加类型注解 | ✅ | 为 7 个文件添加完整类型注解 |

**新增文件**:
- `widgets/base_canvas.py` (478 行) - 画布基类

**修改文件**:
- `color_utils.py` - 添加类型注解
- `config_manager.py` - 添加类型注解，删除未使用导入
- `version.py` - 添加类型注解
- `icon_utils.py` - 添加类型注解，完善异常处理
- `widgets/image_canvas.py` - 继承 BaseCanvas，添加类型注解
- `widgets/luminance_canvas.py` - 继承 BaseCanvas，添加类型注解
- `widgets/__init__.py` - 导出 BaseCanvas 和 ImageLoader

---

### 阶段三：命名规范统一（0.5天）

#### 任务 3.1: 统一文件名风格

**当前问题**:
- `color_card.py` vs `luminance_card.py`（一致，好）
- `hsb_color_wheel.py`（可简化为 `color_wheel.py`）
- `histogram_widget.py` vs `luminance_histogram.py`（不一致）

**命名规范**:
| 类型 | 规范 | 示例 |
|:---:|:---:|:---:|
| 模块文件 | 小写+下划线 | `color_utils.py` |
| 类文件 | 小写+下划线 | `main_window.py` |
| 组件文件 | 小写+下划线 | `color_picker.py` |

**重命名计划**:
| 原文件名 | 新文件名 | 说明 |
|:---|:---|:---|
| `hsb_color_wheel.py` | `color_wheel.py` | 简化名称 |
| `histogram_widget.py` | `luminance_histogram_widget.py` | 明确用途 |
| `luminance_histogram.py` | 合并到上述文件 | 消除重复 |

---

#### 任务 3.2: 统一类名规范

**规范**: 驼峰命名法（PascalCase）

**检查清单**:
| 文件 | 类名 | 状态 |
|:---|:---|:---:|
| `main_window.py` | `MainWindow` | ✓ |
| `main_window.py` | `ColorExtractInterface` | ✓ |
| `main_window.py` | `LuminanceExtractInterface` | ✓ |
| `image_canvas.py` | `ImageCanvas` | ✓ |
| `luminance_canvas.py` | `LuminanceCanvas` | ✓ |
| `color_card.py` | `ColorCardPanel` | ✓ |
| `luminance_card.py` | `LuminanceCard` | ✓ |
| `color_picker.py` | `ColorPicker` | ✓ |
| `hsb_color_wheel.py` | `HSBColorWheel` | ✓ |
| `histogram_widget.py` | `HistogramWidget` | 需明确 |
| `luminance_histogram.py` | `LuminanceHistogram` | ✓ |
| `rgb_histogram_widget.py` | `RGBHistogramWidget` | ✓ |

---

#### 任务 3.3: 统一变量命名

**规范**:
| 类型 | 规范 | 示例 |
|:---:|:---:|:---:|
| 常量 | 大写+下划线 | `PICKER_RADIUS = 12` |
| 变量 | 小写+下划线 | `picker_positions` |
| 私有变量 | 单下划线前缀 | `_dragging_index` |
| 类属性 | 小写+下划线 | `self.image_path` |

**需要统一的变量**:
```python
# 统一前（不同文件中的不同风格）
self.imagePath      # camelCase
self.image_path     # snake_case
self._imagePath     # 私有 camelCase
self._image_path    # 私有 snake_case

# 统一后
self._image_path    # 全部使用私有 snake_case
```

---

#### 任务 3.4: 统一私有成员标记

**规范**: 私有属性和方法使用单下划线前缀 `_`

**检查清单**:
- [ ] `image_canvas.py` 中的私有属性
- [ ] `luminance_canvas.py` 中的私有属性
- [ ] `color_card.py` 中的私有属性
- [ ] `luminance_card.py` 中的私有属性

---

### 阶段四：文档完善（0.5天）

#### 任务 4.1: 完善文档字符串

**规范要求**（根据开发规范）:
- 类文档字符串保持简洁（单行或简短段落）
- 方法文档字符串包含 Args、Returns 说明
- 使用中文描述

**需要完善的文件**:
| 文件 | 优先级 | 说明 |
|:---|:---:|:---|
| `color_utils.py` | 高 | 所有公共函数 |
| `config_manager.py` | 高 | 所有公共方法 |
| `version.py` | 中 | 类和方法 |
| `icon_utils.py` | 中 | 公共函数 |
| `widgets/*.py` | 中 | 所有类 |

**示例**:
```python
# 完善前
class ImageCanvas(QWidget):
    """图片显示画布"""
    pass

# 完善后
class ImageCanvas(QWidget):
    """图片显示画布，支持拖拽取色点
    
    功能：
        - 显示图片并保持比例
        - 支持拖拽放置图片
        - 支持添加和拖动取色点
        - 实时提取像素颜色
        
    信号：
        color_picked: 取色点颜色变化时发射
        image_loaded: 图片加载完成时发射
        image_cleared: 图片清空时发射
    """
    pass
```

---

#### 任务 4.2: 添加文件头注释

**模板**:
```python
"""
Color Card - 图片颜色提取工具
Copyright (c) 2026 浮晓 HXiao Studio

模块名称: [模块名]
功能描述: [简要描述]

作者: 青山公仔
创建日期: 2026-02-04
"""
```

---

#### 任务 4.3: 添加关键逻辑注释

**需要注释的关键逻辑**:
1. 坐标转换算法
2. 颜色空间转换
3. 明度计算（Rec. 709）
4. 图片缩放算法
5. 直方图计算

**示例**:
```python
def get_luminance(r, g, b):
    """计算像素的明度值 (0-255)
    
    使用 Rec. 709 标准计算亮度值，包含 sRGB Gamma 校正
    这是 Lightroom、Photoshop 等专业软件使用的标准方法
    """
    # 步骤1: 归一化到 0-1 范围
    r_norm = r / 255.0
    g_norm = g / 255.0
    b_norm = b / 255.0

    # 步骤2: sRGB Gamma 解码（转换到线性空间）
    # sRGB 的 gamma 曲线近似于 gamma 2.2，但使用更精确的公式
    def srgb_to_linear(c):
        if c <= 0.04045:
            return c / 12.92
        else:
            return ((c + 0.055) / 1.055) ** 2.4

    r_linear = srgb_to_linear(r_norm)
    g_linear = srgb_to_linear(g_norm)
    b_linear = srgb_to_linear(b_norm)

    # 步骤3: 在线性空间应用 Rec. 709 权重
    # 人眼对绿色最敏感，其次是红色，对蓝色最不敏感
    luminance_linear = 0.2126 * r_linear + 0.7152 * g_linear + 0.0722 * b_linear

    # 步骤4-5: 编码回 sRGB 空间并转换到 0-255
    ...
```

---

### 阶段五：提取画布基类（1-2天）

#### 任务 5.1: 分析公共逻辑

**对比 image_canvas.py 和 luminance_canvas.py**:

| 功能 | ImageCanvas | LuminanceCanvas | 公共 |
|:---:|:---:|:---:|:---:|
| 图片加载 | ✓ | ✓ | ✓ |
| 图片清空 | ✓ | ✓ | ✓ |
| 拖拽支持 | ✓ | ✓ | ✓ |
| 右键菜单 | ✓ | ✓ | ✓ |
| 缩放显示 | ✓ | ✓ | ✓ |
| 采样点 | ✓ | ✗ | ✗ |
| 区域选择 | ✗ | ✓ | ✗ |

**公共属性**:
- `_image_path`: 图片路径
- `_pixmap`: 显示用的 QPixmap
- `_original_image`: 原始 QImage
- `_display_rect`: 图片显示区域
- `_zoom_factor`: 缩放因子

**公共方法**:
- `set_image(path)`: 加载图片
- `clear_image()`: 清空图片
- `paintEvent(event)`: 绘制事件
- `resizeEvent(event)`: 调整大小事件
- `dragEnterEvent(event)`: 拖拽进入
- `dropEvent(event)`: 拖拽放下

---

#### 任务 5.2: 设计 BaseImageCanvas 基类

**文件**: `ui/canvases/base.py`

```python
"""画布基类模块"""

from PySide6.QtWidgets import QWidget, QMenu
from PySide6.QtCore import Signal, Qt, QRect
from PySide6.QtGui import QPixmap, QImage, QPainter, QColor, QCursor

from qfluentwidgets import RoundMenu, Action, FluentIcon


class BaseImageCanvas(QWidget):
    """图片画布基类，提供通用的图片显示和交互功能
    
    功能：
        - 图片加载和显示（保持比例）
        - 拖拽打开图片
        - 右键菜单
        - 缩放显示
        
    子类需要实现：
        - _on_image_loaded(): 图片加载后的处理
        - _on_image_cleared(): 图片清空后的处理
        - _draw_overlay(painter): 绘制叠加内容
        - _setup_context_menu(menu): 设置右键菜单项
        
    信号：
        image_loaded(str): 图片加载完成，参数为图片路径
        image_cleared(): 图片已清空
        open_image_requested(): 请求打开图片对话框
    """
    
    image_loaded = Signal(str)
    image_cleared = Signal()
    open_image_requested = Signal()
    
    # 常量
    BACKGROUND_COLOR = QColor(40, 40, 40)
    SUPPORTED_FORMATS = {'.png', '.jpg', '.jpeg', '.bmp', '.gif'}
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._image_path: str = None
        self._pixmap: QPixmap = None
        self._original_image: QImage = None
        self._display_rect: QRect = QRect()
        self._zoom_factor: float = 1.0
        
        self._setup_ui()
        self._setup_connections()
        
    def _setup_ui(self):
        """初始化UI"""
        self.setAcceptDrops(True)
        self.setMinimumSize(200, 200)
        self.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        
    def _setup_connections(self):
        """设置信号连接"""
        self.customContextMenuRequested.connect(self._show_context_menu)
        
    def set_image(self, path: str) -> bool:
        """加载并显示图片
        
        Args:
            path: 图片文件的完整路径
            
        Returns:
            bool: 加载成功返回 True，失败返回 False
        """
        if not self._validate_image_path(path):
            return False
            
        try:
            # 加载原始图片
            self._original_image = QImage(path)
            if self._original_image.isNull():
                return False
                
            # 创建显示用的 pixmap
            self._pixmap = QPixmap.fromImage(self._original_image)
            self._image_path = path
            
            # 更新显示
            self._update_display_rect()
            self.update()
            
            # 子类处理
            self._on_image_loaded()
            
            # 发射信号
            self.image_loaded.emit(path)
            return True
            
        except Exception as e:
            print(f"加载图片失败: {e}")
            return False
            
    def clear_image(self):
        """清空图片"""
        self._image_path = None
        self._pixmap = None
        self._original_image = None
        self._display_rect = QRect()
        self._zoom_factor = 1.0
        
        # 子类处理
        self._on_image_cleared()
        
        self.update()
        self.image_cleared.emit()
        
    def get_image_pixel(self, canvas_x: int, canvas_y: int) -> tuple:
        """获取指定画布位置的像素颜色
        
        Args:
            canvas_x: 画布X坐标
            canvas_y: 画布Y坐标
            
        Returns:
            tuple: (r, g, b) 颜色值，如果位置无效返回 None
        """
        if not self._original_image or self._original_image.isNull():
            return None
            
        # 转换为图片坐标
        rel_x, rel_y = self._canvas_to_relative(canvas_x, canvas_y)
        if rel_x is None:
            return None
            
        # 转换为像素坐标
        img_x = int(rel_x * self._original_image.width())
        img_y = int(rel_y * self._original_image.height())
        
        # 边界检查
        if not (0 <= img_x < self._original_image.width() and 
                0 <= img_y < self._original_image.height()):
            return None
            
        color = self._original_image.pixelColor(img_x, img_y)
        return (color.red(), color.green(), color.blue())
        
    def _validate_image_path(self, path: str) -> bool:
        """验证图片路径是否有效"""
        if not path or not isinstance(path, str):
            return False
            
        from pathlib import Path
        file_path = Path(path)
        
        if not file_path.exists():
            return False
            
        return file_path.suffix.lower() in self.SUPPORTED_FORMATS
        
    def _update_display_rect(self):
        """计算图片显示区域（保持比例居中）"""
        if not self._pixmap or self._pixmap.isNull():
            self._display_rect = QRect()
            return
            
        widget_w = self.width()
        widget_h = self.height()
        img_w = self._pixmap.width()
        img_h = self._pixmap.height()
        
        # 计算缩放比例
        scale_w = widget_w / img_w
        scale_h = widget_h / img_h
        self._zoom_factor = min(scale_w, scale_h, 1.0)  # 不放大
        
        # 计算显示尺寸
        disp_w = int(img_w * self._zoom_factor)
        disp_h = int(img_h * self._zoom_factor)
        
        # 居中显示
        disp_x = (widget_w - disp_w) // 2
        disp_y = (widget_h - disp_h) // 2
        
        self._display_rect = QRect(disp_x, disp_y, disp_w, disp_h)
        
    def _canvas_to_relative(self, canvas_x: int, canvas_y: int) -> tuple:
        """画布坐标转换为相对坐标 (0.0-1.0)"""
        if not self._display_rect.isValid():
            return None, None
            
        rel_x = (canvas_x - self._display_rect.x()) / self._display_rect.width()
        rel_y = (canvas_y - self._display_rect.y()) / self._display_rect.height()
        
        # 检查是否在图片区域内
        if not (0 <= rel_x <= 1 and 0 <= rel_y <= 1):
            return None, None
            
        return rel_x, rel_y
        
    def _relative_to_canvas(self, rel_x: float, rel_y: float) -> tuple:
        """相对坐标转换为画布坐标"""
        if not self._display_rect.isValid():
            return None, None
            
        canvas_x = self._display_rect.x() + rel_x * self._display_rect.width()
        canvas_y = self._display_rect.y() + rel_y * self._display_rect.height()
        return int(canvas_x), int(canvas_y)
        
    def paintEvent(self, event):
        """绘制事件"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # 绘制背景
        painter.fillRect(self.rect(), self.BACKGROUND_COLOR)
        
        # 绘制图片
        if self._pixmap and not self._pixmap.isNull():
            painter.drawPixmap(self._display_rect, self._pixmap)
            
        # 绘制子类特定的叠加内容
        self._draw_overlay(painter)
        
    def resizeEvent(self, event):
        """调整大小事件"""
        super().resizeEvent(event)
        self._update_display_rect()
        
    def dragEnterEvent(self, event):
        """拖拽进入事件"""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            event.ignore()
            
    def dropEvent(self, event):
        """拖拽放下事件"""
        urls = event.mimeData().urls()
        if urls:
            file_path = urls[0].toLocalFile()
            if self._validate_image_path(file_path):
                self.set_image(file_path)
                
    def _show_context_menu(self, pos):
        """显示右键菜单"""
        menu = RoundMenu("")
        
        if self._pixmap:
            # 已有图片时的菜单
            change_action = Action(FluentIcon.PHOTO, "更换图片")
            change_action.triggered.connect(self.open_image_requested.emit)
            menu.addAction(change_action)
            
            clear_action = Action(FluentIcon.DELETE, "清空图片")
            clear_action.triggered.connect(self.clear_image)
            menu.addAction(clear_action)
        else:
            # 无图片时的菜单
            open_action = Action(FluentIcon.FOLDER, "打开图片")
            open_action.triggered.connect(self.open_image_requested.emit)
            menu.addAction(open_action)
            
        # 子类添加自定义菜单项
        self._setup_context_menu(menu)
        
        menu.exec(QCursor.pos())
        
    # 子类必须实现的方法
    def _on_image_loaded(self):
        """图片加载后的处理（子类重写）"""
        pass
        
    def _on_image_cleared(self):
        """图片清空后的处理（子类重写）"""
        pass
        
    def _draw_overlay(self, painter: QPainter):
        """绘制叠加内容（子类必须实现）"""
        raise NotImplementedError("子类必须实现 _draw_overlay 方法")
        
    def _setup_context_menu(self, menu: RoundMenu):
        """设置右键菜单项（子类重写）"""
        pass
```

---

#### 任务 5.3: 迁移 ImageCanvas

**修改后的 ImageCanvas**:
```python
"""图片画布模块"""

from PySide6.QtCore import Signal, Qt, QRect
from PySide6.QtGui import QPainter, QColor, QPen, QFont

from qfluentwidgets import RoundMenu, Action, FluentIcon

from .base import BaseImageCanvas
from ..widgets.color_picker import ColorPicker


class ImageCanvas(BaseImageCanvas):
    """图片画布，支持取色点拖动
    
    功能：
        - 继承 BaseImageCanvas 的所有功能
        - 支持添加和拖动多个取色点
        - 实时提取并发射颜色信息
        
    信号：
        color_picked(int, tuple): 取色点颜色变化，参数为(索引, RGB颜色)
        picker_moved(int, tuple): 取色点位置变化，参数为(索引, 相对位置)
    """
    
    color_picked = Signal(int, tuple)  # 索引, RGB颜色
    picker_moved = Signal(int, tuple)  # 索引, (rel_x, rel_y)
    
    # 常量
    MAX_PICKERS = 5
    PICKER_RADIUS = 12
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._pickers: list = []  # 取色点列表
        self._dragging_index: int = -1  # 当前拖动的取色点索引
        self._show_picker_labels: bool = True
        
    def _setup_ui(self):
        """初始化UI"""
        super()._setup_ui()
        self.setMouseTracking(True)
        
    def _on_image_loaded(self):
        """图片加载后初始化取色点"""
        self._init_pickers()
        
    def _on_image_cleared(self):
        """图片清空后清除取色点"""
        self._pickers.clear()
        self._dragging_index = -1
        
    def _init_pickers(self):
        """初始化取色点位置"""
        self._pickers.clear()
        
        # 默认位置：均匀分布在图片上
        positions = [
            (0.2, 0.2), (0.8, 0.2),
            (0.5, 0.5),
            (0.2, 0.8), (0.8, 0.8)
        ]
        
        for i, (rel_x, rel_y) in enumerate(positions[:self.MAX_PICKERS]):
            self._pickers.append({
                'index': i,
                'rel_x': rel_x,
                'rel_y': rel_y,
                'rgb': None
            })
            
        # 提取初始颜色
        self._update_all_picker_colors()
        
    def _update_all_picker_colors(self):
        """更新所有取色点的颜色"""
        for i, picker in enumerate(self._pickers):
            canvas_x, canvas_y = self._relative_to_canvas(
                picker['rel_x'], picker['rel_y']
            )
            if canvas_x is not None:
                rgb = self.get_image_pixel(canvas_x, canvas_y)
                if rgb:
                    picker['rgb'] = rgb
                    self.color_picked.emit(i, rgb)
                    
    def _draw_overlay(self, painter: QPainter):
        """绘制取色点"""
        if not self._pickers:
            return
            
        for picker in self._pickers:
            canvas_x, canvas_y = self._relative_to_canvas(
                picker['rel_x'], picker['rel_y']
            )
            if canvas_x is None:
                continue
                
            # 绘制取色点
            self._draw_picker(painter, canvas_x, canvas_y, picker)
            
    def _draw_picker(self, painter: QPainter, x: int, y: int, picker: dict):
        """绘制单个取色点"""
        index = picker['index']
        rgb = picker['rgb']
        
        # 外圈（白色）
        painter.setPen(QPen(QColor(255, 255, 255), 2))
        painter.setBrush(QColor(0, 0, 0, 0))
        painter.drawEllipse(
            x - self.PICKER_RADIUS,
            y - self.PICKER_RADIUS,
            self.PICKER_RADIUS * 2,
            self.PICKER_RADIUS * 2
        )
        
        # 内圈（当前颜色）
        if rgb:
            painter.setBrush(QColor(*rgb))
            painter.setPen(Qt.PenStyle.NoPen)
            painter.drawEllipse(
                x - self.PICKER_RADIUS + 4,
                y - self.PICKER_RADIUS + 4,
                (self.PICKER_RADIUS - 4) * 2,
                (self.PICKER_RADIUS - 4) * 2
            )
            
        # 编号
        if self._show_picker_labels:
            painter.setPen(QColor(255, 255, 255))
            painter.setFont(QFont("Microsoft YaHei", 8))
            painter.drawText(
                x - self.PICKER_RADIUS, y - self.PICKER_RADIUS - 5,
                self.PICKER_RADIUS * 2, 15,
                Qt.AlignmentFlag.AlignCenter,
                str(index + 1)
            )
            
    def mousePressEvent(self, event):
        """鼠标按下事件"""
        if not self._pixmap:
            return
            
        # 检查是否点击了取色点
        for i, picker in enumerate(self._pickers):
            canvas_x, canvas_y = self._relative_to_canvas(
                picker['rel_x'], picker['rel_y']
            )
            if canvas_x is None:
                continue
                
            # 计算距离
            dx = event.pos().x() - canvas_x
            dy = event.pos().y() - canvas_y
            distance = (dx ** 2 + dy ** 2) ** 0.5
            
            if distance <= self.PICKER_RADIUS:
                self._dragging_index = i
                self.setCursor(Qt.CursorShape.ClosedHandCursor)
                return
                
        super().mousePressEvent(event)
        
    def mouseMoveEvent(self, event):
        """鼠标移动事件"""
        if self._dragging_index >= 0:
            # 拖动取色点
            rel_x, rel_y = self._canvas_to_relative(
                event.pos().x(), event.pos().y()
            )
            if rel_x is not None:
                self._pickers[self._dragging_index]['rel_x'] = rel_x
                self._pickers[self._dragging_index]['rel_y'] = rel_y
                self._update_all_picker_colors()
                self.update()
            return
            
        # 检查鼠标悬停
        for picker in self._pickers:
            canvas_x, canvas_y = self._relative_to_canvas(
                picker['rel_x'], picker['rel_y']
            )
            if canvas_x is None:
                continue
                
            dx = event.pos().x() - canvas_x
            dy = event.pos().y() - canvas_y
            if (dx ** 2 + dy ** 2) ** 0.5 <= self.PICKER_RADIUS:
                self.setCursor(Qt.CursorShape.OpenHandCursor)
                return
                
        self.setCursor(Qt.CursorShape.ArrowCursor)
        super().mouseMoveEvent(event)
        
    def mouseReleaseEvent(self, event):
        """鼠标释放事件"""
        if self._dragging_index >= 0:
            self._dragging_index = -1
            self.setCursor(Qt.CursorShape.ArrowCursor)
            return
        super().mouseReleaseEvent(event)
```

---

#### 任务 5.4: 迁移 LuminanceCanvas

**修改后的 LuminanceCanvas**:
```python
"""明度画布模块"""

from PySide6.QtCore import Signal, Qt, QRect
from PySide6.QtGui import QPainter, QColor, QPen, QBrush

from qfluentwidgets import RoundMenu, Action, FluentIcon

from .base import BaseImageCanvas


class LuminanceCanvas(BaseImageCanvas):
    """明度画布，支持区域选择
    
    功能：
        - 继承 BaseImageCanvas 的所有功能
        - 显示明度分区（9个 Zone）
        - 支持点击选择区域
        - 显示区域统计信息
        
    信号：
        zone_selected(int): 区域被选择，参数为区域索引(0-8)
        zone_cleared(): 区域选择被清除
    """
    
    zone_selected = Signal(int)
    zone_cleared = Signal()
    
    # 常量
    NUM_ZONES = 9
    ZONE_COLORS = [
        QColor(20, 20, 20),    # Zone 0
        QColor(50, 50, 50),    # Zone 1
        QColor(80, 80, 80),    # Zone 2
        QColor(110, 110, 110), # Zone 3
        QColor(140, 140, 140), # Zone 4
        QColor(170, 170, 170), # Zone 5
        QColor(200, 200, 200), # Zone 6
        QColor(230, 230, 230), # Zone 7
        QColor(250, 250, 250), # Zone 8
    ]
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._selected_zone: int = -1
        self._zone_stats: list = []  # 每个区域的统计信息
        
    def _on_image_loaded(self):
        """图片加载后计算统计信息"""
        self._calculate_zone_stats()
        
    def _on_image_cleared(self):
        """图片清空后清除统计"""
        self._selected_zone = -1
        self._zone_stats.clear()
        self.zone_cleared.emit()
        
    def _calculate_zone_stats(self):
        """计算每个明度区域的统计信息"""
        if not self._original_image:
            return
            
        self._zone_stats = [0] * self.NUM_ZONES
        
        width = self._original_image.width()
        height = self._original_image.height()
        
        # 采样计算
        from core.color import get_luminance
        
        sample_step = 4
        for y in range(0, height, sample_step):
            for x in range(0, width, sample_step):
                color = self._original_image.pixelColor(x, y)
                luminance = get_luminance(
                    color.red(), color.green(), color.blue()
                )
                zone = min(luminance // 32, self.NUM_ZONES - 1)
                self._zone_stats[zone] += 1
                
    def _draw_overlay(self, painter: QPainter):
        """绘制明度分区"""
        if not self._display_rect.isValid():
            return
            
        # 绘制分区标记
        zone_width = self._display_rect.width() / self.NUM_ZONES
        
        for i in range(self.NUM_ZONES):
            x = self._display_rect.x() + i * zone_width
            
            # 高亮选中的区域
            if i == self._selected_zone:
                painter.fillRect(
                    int(x), self._display_rect.y(),
                    int(zone_width), self._display_rect.height(),
                    QColor(0, 120, 215, 100)
                )
                
            # 绘制分隔线
            painter.setPen(QPen(self.ZONE_COLORS[i], 2))
            painter.drawLine(
                int(x), self._display_rect.y(),
                int(x), self._display_rect.y() + self._display_rect.height()
            )
            
    def mousePressEvent(self, event):
        """鼠标按下事件"""
        if not self._pixmap or not self._display_rect.isValid():
            return
            
        # 检查是否点击图片区域
        if not self._display_rect.contains(event.pos()):
            return
            
        # 计算点击的区域
        rel_x = (event.pos().x() - self._display_rect.x()) / self._display_rect.width()
        zone = int(rel_x * self.NUM_ZONES)
        zone = max(0, min(zone, self.NUM_ZONES - 1))
        
        self._selected_zone = zone
        self.zone_selected.emit(zone)
        self.update()
        
    def get_zone_info(self, zone_index: int) -> dict:
        """获取指定区域的详细信息
        
        Args:
            zone_index: 区域索引 (0-8)
            
        Returns:
            dict: 包含区域信息的字典
        """
        if not (0 <= zone_index < self.NUM_ZONES):
            return {}
            
        min_lum = zone_index * 32
        max_lum = min((zone_index + 1) * 32 - 1, 255)
        
        return {
            'index': zone_index,
            'name': f'Zone {zone_index}',
            'luminance_range': (min_lum, max_lum),
            'pixel_count': self._zone_stats[zone_index] if self._zone_stats else 0,
        }
```

---

### 阶段六：提取卡片基类（1天）

#### 任务 6.1: 分析公共结构

**对比 ColorCardPanel 和 LuminanceCard**:

| 功能 | ColorCardPanel | LuminanceCard | 公共 |
|:---:|:---:|:---:|:---:|
| 标题显示 | ✓ | ✓ | ✓ |
| 颜色显示 | ✓ | ✓ | ✓ |
| 信息标签 | ✓ | ✓ | ✓ |
| 复制功能 | ✓ | ✓ | ✓ |
| 多色彩模式 | ✓ | ✗ | ✗ |
| 明度区域 | ✗ | ✓ | ✗ |

---

#### 任务 6.2: 设计 BaseCard 基类

**文件**: `ui/widgets/cards/base.py`

```python
"""卡片基类模块"""

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QFrame, QGridLayout
)
from PySide6.QtCore import Qt, pyqtSignal
from PySide6.QtGui import QColor, QFont, QClipboard, QGuiApplication

from qfluentwidgets import CardWidget, PrimaryPushButton, FluentIcon


class BaseCard(QWidget):
    """卡片基类，提供统一的卡片UI结构
    
    功能：
        - 统一的标题样式
        - 颜色显示区域
        - 信息标签布局
        - 复制到剪贴板功能
        
    子类需要实现：
        - _setup_info_layout(): 设置信息布局
        - _update_display(data): 更新显示内容
        
    信号：
        data_copied(str): 数据被复制到剪贴板
    """
    
    data_copied = pyqtSignal(str)
    
    # 样式常量
    TITLE_FONT_SIZE = 14
    INFO_FONT_SIZE = 12
    COLOR_PREVIEW_SIZE = 60
    
    def __init__(self, title: str, parent=None):
        super().__init__(parent)
        self._title = title
        self._current_color: QColor = QColor()
        self._setup_ui()
        
    def _setup_ui(self):
        """设置UI布局"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(12)
        
        # 标题
        self._title_label = QLabel(self._title)
        self._title_label.setStyleSheet(f"""
            font-weight: bold;
            font-size: {self.TITLE_FONT_SIZE}px;
            color: {'white' if self._is_dark_theme() else 'black'};
        """)
        layout.addWidget(self._title_label)
        
        # 顶部区域：颜色预览 + 信息
        top_layout = QHBoxLayout()
        top_layout.setSpacing(15)
        
        # 颜色预览
        self._color_preview = QFrame()
        self._color_preview.setFixedSize(
            self.COLOR_PREVIEW_SIZE, 
            self.COLOR_PREVIEW_SIZE
        )
        self._color_preview.setStyleSheet("""
            QFrame {
                border: 2px solid #808080;
                border-radius: 8px;
                background-color: transparent;
            }
        """)
        top_layout.addWidget(self._color_preview)
        
        # 信息区域（子类填充）
        self._info_widget = QWidget()
        self._info_layout = QGridLayout(self._info_widget)
        self._info_layout.setSpacing(8)
        self._setup_info_layout()
        top_layout.addWidget(self._info_widget, stretch=1)
        
        layout.addLayout(top_layout)
        
        # 按钮区域
        self._button_layout = QHBoxLayout()
        self._button_layout.addStretch()
        self._setup_buttons()
        layout.addLayout(self._button_layout)
        
        layout.addStretch()
        
    def _setup_info_layout(self):
        """设置信息布局（子类重写）"""
        raise NotImplementedError("子类必须实现 _setup_info_layout 方法")
        
    def _setup_buttons(self):
        """设置按钮（子类重写）"""
        pass
        
    def set_color(self, color: QColor):
        """设置显示的颜色
        
        Args:
            color: QColor 对象
        """
        self._current_color = color
        self._color_preview.setStyleSheet(f"""
            QFrame {{
                border: 2px solid #808080;
                border-radius: 8px;
                background-color: {color.name()};
            }}
        """)
        
    def _create_info_label(self, text: str, row: int, col: int = 0):
        """创建信息标签
        
        Args:
            text: 标签文本
            row: 行位置
            col: 列位置
        """
        label = QLabel(text)
        label.setStyleSheet(f"""
            font-size: {self.INFO_FONT_SIZE}px;
            color: {'#cccccc' if self._is_dark_theme() else '#333333'};
        """)
        self._info_layout.addWidget(label, row, col)
        return label
        
    def _copy_to_clipboard(self, text: str):
        """复制文本到剪贴板
        
        Args:
            text: 要复制的文本
        """
        clipboard = QGuiApplication.clipboard()
        clipboard.setText(text)
        self.data_copied.emit(text)
        
    def _is_dark_theme(self) -> bool:
        """检测当前是否为深色主题"""
        from qfluentwidgets import isDarkTheme
        return isDarkTheme()
        
    def clear(self):
        """清空卡片内容"""
        self._current_color = QColor()
        self._color_preview.setStyleSheet("""
            QFrame {
                border: 2px solid #808080;
                border-radius: 8px;
                background-color: transparent;
            }
        """)
```

---

### 阶段七：合并直方图组件（1天）

#### 任务 7.1: 分析现有直方图组件

**对比 histogram_widget.py 和 luminance_histogram.py**:

| 功能 | HistogramWidget | LuminanceHistogram | 公共 |
|:---:|:---:|:---:|:---:|
| 直方图绘制 | ✓ | ✓ | ✓ |
| 数据设置 | ✓ | ✓ | ✓ |
| 清空 | ✓ | ✓ | ✓ |
| Zone 分区 | ✗ | ✓ | ✗ |
| 区域点击 | ✗ | ✓ | ✗ |
| 颜色渐变 | ✓ | ✗ | ✗ |

---

#### 任务 7.2: 设计 BaseHistogram 基类

**文件**: `ui/widgets/histograms/base.py`

```python
"""直方图基类模块"""

from typing import List, Optional
from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Signal
from PySide6.QtGui import QPainter, QColor, QPen, QLinearGradient


class BaseHistogram(QWidget):
    """直方图基类
    
    功能：
        - 绘制柱状图
        - 支持数据归一化
        - 自定义颜色
        
    子类需要实现：
        - _draw_custom_overlay(painter): 绘制自定义叠加内容
        
    信号：
        data_changed: 数据变化时发射
    """
    
    data_changed = Signal()
    
    def __init__(self, bins: int = 256, parent=None):
        super().__init__(parent)
        self._bins = bins
        self._data: List[int] = []
        self._max_value = 1
        self._bar_color = QColor(100, 150, 255)
        self._gradient: Optional[QLinearGradient] = None
        
        self.setMinimumHeight(100)
        self.setMaximumHeight(200)
        
    def set_data(self, data: List[int]):
        """设置直方图数据
        
        Args:
            data: 长度为 bins 的整数列表
            
        Raises:
            ValueError: 数据长度不匹配
        """
        if len(data) != self._bins:
            raise ValueError(f"数据长度必须为 {self._bins}，当前为 {len(data)}")
            
        self._data = data
        self._max_value = max(data) if data else 1
        self.data_changed.emit()
        self.update()
        
    def set_gradient(self, gradient: QLinearGradient):
        """设置渐变色
        
        Args:
            gradient: 线性渐变对象
        """
        self._gradient = gradient
        self.update()
        
    def set_bar_color(self, color: QColor):
        """设置柱状图颜色
        
        Args:
            color: 颜色对象
        """
        self._bar_color = color
        self._gradient = None
        self.update()
        
    def clear(self):
        """清空数据"""
        self._data = []
        self._max_value = 1
        self.update()
        
    def paintEvent(self, event):
        """绘制直方图"""
        if not self._data:
            self._draw_empty_state()
            return
            
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        width = self.width()
        height = self.height()
        bar_width = width / self._bins
        
        # 绘制背景
        painter.fillRect(self.rect(), QColor(30, 30, 30))
        
        # 绘制柱状图
        for i, value in enumerate(self._data):
            bar_height = (value / self._max_value) * height * 0.95
            x = i * bar_width
            y = height - bar_height
            
            # 确定颜色
            if self._gradient:
                color = self._gradient.interpolate(i / self._bins)
            else:
                color = self._bar_color
                
            painter.fillRect(
                int(x), int(y),
                max(1, int(bar_width)), int(bar_height),
                color
            )
            
        # 绘制子类特定的叠加内容
        self._draw_custom_overlay(painter)
        
    def _draw_empty_state(self):
        """绘制空状态"""
        painter = QPainter(self)
        painter.fillRect(self.rect(), QColor(30, 30, 30))
        
        # 绘制提示文字
        painter.setPen(QColor(100, 100, 100))
        painter.drawText(
            self.rect(),
            Qt.AlignmentFlag.AlignCenter,
            "暂无数据"
        )
        
    def _draw_custom_overlay(self, painter: QPainter):
        """绘制自定义叠加内容（子类重写）"""
        pass
```

---

### 阶段八：目录结构重组（1-2天）

#### 任务 8.1: 创建新目录结构

**执行命令**:
```bash
# 创建核心模块目录
mkdir -p core

# 创建工具模块目录
mkdir -p utils

# 创建 UI 模块目录
mkdir -p ui/interfaces
mkdir -p ui/canvases
mkdir -p ui/widgets/cards
mkdir -p ui/widgets/histograms
mkdir -p ui/dialogs

# 创建资源目录
mkdir -p resources/logo
mkdir -p resources/file
mkdir -p resources/styles

# 创建测试目录
mkdir -p tests

# 创建文档目录
mkdir -p docs
```

---

#### 任务 8.2: 迁移核心模块

**文件映射**:
| 原文件 | 新文件 | 操作 |
|:---|:---|:---|
| `color_utils.py` | `core/color.py` | 移动 + 重命名 |
| `config_manager.py` | `core/config.py` | 移动 + 重命名 |
| `version.py` | `core/version.py` | 移动 |

**core/__init__.py**:
```python
"""核心功能模块"""

from .color import (
    rgb_to_hsb,
    rgb_to_lab,
    rgb_to_hex,
    rgb_to_hsl,
    rgb_to_cmyk,
    get_color_info,
    get_luminance,
    get_zone,
    calculate_histogram,
    calculate_rgb_histogram,
)

from .config import ConfigManager, get_config_manager
from .version import VersionManager, version_manager

__all__ = [
    # 颜色函数
    'rgb_to_hsb',
    'rgb_to_lab',
    'rgb_to_hex',
    'rgb_to_hsl',
    'rgb_to_cmyk',
    'get_color_info',
    'get_luminance',
    'get_zone',
    'calculate_histogram',
    'calculate_rgb_histogram',
    # 配置
    'ConfigManager',
    'get_config_manager',
    # 版本
    'VersionManager',
    'version_manager',
]
```

---

#### 任务 8.3: 迁移工具模块

**文件映射**:
| 原文件 | 新文件 | 操作 |
|:---|:---|:---|
| `icon_utils.py`（图标部分） | `utils/icon.py` | 拆分 |
| `icon_utils.py`（平台部分） | `utils/platform.py` | 拆分 |

---

#### 任务 8.4: 迁移 UI 模块

**文件映射**:
| 原文件 | 新文件 | 操作 |
|:---|:---|:---|
| `widgets/main_window.py` | `ui/main_window.py` | 移动 |
| `widgets/image_canvas.py` | `ui/canvases/image.py` | 移动 + 重命名 |
| `widgets/luminance_canvas.py` | `ui/canvases/luminance.py` | 移动 + 重命名 |
| `widgets/color_card.py` | `ui/widgets/cards/color.py` | 移动 + 重命名 |
| `widgets/luminance_card.py` | `ui/widgets/cards/luminance.py` | 移动 + 重命名 |
| `widgets/color_picker.py` | `ui/widgets/color_picker.py` | 移动 |
| `widgets/hsb_color_wheel.py` | `ui/widgets/color_wheel.py` | 移动 + 重命名 |
| `widgets/histogram_widget.py` | `ui/widgets/histograms/luminance.py` | 移动 + 合并 |
| `widgets/luminance_histogram.py` | 合并到上述文件 | 删除 |
| `widgets/rgb_histogram_widget.py` | `ui/widgets/histograms/rgb.py` | 移动 + 重命名 |
| `widgets/settings_interface.py` | `ui/interfaces/settings.py` | 移动 + 重命名 |
| `widgets/about_dialog.py` | `ui/dialogs/about.py` | 移动 + 重命名 |
| `widgets/update_dialog.py` | `ui/dialogs/update.py` | 移动 + 重命名 |
| `widgets/zoom_viewer.py` | `ui/widgets/zoom_viewer.py` | 移动 |

---

#### 任务 8.5: 更新导入路径

**main.py 更新**:
```python
# 修改前
from widgets import MainWindow
from icon_utils import load_icon_universal, fix_windows_taskbar_icon_for_window

# 修改后
from ui import MainWindow
from utils.icon import load_icon_universal
from utils.platform import fix_windows_taskbar_icon_for_window
```

**ui/main_window.py 更新**:
```python
# 修改前
from widgets.image_canvas import ImageCanvas
from widgets.color_card import ColorCardPanel
from color_utils import get_color_info
from config_manager import get_config_manager

# 修改后
from .canvases.image import ImageCanvas
from .widgets.cards.color import ColorCardPanel
from core.color import get_color_info
from core.config import get_config_manager
```

---

### 阶段九：模块拆分（1天）

#### 任务 9.1: 拆分 main_window.py

**拆分方案**:

1. **ui/interfaces/color_extract.py**:
   - `ColorExtractInterface` 类
   - 约 150 行代码

2. **ui/interfaces/luminance_extract.py**:
   - `LuminanceExtractInterface` 类
   - 约 150 行代码

3. **ui/interfaces/settings.py**:
   - `SettingsInterface` 类
   - 约 200 行代码

4. **ui/main_window.py**:
   - 仅保留 `MainWindow` 类
   - 约 100 行代码

---

#### 任务 9.2: 拆分 icon_utils.py

**utils/icon.py**:
```python
"""图标工具模块"""

import sys
import os
from PySide6.QtGui import QIcon, QPixmap, QColor, QPainter
from PySide6.QtCore import Qt


def get_base_path() -> str:
    """获取应用程序基础路径"""
    if getattr(sys, 'frozen', False):
        if hasattr(sys, '_MEIPASS'):
            return sys._MEIPASS
        return os.path.dirname(sys.executable)
    return os.path.dirname(os.path.abspath(__file__))


def get_icon_path() -> str:
    """获取图标文件路径"""
    base_path = get_base_path()
    possible_paths = [
        os.path.join(base_path, 'resources', 'logo', 'Color Card_logo.ico'),
        os.path.join(base_path, 'resources', 'logo', 'logo.ico'),
        os.path.join(base_path, 'logo', 'Color Card_logo.ico'),
    ]
    
    for path in possible_paths:
        if os.path.exists(path):
            return path
    return None


def load_icon_universal() -> QIcon:
    """加载应用程序图标"""
    icon_path = get_icon_path()
    
    if icon_path:
        icon = QIcon(icon_path)
        if not icon.isNull():
            return icon
    
    return create_fallback_icon()


def create_fallback_icon() -> QIcon:
    """创建后备图标"""
    try:
        pixmap = QPixmap(32, 32)
        pixmap.fill(QColor("#0078d4"))
        
        painter = QPainter(pixmap)
        painter.setPen(QColor('white'))
        painter.drawText(pixmap.rect(), Qt.AlignmentFlag.AlignCenter, "CC")
        painter.end()
        
        return QIcon(pixmap)
    except Exception:
        return QIcon()
```

**utils/platform.py**:
```python
"""平台相关工具模块"""

import os
import ctypes
from PySide6.QtCore import QTimer, QObject, Signal


def set_app_user_model_id(app_id: str = 'HXiaoStudio.ColorCard.1.0.0') -> bool:
    """设置 Windows AppUserModelID"""
    if os.name != 'nt':
        return False
    
    try:
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(app_id)
        return True
    except Exception:
        return False


def fix_windows_taskbar_icon_for_window(window) -> bool:
    """修复 Windows 任务栏图标"""
    if os.name != 'nt':
        return False
    
    try:
        if not window.isVisible():
            window.show()
        window.raise_()
        window.activateWindow()
        
        hwnd = int(window.winId())
        
        # 获取图标路径
        from .icon import get_icon_path
        icon_path = get_icon_path()
        
        if not icon_path:
            return False
        
        user32 = ctypes.windll.user32
        
        if icon_path.lower().endswith('.ico'):
            h_icon = user32.LoadImageW(
                None, icon_path, 1, 0, 0, 0x00000010
            )
        else:
            return False
        
        if h_icon:
            user32.SendMessageW(hwnd, 0x0080, 1, h_icon)
            user32.SendMessageW(hwnd, 0x0080, 0, h_icon)
            user32.UpdateWindow(hwnd)
            return True
        
        return False
    except Exception:
        return False
```

---

### 阶段十：开源准备（最后完善）

#### 任务 10.1: 添加开源许可证

**选择**: GPL-3.0 或 MIT License

**文件**: `LICENSE`
```
GNU GENERAL PUBLIC LICENSE
Version 3, 29 June 2007

Copyright (c) 2026 浮晓 HXiao Studio

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
...
```

---

#### 任务 10.2: 完善 README.md

**必需内容**:
- 项目简介
- 功能特性
- 安装说明
- 使用说明
- 截图
- 技术栈
- 许可证

---

#### 任务 10.3: 创建 CHANGELOG.md

```markdown
# 更新日志

## [1.0.0] - 2026-02-04

### 新增
- 初始版本发布
- 图片颜色提取功能
- 明度分析功能
- 支持 HSB、LAB、HSL、CMYK、RGB 色彩模式

### 重构
- 代码结构优化
- 提取公共基类
- 统一代码规范
```

---

## 四、重构执行计划

### 4.1 时间安排

| 阶段 | 任务 | 预计时间 | 优先级 | 依赖 |
|:---:|:---|:---:|:---:|:---|
| **阶段一** | 导入规范整理 | 1天 | 最高 | 无 |
| | 1.1 统一导入顺序 | 4小时 | | |
| | 1.2 清理未使用导入 | 2小时 | | |
| | 1.3 合并重复导入 | 2小时 | | |
| **阶段二** | 代码清理与优化 | 1-2天 | 最高 | 阶段一 |
| | 2.1 删除未使用变量 | 2小时 | | |
| | 2.2 删除未使用函数 | 2小时 | | |
| | 2.3 清理调试代码 | 2小时 | | |
| | 2.4 优化重复逻辑 | 4小时 | | |
| | 2.5 完善异常处理 | 2小时 | | |
| | 2.6 添加类型注解 | 4小时 | | |
| **阶段三** | 命名规范统一 | 0.5天 | 最高 | 阶段二 |
| | 3.1 统一文件名 | 2小时 | | |
| | 3.2 统一类名 | 1小时 | | |
| | 3.3 统一变量名 | 1小时 | | |
| **阶段四** | 文档完善 | 0.5天 | 高 | 阶段三 |
| | 4.1 完善文档字符串 | 2小时 | | |
| | 4.2 添加文件头 | 1小时 | | |
| | 4.3 添加关键注释 | 1小时 | | |
| **阶段五** | 提取画布基类 | 1-2天 | 高 | 阶段四 |
| | 5.1 分析公共逻辑 | 2小时 | | |
| | 5.2 设计基类 | 4小时 | | |
| | 5.3 迁移 ImageCanvas | 4小时 | | |
| | 5.4 迁移 LuminanceCanvas | 4小时 | | |
| | 5.5 测试验证 | 2小时 | | |
| **阶段六** | 提取卡片基类 | 1天 | 高 | 阶段五 |
| | 6.1 分析公共结构 | 2小时 | | |
| | 6.2 设计基类 | 2小时 | | |
| | 6.3 迁移 ColorCard | 2小时 | | |
| | 6.4 迁移 LuminanceCard | 2小时 | | |
| | 6.5 测试验证 | 2小时 | | |
| **阶段七** | 合并直方图 | 1天 | 高 | 阶段六 |
| | 7.1 分析现有组件 | 2小时 | | |
| | 7.2 设计基类 | 2小时 | | |
| | 7.3 创建 LuminanceHistogram | 2小时 | | |
| | 7.4 创建 RGBHistogram | 2小时 | | |
| | 7.5 测试验证 | 2小时 | | |
| **阶段八** | 目录结构重组 | 1-2天 | 高 | 阶段七 |
| | 8.1 创建目录结构 | 1小时 | | |
| | 8.2 迁移核心模块 | 2小时 | | |
| | 8.3 迁移工具模块 | 2小时 | | |
| | 8.4 迁移 UI 模块 | 4小时 | | |
| | 8.5 更新导入路径 | 2小时 | | |
| | 8.6 全面测试 | 4小时 | | |
| **阶段九** | 模块拆分 | 1天 | 中 | 阶段八 |
| | 9.1 拆分 main_window.py | 4小时 | | |
| | 9.2 拆分 icon_utils.py | 2小时 | | |
| | 9.3 更新模块导出 | 2小时 | | |
| **阶段十** | 开源准备 | 0.5天 | 低 | 最后 |
| | 10.1 添加许可证 | 1小时 | | |
| | 10.2 完善 README | 2小时 | | |
| | 10.3 创建 CHANGELOG | 1小时 | | |

**代码整理总计**: 约 10-14 天

### 4.2 验证检查点

每个阶段完成后必须验证：

**阶段一验证**:
- [ ] 所有文件导入顺序符合规范
- [ ] 无未使用的导入
- [ ] 程序能正常启动

**阶段二验证**:
- [ ] 无未使用的变量和函数
- [ ] ~~无调试代码残留~~（保留 `print()` 调试语句）
- [ ] 异常处理完善
- [ ] 程序能正常启动

**阶段三验证**:
- [ ] 文件名风格统一
- [ ] 类名符合规范
- [ ] 变量名符合规范
- [ ] 程序能正常启动

**阶段四验证**:
- [ ] 所有公共类有文档字符串
- [ ] 所有公共方法有文档字符串
- [ ] 关键逻辑有注释

**阶段五验证**:
- [ ] 画布基类功能完整
- [ ] ImageCanvas 继承正确
- [ ] LuminanceCanvas 继承正确
- [ ] 取色功能正常
- [ ] 区域选择功能正常

**阶段六验证**:
- [ ] 卡片基类功能完整
- [ ] ColorCard 继承正确
- [ ] LuminanceCard 继承正确
- [ ] 颜色显示正常
- [ ] 复制功能正常

**阶段七验证**:
- [ ] 直方图基类功能完整
- [ ] LuminanceHistogram 继承正确
- [ ] RGBHistogram 继承正确
- [ ] 直方图显示正常

**阶段八验证**:
- [ ] 新目录结构完整
- [ ] 所有文件迁移正确
- [ ] 导入路径更新正确
- [ ] 程序能正常启动
- [ ] 所有功能正常

**阶段九验证**:
- [ ] main_window.py 拆分正确
- [ ] icon_utils.py 拆分正确
- [ ] 模块导出正确
- [ ] 程序能正常启动

---

## 五、风险与应对

| 风险 | 可能性 | 影响 | 应对措施 |
|:---|:---:|:---:|:---|
| 重构引入 Bug | 中 | 高 | 每阶段完成后全面测试 |
| 功能回归 | 中 | 高 | 建立功能测试清单 |
| 导入循环 | 中 | 中 | 使用延迟导入 |
| 时间超期 | 低 | 中 | 优先完成高优先级任务 |
| 基类设计不当 | 低 | 高 | 先设计后实现，充分测试 |

---

## 六、附录

### 6.1 参考文档

- [开发规范.md](./开发规范.md)
- [代码审查报告.md](./代码审查报告.md)
- [PEP 8 - Python代码风格指南](https://peps.python.org/pep-0008/)
- [PyQt Best Practices](https://www.riverbankcomputing.com/static/Docs/PyQt6/)

### 6.2 工具推荐

| 用途 | 工具 | 命令 |
|:---|:---|:---|
| 代码格式化 | Black | `black .` |
| 导入排序 | isort | `isort .` |
| 代码检查 | Flake8 | `flake8 .` |
| 类型检查 | MyPy | `mypy core/ utils/` |
| 测试运行 | Pytest | `pytest tests/` |

### 6.3 功能测试清单

重构过程中需要验证的功能：

- [ ] 打开图片文件
- [ ] 拖拽图片到画布
- [ ] 拖动取色点
- [ ] 颜色值显示
- [ ] 切换色彩模式
- [ ] 明度直方图显示
- [ ] 区域选择
- [ ] 设置保存和加载
- [ ] 窗口状态记忆
- [ ] 右键菜单
- [ ] 复制颜色值

---

**计划制定**: 青山公仔  
**最后更新**: 2026-02-04
