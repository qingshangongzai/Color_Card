# Color Extractor 开发规范

## 1. 概述

本规范旨在指导 Color Extractor 图片颜色提取器项目的后续开发，确保代码的一致性、可维护性和可扩展性。

### 1.1 项目简介

Color Extractor 是一个基于 PySide6 开发的 GUI 程序，用于从图片中提取颜色，支持多种色彩模式（HSB、LAB、HSL、CMYK、RGB）和16进制颜色值显示，以及明度分析。核心功能包括：

- 图片导入（JPG、PNG、BMP、GIF）
- **色彩提取**：5个可拖动取色点，实时显示选定的两种色彩模式和16进制颜色值
- **多色彩模式支持**：支持 HSB、LAB、HSL、CMYK、RGB 五种色彩模式，用户可自定义显示任意两种
- **16进制颜色值**：显示并支持一键复制到剪贴板
- **明度提取**：5个可拖动取色点，显示明度区域编号（Zone 0-1 到 Zone 7-8）
- 明度直方图可视化
- 双面板数据同步
- 设置面板：支持开关16进制颜色值显示和色彩模式选择

### 1.2 开发环境

- **操作系统**：Windows 10/11
- **Python 版本**：3.x
- **GUI 框架**：PySide6 + PySide6-Fluent-Widgets
- **推荐 IDE**：VS Code、PyCharm、Trae

### 1.3 项目结构

```
d:\青山公仔\应用\Py测试\取色卡\
├── main.py                  # 程序入口
├── requirements.txt         # 项目依赖
├── version.py               # 版本管理模块
├── version_info.txt         # Windows EXE 版本信息文件
├── color_utils.py           # 颜色转换工具（RGB ↔ HSB/LAB/16进制/明度）
├── config_manager.py        # 配置管理模块（状态保存和加载）
├── icon_utils.py            # Windows 任务栏图标显示支持
├── README.md                # 项目文档
├── 开发规范.md              # 本文件
└── widgets/
    ├── __init__.py          # 统一导出接口
    ├── main_window.py       # 主窗口（FluentWindow）
    ├── image_canvas.py      # 图片画布（色彩提取）
    ├── luminance_canvas.py  # 明度提取画布
    ├── color_picker.py      # 取色点组件
    ├── color_card.py        # 色卡面板（含16进制显示）
    ├── histogram_widget.py  # 明度直方图组件
    ├── zoom_viewer.py       # 放大视图组件（拖动时显示）
    ├── settings_interface.py # 设置面板
    └── about_dialog.py      # 关于对话框
```

---

## 2. 代码组织规范

### 2.1 文件命名规范

- 采用小写字母和下划线命名，如 `color_utils.py`
- 核心功能模块使用清晰的描述性名称
- 组件文件应反映其功能，如 `color_picker.py`

### 2.2 模块划分

| 模块类型 | 职责 | 示例文件 |
|:---:|:---:|:---:|
| 入口模块 | 应用程序入口，初始化 QApplication | `main.py` |
| 工具模块 | 颜色空间转换、明度计算、直方图等通用功能 | `color_utils.py` |
| 图标模块 | Windows 任务栏图标显示支持 | `icon_utils.py` |
| 窗口模块 | 主窗口实现，管理双面板导航 | `main_window.py` |
| 画布模块 | 图片显示和取色点管理（色彩/明度） | `image_canvas.py`, `luminance_canvas.py` |
| 组件模块 | 可复用的 UI 组件 | `color_picker.py`, `color_card.py`, `histogram_widget.py` |

### 2.3 导入规范

- 按模块类型分组导入：标准库 → 第三方库 → 项目模块
- 使用绝对导入，保持清晰
- 避免循环导入

```python
# 标准库导入
import sys
import math

# 第三方库导入
from PySide6.QtWidgets import QApplication, QMainWindow
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QPainter, QColor
from qfluentwidgets import FluentWindow, setTheme, Theme, setThemeColor, FluentIcon

# 项目模块导入
from widgets import MainWindow
from color_utils import get_color_info
```

---

## 3. 代码编写规范

### 3.1 基本规范

- 遵循 **PEP 8** 代码风格规范
- 使用 4 个空格缩进
- 行长度限制在 100 字符以内
- 使用清晰、有意义的变量和函数命名

### 3.2 命名规范

| 类型 | 规范 | 示例 |
|:---:|:---:|:---:|
| 类名 | 驼峰命名法 (CamelCase) | `ColorPicker`, `ImageCanvas` |
| 函数/方法 | 小写+下划线 | `extract_color()`, `update_picker_positions()` |
| 变量 | 小写+下划线 | `picker_positions`, `original_pixmap` |
| 常量 | 大写+下划线 | `PICKER_RADIUS = 12` |
| 私有属性 | 单下划线前缀 | `_dragging`, `_color` |

### 3.3 文档字符串规范

- 所有公共类和方法必须添加文档字符串
- 使用简洁的中文描述
- 复杂逻辑添加行内注释

```python
def rgb_to_hsb(r, g, b):
    """将RGB转换为HSB (Hue, Saturation, Brightness)"""
    # 归一化到 0-1 范围
    r, g, b = r / 255.0, g / 255.0, b / 255.0
    h, s, v = colorsys.rgb_to_hsv(r, g, b)
    return h * 360, s * 100, v * 100


class ImageCanvas(QWidget):
    """图片显示画布，支持取色点拖动"""
    
    color_picked = pyqtSignal(int, tuple)  # 信号：索引, RGB颜色
    
    def set_image(self, image_path):
        """加载并显示图片
        
        Args:
            image_path: 图片文件的完整路径
        """
        # 实现代码...
```

### 3.4 信号命名规范

- 信号名使用小写+下划线
- 信号名应描述动作或状态变化
- 添加注释说明信号参数

```python
class ImageCanvas(QWidget):
    color_picked = pyqtSignal(int, tuple)      # 信号：索引, RGB颜色
    image_loaded = pyqtSignal(str)              # 信号：图片路径
    position_changed = pyqtSignal(int, QPoint)  # 信号：索引, 新位置
    image_cleared = pyqtSignal()                # 信号：图片已清空（用于同步）
```

**同步信号命名建议：**
- 使用 `*_cleared` 表示数据已清除，用于触发同步操作
- 使用 `*_changed` 表示状态变化，用于更新关联组件
- 使用 `*_requested` 表示用户请求，用于触发对话框或操作

---

## 4. PyQt6 开发规范

### 4.1 PySide6-Fluent-Widgets 使用规范

- 主窗口继承 `FluentWindow` 而非 `QMainWindow`
- 使用 `setTheme()` 设置主题（Theme.AUTO / Theme.LIGHT / Theme.DARK）
- 使用 `setThemeColor()` 设置主题色
- 使用 `addSubInterface()` 添加导航界面
- 使用 `qrouter` 管理页面路由

```python
from qfluentwidgets import FluentWindow, setTheme, Theme, setThemeColor, FluentIcon, NavigationItemPosition, qrouter

# 设置主题
setTheme(Theme.AUTO)
setThemeColor('#0078d4')

# 创建主窗口
class MainWindow(FluentWindow):
    def __init__(self):
        super().__init__()
        self.create_sub_interface()
        self.setup_navigation()

    def create_sub_interface(self):
        """创建子界面"""
        self.interface = QWidget()
        self.interface.setObjectName('interface')
        self.stackedWidget.addWidget(self.interface)

    def setup_navigation(self):
        """设置导航栏"""
        self.addSubInterface(
            self.interface,
            FluentIcon.PALETTE,
            "界面名称",
            position=NavigationItemPosition.TOP
        )
```

#### 4.1.1 导航栏 Logo 与返回按钮规范

**隐藏返回按钮并显示 Logo：**

- 使用 `setReturnButtonVisible(False)` 隐藏返回按钮
- 使用 `QIcon` 加载 ICO 文件以获取最佳分辨率
- 使用 `icon.actualSize()` 获取 ICO 文件中可用的最佳分辨率
- 通过 `navigationInterface.panel.topLayout` 访问顶部布局
- 使用 `insertWidget()` 在布局开头插入 Logo
- **高 DPI 支持**：使用 `devicePixelRatio()` 获取屏幕缩放比例，确保在高分辨率屏幕上图标清晰显示

```python
from PySide6.QtWidgets import QLabel
from PySide6.QtGui import QIcon
from PySide6.QtCore import Qt, QSize

class MainWindow(FluentWindow):
    def setup_navigation(self):
        """设置导航栏"""
        # 隐藏返回按钮
        self.navigationInterface.setReturnButtonVisible(False)

        # 添加 Logo
        self._setup_logo()

        # 添加其他导航项...

    def _setup_logo(self):
        """在导航栏左上角设置 Logo"""
        logo_label = QLabel(self.navigationInterface.panel)
        logo_label.setObjectName('logoLabel')

        # 使用 QIcon 加载 ICO 文件以获取最佳分辨率
        icon = QIcon('path/to/logo.ico')

        # 获取设备像素比（支持高 DPI 屏幕）
        pixel_ratio = self.devicePixelRatio()

        # 请求更大的图标尺寸以获得更好的质量（在高 DPI 屏幕上自动调整）
        icon_size = int(64 * pixel_ratio)
        pixmap = icon.pixmap(icon.actualSize(QSize(icon_size, icon_size)))

        if not pixmap.isNull():
            # 高质量缩放
            target_size = int(28 * pixel_ratio)
            scaled_pixmap = pixmap.scaled(
                target_size, target_size,
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            # 设置设备像素比，确保在高 DPI 屏幕上正确显示
            scaled_pixmap.setDevicePixelRatio(pixel_ratio)

            logo_label.setPixmap(scaled_pixmap)
            logo_label.setFixedSize(40, 40)
            logo_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

            # 插入到顶部布局开头
            top_layout = self.navigationInterface.panel.topLayout
            top_layout.insertWidget(0, logo_label, 0, Qt.AlignTop)
```

**关键优化点：**
1. **请求更大的图标尺寸**：使用 64px 而不是 32px，让 `actualSize()` 能获取更高质量的图标数据
2. **设备像素比支持**：通过 `devicePixelRatio()` 自动适应高 DPI 屏幕（如 4K 显示器、Retina 屏幕）
3. **设置像素比**：使用 `setDevicePixelRatio()` 告知 Qt 图标的实际像素密度，避免在高分辨率屏幕上模糊
4. **高质量缩放**：始终使用 `SmoothTransformation` 进行双线性插值缩放

### 4.1.2 Windows 任务栏图标显示规范

Windows 任务栏图标显示需要特殊处理，以确保打包后的 EXE 文件也能正常显示自定义图标。

**核心原理：**
1. **AppUserModelID 设置**：Windows 使用 AppUserModelID 来识别和分组任务栏上的应用程序
2. **任务栏图标修复**：通过 Windows API 强制刷新窗口图标

**实现步骤：**

1. **在 `main.py` 中设置 AppUserModelID**（必须在创建 QApplication 之前）：

```python
import os
import ctypes

def set_app_user_model_id():
    """设置 AppUserModelID"""
    if os.name != 'nt':
        return False
    try:
        app_id = 'HXiaoStudio.ColorCard.1.0.0'
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(app_id)
        return True
    except Exception:
        return False

# 立即调用（在导入 PySide6 之前）
set_app_user_model_id()
```

2. **使用 `icon_utils.py` 模块管理图标**：

```python
from icon_utils import load_icon_universal, fix_windows_taskbar_icon_for_window

# 在 main() 函数中
def main():
    app = QApplication(sys.argv)
    
    # 设置应用程序图标
    app_icon = load_icon_universal()
    app.setWindowIcon(app_icon)
    
    window = MainWindow()
    window.show()
    
    # 修复任务栏图标（在窗口显示后调用）
    from PySide6.QtCore import QTimer
    QTimer.singleShot(100, lambda: fix_windows_taskbar_icon_for_window(window))
```

3. **对话框窗口也需要修复任务栏图标**：

```python
from icon_utils import load_icon_universal, fix_windows_taskbar_icon_for_window

class AboutDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        # 设置窗口图标
        self.setWindowIcon(load_icon_universal())
        
        # 修复任务栏图标（在窗口显示后调用）
        from PySide6.QtCore import QTimer
        QTimer.singleShot(100, lambda: fix_windows_taskbar_icon_for_window(self))
```

**注意事项：**
- 主窗口的图标由 `_setup_logo()` 统一设置，不要在 `main.py` 中重复设置 `window.setWindowIcon()`
- 仅设置 `app.setWindowIcon()` 和调用 `fix_windows_taskbar_icon_for_window()`
- 图标文件路径：`logo/Color Card_logo.ico`
- 支持开发环境和 PyInstaller 打包后的环境（自动检测 `sys._MEIPASS`）

### 4.2 界面组织规范

- 每个功能模块创建独立的 `QWidget` 子类作为界面
- 界面类使用 `setObjectName()` 设置唯一标识
- 将界面添加到 `stackedWidget` 中
- 使用 `qrouter.setDefaultRouteKey()` 设置默认路由

```python
class ColorExtractInterface(QWidget):
    """色彩提取界面"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
        self.setup_connections()
    
    def setup_ui(self):
        """设置界面布局"""
        layout = QVBoxLayout(self)
        # 添加控件...
    
    def setup_connections(self):
        """设置信号连接"""
        # 连接信号...
```

### 4.3 信号与槽

- 使用 `Signal` 定义信号
- 信号连接应在初始化时完成
- 槽函数命名使用 `on_` 前缀

```python
# 信号定义
class ImageCanvas(QWidget):
    color_picked = Signal(int, tuple)
```
# 信号连接
self.image_canvas.color_picked.connect(self.on_color_picked)

# 槽函数实现
def on_color_picked(self, index, rgb):
    """颜色提取回调"""
    color_info = get_color_info(*rgb)
    self.color_card_panel.update_color(index, color_info)
```

### 4.4 自定义控件规范

- 继承自合适的 QWidget 子类
- 重写 `paintEvent` 实现自定义绘制
- 重写鼠标事件实现交互

```python
class ColorPicker(QWidget):
    """可拖动的圆形取色点"""
    
    def __init__(self, index, parent=None):
        super().__init__(parent)
        self.index = index
        self.radius = 12
        self.setFixedSize(self.radius * 2, self.radius * 2)
    
    def paintEvent(self, event):
        """绘制取色点"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        # 绘制代码...
    
    def mousePressEvent(self, event):
        """鼠标按下事件"""
        if event.button() == Qt.MouseButton.LeftButton:
            self._dragging = True
            event.accept()
```

### 4.5 样式设置规范

- 使用 `setTheme()` 设置全局主题，避免手动设置样式表
- 使用 `setThemeColor()` 设置主题色，保持界面风格统一
- 特殊控件需要自定义样式时，使用 Fluent 风格的设计规范
- 避免使用 QSS 样式表，优先使用 Fluent 组件
- **禁止使用硬编码颜色值**（如 `#333`, `#888`, `#cccccc` 等），应使用主题感知颜色

#### 4.5.1 主题感知颜色使用规范

所有自定义控件必须使用 `isDarkTheme()` 检测当前主题，动态返回适配的颜色值。

```python
from qfluentwidgets import isDarkTheme
from PySide6.QtGui import QColor


def get_text_color(secondary=False):
    """获取主题文本颜色
    
    Args:
        secondary: 是否为次要文本（标签等）
    
    Returns:
        QColor: 适配当前主题的文本颜色
    """
    if isDarkTheme():
        return QColor(160, 160, 160) if secondary else QColor(255, 255, 255)
    else:
        return QColor(120, 120, 120) if secondary else QColor(40, 40, 40)


def get_placeholder_color():
    """获取占位符颜色（空状态背景）"""
    if isDarkTheme():
        return QColor(60, 60, 60)
    else:
        return QColor(204, 204, 204)


def get_border_color():
    """获取边框颜色"""
    if isDarkTheme():
        return QColor(80, 80, 80)
    else:
        return QColor(221, 221, 221)
```

#### 4.5.2 样式设置示例

```python
# 设置全局主题
setTheme(Theme.AUTO)
setThemeColor('#0078d4')

# 错误示例：禁止使用硬编码颜色
self.label.setStyleSheet("color: #888;")  # ❌ 禁止
self.setStyleSheet("background-color: #2a2a2a;")  # ❌ 禁止

# 正确示例：使用主题感知颜色
text_color = get_text_color(secondary=True)
self.label.setStyleSheet(f"color: {text_color.name()};")  # ✅ 推荐
```

#### 4.5.3 自定义绘制控件规范

对于需要自定义 `paintEvent` 的控件，必须在绘制时动态获取主题颜色：

```python
class CustomWidget(QWidget):
    def paintEvent(self, event):
        painter = QPainter(self)
        
        # 获取主题背景色
        if isDarkTheme():
            bg_color = QColor(50, 50, 50)
            text_color = QColor(255, 255, 255)
        else:
            bg_color = QColor(240, 240, 240)
            text_color = QColor(40, 40, 40)
        
        # 使用主题颜色绘制
        painter.fillRect(self.rect(), bg_color)
        painter.setPen(text_color)
        painter.drawText(self.rect(), Qt.AlignmentFlag.AlignCenter, "文本")
```

#### 4.5.4 例外情况

以下情况**允许**使用固定颜色：
- 图片显示区域（如 `image_canvas.py`, `luminance_canvas.py` 的画布背景）
- 直方图等数据可视化组件（如 `histogram_widget.py`）
- 颜色块本身显示的颜色值
- 需要精确色彩还原的专业功能区域

### 4.6 右键菜单规范

- 使用 `RoundMenu` 创建 Fluent 风格的右键菜单
- 使用 `Action` 创建菜单项，支持 Fluent 图标
- 菜单标题使用空字符串 `""` 而非父组件
- 右键菜单仅在适当场景下显示（如已加载图片时）

```python
from qfluentwidgets import RoundMenu, Action, FluentIcon

def contextMenuEvent(self, event):
    """右键菜单事件"""
    # 只有在满足条件时才显示右键菜单
    if not self.should_show_menu():
        return

    # 创建菜单，标题参数为空字符串
    menu = RoundMenu("")

    # 添加带图标的菜单项
    change_action = Action(FluentIcon.PHOTO, "更换图片")
    change_action.triggered.connect(self.change_image_requested.emit)
    menu.addAction(change_action)

    clear_action = Action(FluentIcon.DELETE, "清空图片")
    clear_action.triggered.connect(self.clear_image_requested.emit)
    menu.addAction(clear_action)

    # 在鼠标位置显示菜单
    menu.exec(event.globalPos())
```

---

## 5. 颜色处理规范

### 5.1 颜色空间转换

- 所有颜色转换函数放在 `color_utils.py`
- 使用标准算法进行颜色空间转换
- 返回结果应包含完整的颜色信息（包括16进制值）

```python
def rgb_to_hex(r, g, b):
    """将RGB转换为16进制颜色值"""
    return f"#{r:02X}{g:02X}{b:02X}"


def get_color_info(r, g, b):
    """获取颜色的完整信息"""
    h, s, b_val = rgb_to_hsb(r, g, b)
    l, a, b_lab = rgb_to_lab(r, g, b)

    return {
        'rgb': (r, g, b),
        'hsb': (round(h), round(s), round(b_val)),
        'lab': (round(l), round(a), round(b_lab)),
        'hex': rgb_to_hex(r, g, b)
    }
```

### 5.2 明度计算规范

#### 5.2.1 明度计算原理

明度计算遵循 **Lightroom**、**Photoshop** 等专业软件的标准方法，包含完整的 **sRGB Gamma 校正**流程：

1. **归一化**：将 0-255 的 RGB 值转换到 0.0-1.0 范围
2. **Gamma 解码**：将 sRGB 值转换到线性空间（使用标准 sRGB gamma 曲线）
3. **Rec. 709 加权**：在线性空间应用人眼感知权重（绿>红>蓝）
4. **Gamma 编码**：将结果转换回 sRGB 空间
5. **反归一化**：将 0.0-1.0 结果转换回 0-255

**为什么需要 Gamma 校正？**
- sRGB 图片存储的值是经过 gamma 编码的非线性值
- 人眼对亮度的感知是线性的，必须在线性空间进行加权计算
- 缺少 gamma 校正会导致颜色明度计算偏差（如纯红色会显得过暗）

#### 5.2.2 明度计算实现

```python
def get_luminance(r, g, b):
    """计算像素的明度值 (0-255)

    使用 Rec. 709 标准计算亮度值，包含 sRGB Gamma 校正
    这是 Lightroom、Photoshop 等专业软件使用的标准方法
    """
    # 步骤1: 归一化到 0-1 范围
    r_norm = r / 255.0
    g_norm = g / 255.0
    b_norm = b / 255.0

    # 步骤2: sRGB Gamma 解码（转换到线性空间）
    def srgb_to_linear(c):
        if c <= 0.04045:
            return c / 12.92
        else:
            return ((c + 0.055) / 1.055) ** 2.4

    r_linear = srgb_to_linear(r_norm)
    g_linear = srgb_to_linear(g_norm)
    b_linear = srgb_to_linear(b_norm)

    # 步骤3: 在线性空间应用 Rec. 709 权重
    luminance_linear = 0.2126 * r_linear + 0.7152 * g_linear + 0.0722 * b_linear

    # 步骤4: 将结果编码回 sRGB Gamma 空间
    def linear_to_srgb(c):
        if c <= 0.0031308:
            return c * 12.92
        else:
            return 1.055 * (c ** (1.0 / 2.4)) - 0.055

    luminance_srgb = linear_to_srgb(luminance_linear)

    # 步骤5: 转换回 0-255 范围
    return min(255, round(luminance_srgb * 255))
```

#### 5.2.3 Zone 分区规范

将 0-255 的明度值分为8个区域（Zone System），使用专业摄影术语描述：

| Zone | 明度范围 | 描述 | 摄影术语 |
|:---:|:---:|:---:|:---:|
| Zone 0-1 | 0-31 | 极暗（纯黑） | 黑色 |
| Zone 1-2 | 32-63 | 暗部 | 阴影 |
| Zone 2-3 | 64-95 | 偏暗 | 暗部 |
| Zone 3-4 | 96-127 | 中灰 | 中间调 |
| Zone 4-5 | 128-159 | 偏亮 | 亮部 |
| Zone 5-6 | 160-191 | 亮部 | 高光 |
| Zone 6-7 | 192-223 | 很亮 | 白色 |
| Zone 7-8 | 224-255 | 极亮（纯白） | 极白 |

**直方图交互功能**：
- 点击直方图某一 Zone 区域时，在图片中高亮标记该亮度范围的像素
- 鼠标按住时持续显示高亮，松开时自动消失
- 支持在直方图上拖动切换不同 Zone

```python
def get_zone(luminance):
    """根据明度值返回区域编号"""
    zone_index = min(luminance // 32, 7)
    return f"{zone_index}-{zone_index + 1}"

def get_zone_bounds(zone_str):
    """获取区域对应的明度范围"""
    start = int(zone_str.split('-')[0])
    return (start * 32, (start + 1) * 32 - 1)
```

#### 5.2.4 直方图计算规范

直方图计算使用采样优化提高性能，同时确保边缘像素不被遗漏：

```python
def calculate_histogram(image, sample_step=4):
    """计算图片的明度直方图（使用采样优化）

    Args:
        image: QImage 对象
        sample_step: 采样步长，每隔N个像素采样一次（默认4）

    Returns:
        长度为256的列表，表示每个明度值的像素数量
    """
    histogram = [0] * 256

    if image is None or image.isNull():
        return histogram

    width = image.width()
    height = image.height()

    # 采样计算直方图
    for y in range(0, height, sample_step):
        for x in range(0, width, sample_step):
            color = image.pixelColor(x, y)
            luminance = get_luminance(color.red(), color.green(), color.blue())
            histogram[luminance] += 1

    # 额外采样边缘像素，确保高亮区域不被遗漏
    if width > 0:
        right_x = width - 1
        for y in range(0, height, sample_step):
            color = image.pixelColor(right_x, y)
            luminance = get_luminance(color.red(), color.green(), color.blue())
            histogram[luminance] += 1

    if height > 0:
        bottom_y = height - 1
        for x in range(0, width, sample_step):
            color = image.pixelColor(x, bottom_y)
            luminance = get_luminance(color.red(), color.green(), color.blue())
            histogram[luminance] += 1

    # 采样右下角像素
    if width > 0 and height > 0:
        color = image.pixelColor(width - 1, height - 1)
        luminance = get_luminance(color.red(), color.green(), color.blue())
        histogram[luminance] += 1

    return histogram
```

### 5.3 颜色值显示规范

- HSB 值：H 显示为度(°)，S/B 显示为百分比(%)
- LAB 值：直接显示数值
- RGB 值：用于颜色块显示
- 16进制值：显示为 `#RRGGBB` 格式（大写），支持复制到剪贴板
- 明度区域：显示为 "Zone X-Y" 格式

### 5.4 多色彩模式支持规范

#### 5.4.1 支持的色彩模式

系统支持以下五种色彩模式，用户可通过设置面板选择显示任意两种：

| 模式 | 说明 | 显示格式 |
|:---:|:---:|:---:|
| HSB | 色相、饱和度、亮度 | H: 360°, S: 100%, B: 100% |
| LAB | CIE LAB 色彩空间 | L: 100, a: -128, b: 128 |
| HSL | 色相、饱和度、明度 | H: 360°, S: 100%, L: 100% |
| CMYK | 印刷四色模式 | C: 100%, M: 100%, Y: 100%, K: 100% |
| RGB | 红绿蓝（显示值） | R: 255, G: 255, B: 255 |

#### 5.4.2 色彩模式配置

- 配置键：`settings.color_modes`
- 默认值：`["HSB", "LAB"]`
- 值类型：包含两个模式名称字符串的列表

#### 5.4.3 色彩模式切换实现

**在 `color_utils.py` 中：**
- 所有颜色转换函数返回统一的字典格式
- 字典键使用小写模式名（如 `'hsb'`, `'lab'`, `'hsl'`）

```python
def get_color_info(r, g, b):
    """获取颜色的完整信息"""
    return {
        'rgb': (r, g, b),
        'hsb': (round(h), round(s), round(b_val)),
        'lab': (round(l), round(a), round(b_lab)),
        'hsl': (round(h_hsl), round(s_hsl), round(l_hsl)),
        'cmyk': (round(c), round(m), round(y), round(k)),
        'rgb_display': (r, g, b),
        'hex': rgb_to_hex(r, g, b)
    }
```

**在 `color_card.py` 中：**
- 使用 `COLOR_MODE_CONFIG` 字典定义各模式的显示配置
- 使用 `ColorModeContainer` 类动态显示单个色彩模式
- 通过 `set_color_modes(modes)` 方法切换显示的模式

```python
# 色彩模式配置：模式名称 -> (显示名称, 标签列表, 单位列表, 格式化函数)
COLOR_MODE_CONFIG = {
    'HSB': (
        'HSB',
        ['H:', 'S:', 'B:'],
        ['°', '%', '%'],
        lambda values: [f"{values[0]}°", f"{values[1]}%", f"{values[2]}%"]
    ),
    # ... 其他模式
}
```

**在 `settings_interface.py` 中：**
- 使用两个 `ComboBox` 下拉框让用户选择模式
- 发射 `color_modes_changed` 信号通知主窗口更新
- 保存配置到 `settings.color_modes`

---

## 6. 图片处理规范

### 6.1 图片加载规范

- 保留原始高分辨率图片
- 使用 `QPixmap` 用于显示
- 使用 `QImage` 用于像素读取
- **使用多线程异步加载大图片，避免阻塞UI**

```python
# 使用PIL在子线程读取图片数据，主线程创建QImage
class ImageLoader(QThread):
    """图片加载工作线程（使用PIL在子线程读取图片数据）"""
    loaded = Signal(bytes, int, int, str)
    
    def run(self):
        """在子线程中使用PIL加载图片"""
        with Image.open(self._image_path) as pil_image:
            # 转换为RGB，保存为BMP格式字节数据
            ...
            self.loaded.emit(image_data, width, height, 'BMP')
```

### 6.2 坐标映射规范

- 显示坐标 → 原始图片坐标的映射
- 使用比例计算确保精度
- 边界检查防止越界

```python
# 将画布坐标转换为图片坐标
img_x = pos.x() - disp_x
img_y = pos.y() - disp_y

# 计算在原始图片中的坐标
scale_x = self._image.width() / disp_w
scale_y = self._image.height() / disp_h
orig_x = int(img_x * scale_x)
orig_y = int(img_y * scale_y)

# 边界检查
orig_x = max(0, min(orig_x, self._image.width() - 1))
orig_y = max(0, min(orig_y, self._image.height() - 1))
```

### 6.3 性能优化规范

#### 6.3.1 多线程加载
- 使用 `QThread` 在子线程读取图片文件
- 子线程使用 PIL 读取图片，转换为字节数据
- 主线程接收字节数据后创建 `QImage` 和 `QPixmap`
- 显示加载指示器（`IndeterminateProgressRing`）提示用户

#### 6.3.2 延迟执行耗时操作
- 图片显示后立即更新界面，让用户可以交互
- 使用 `QTimer.singleShot()` 延迟提取颜色/区域
- 直方图计算延迟执行，避免与颜色提取同时进行

```python
def _on_image_loaded(self, image_data, width, height, fmt):
    """图片加载完成的回调"""
    # 立即创建图片并显示
    self._image = QImage.fromData(image_data, fmt)
    self._original_pixmap = QPixmap.fromImage(self._image)
    self.update()
    
    # 延迟提取颜色，让UI先响应
    QTimer.singleShot(300, self.extract_all_colors)
```

#### 6.3.3 采样优化
- 直方图计算使用采样（每隔N个像素），减少计算量
- 默认采样步长为4，计算量减少到1/16
- 视觉效果几乎无差别

```python
def calculate_histogram(image, sample_step=4):
    """计算图片的明度直方图（使用采样优化）"""
    for y in range(0, height, sample_step):
        for x in range(0, width, sample_step):
            # 采样计算
            ...
```

#### 6.3.4 双面板同步优化
- 图片数据立即同步到两个面板
- 两个面板各自独立延迟执行耗时操作
- 用户可以立即切换面板，不会卡顿

#### 6.3.5 双面板图片清除同步规范

当任一面板执行图片清除操作时，应同步清除另一面板，保持数据一致性。

**实现原则：**
- 画布组件在 `clear_image()` 方法执行完成后发射 `image_cleared` 信号
- 主窗口提供 `sync_clear_to_luminance()` 和 `sync_clear_to_color()` 同步方法
- 同步清除时应重置窗口标题

**信号定义：**
```python
class ImageCanvas(QWidget):
    image_cleared = Signal()  # 图片已清空（用于同步到其他面板）
```

**同步实现示例：**
```python
# 在界面类中连接信号
def setup_connections(self):
    self.image_canvas.image_cleared.connect(self.on_image_cleared)

def on_image_cleared(self):
    """图片已清空回调（同步清除另一面板）"""
    window = self.window()
    if window and hasattr(window, 'sync_clear_to_luminance'):
        window.sync_clear_to_luminance()

# 在主窗口中实现同步方法
class MainWindow(FluentWindow):
    def sync_clear_to_luminance(self):
        """同步清除明度提取面板"""
        self.luminance_extract_interface.luminance_canvas.clear_image()
        self.luminance_extract_interface.histogram_widget.clear()
        self._reset_window_title()
```

---

## 7. 界面布局规范

### 7.1 布局原则

- 使用布局管理器（QVBoxLayout, QHBoxLayout）
- 避免使用固定尺寸，优先使用 size policy
- 合理使用 stretch 分配空间

### 7.2 分割器使用

- 使用 QSplitter 实现可调节区域
- 设置合理的初始分割比例
- 设置最小尺寸限制

```python
splitter = QSplitter(Qt.Orientation.Vertical)
splitter.addWidget(self.image_canvas)
splitter.addWidget(self.color_card_panel)
splitter.setSizes([500, 200])
```

### 7.3 控件尺寸规范

| 控件 | 推荐尺寸 | 说明 |
|:---:|:---:|:---:|
| 主窗口 | 1200×800 | 默认尺寸，可调整 |
| 主窗口最小 | 1000×700 | 保证内容完整显示 |
| 图片显示区域最小高度 | 300px | 确保图片有足够显示空间 |
| 色卡面板最小高度 | 200px | 自适应高度，容纳16进制显示区域 |
| 取色点半径 | 12px | 便于拖动操作 |
| 颜色块高度 | 80px | 清晰展示颜色 |

---

## 8. 交互设计规范

### 8.1 取色点交互

- 鼠标悬停：显示手型光标
- 鼠标按下：显示抓取光标，高亮显示
- 拖动时：实时更新颜色值
- 边界限制：限制在画布范围内

### 8.2 图片导入交互

- 无图片时：显示提示文字，点击打开文件对话框
- 有图片时：显示图片和取色点
- 支持菜单栏和快捷键导入

### 8.3 快捷键规范

| 快捷键 | 功能 |
|:---:|:---:|
| Ctrl + O | 打开图片 |
| Ctrl + Q | 退出程序 |

---

## 9. 代码修改规范

### 9.1 修改原则

- 小步修改，每次专注于一个功能点
- 保持向后兼容
- 修改前备份或使用版本控制
- 修改后测试验证

### 9.2 新增功能规范

1. **需求分析**：明确功能需求和实现方案
2. **设计**：设计接口和交互方式
3. **实现**：编写代码，遵循本规范
4. **测试**：验证功能正确性
5. **文档**：更新 README 和文档字符串

### 9.3 代码清理

- 删除未使用的导入
- 删除未使用的变量和函数
- 合并重复逻辑
- 保持代码简洁

---

## 10. 版本管理规范

### 10.1 版本号格式

- 格式：`主版本.次版本.修订版本`
- 示例：`1.0.0`
- 主版本：重大功能更新
- 次版本：新增功能
- 修订版本：bug 修复

### 10.2 版本管理器使用规范

使用 `version.py` 模块统一管理应用程序版本信息。

**版本管理器结构：**
```python
class VersionManager:
    """应用程序版本管理器"""
    
    def __init__(self):
        self.major = 1          # 主版本号
        self.minor = 0          # 次版本号
        self.patch = 0          # 修订版本号
        self.build = 0          # 构建号
        self.version = "1.0.0"  # 完整版本号
        
        self.app_info = {
            "name": "Color Card",
            "company": "浮晓 HXiao Studio",
            "copyright": "© 2025 浮晓 HXiao Studio",
            "developer": "青山公仔",
            "email": "hxiao_studio@163.com"
        }
```

**使用示例：**
```python
from version import version_manager

# 获取版本号
version = version_manager.get_version()  # 返回 "1.0.0"

# 获取应用信息
app_info = version_manager.get_app_info()
app_name = app_info['name']
company = app_info['company']

# 获取完整应用名称（含版本号）
full_name = version_manager.get_full_app_name()  # 返回 "Color Card v1.0.0"

# 设置窗口标题
self.setWindowTitle(f"取色卡 · Color Card · {version}")
```

**版本更新步骤：**
1. 修改 `version.py` 中的版本号（`major`, `minor`, `patch`）
2. 同步更新 `version_info.txt` 中的版本信息（用于 Windows EXE 打包）
3. 更新 `开发规范.md` 的版本历史记录

### 10.3 提交信息规范

#### 10.3.1 日常提交格式

- 提交信息应清晰、简洁，描述本次提交的主要内容
- 提交信息标题格式：`[类型] 详细描述`
- 类型包括：
  - `新功能`：新增功能或特性
  - `修复bug`：修复代码中的错误
  - `内容调整`：如替换链接、修改文本等
  - `文档更新`：修改或新增文档
  - `样式修改`：代码样式调整，不影响功能
  - `重构`：代码结构调整，不影响功能
  - `优化`：在不改变功能的前提下，提升代码或系统的性能、效率或用户体验的改进
  - `测试`：新增或修改测试代码
  - `构建变更`：修改依赖、构建脚本等
  - `配置变更`：修改配置文件

#### 10.3.2 Pull Request提交格式

Pull Request提交分为两种情况：日常修改/调整和版本更新。

##### 10.3.2.1 日常修改/调整（提交到Dev分支）

- 适用场景：日常调整、增加新功能、修复bug等
- 所有日常修改和调整都直接提交到Dev分支
- Pull Request标题格式：`[类型] 详细描述`
- Pull Request正文应包含：
  - 修改内容的详细描述
  - 修改的理由和目的
  - 测试情况
  - 相关Issue或参考链接（如果有）
- 无需包含开发者署名，Pull Request会自动记录创建者信息

##### 10.3.2.2 版本更新（合并到主分支）

- 适用场景：一次性合并很多内容到主分支，进行版本发布
- 由项目维护者执行，从Dev分支合并到主分支
- Pull Request标题格式：直接使用版本号，如 `1.5.0`
- Pull Request正文格式：`[类型] 详细描述`
- Pull Request正文应包含：
  - 版本更新的主要内容和变更
  - 新增功能列表
  - 修复的bug列表
- Pull Request需包含开发者署名

#### 10.3.3 提交信息示例

1. **日常提交示例**：
   - `[内容调整] 将关于页面的项目地址按钮从GitHub替换为Gitee`
   - `[修复bug] 修复登录功能的验证逻辑错误`
   - `[新功能] 新增用户管理功能`
   - `[文档更新] 更新README.md中的安装指南`

2. **Pull Request示例**：

   ##### 2.1 日常修改/调整（提交到Dev分支）
   - 标题：`[内容调整] 将关于页面的项目地址按钮从GitHub替换为Gitee`
   - 正文：

     ```
     修改内容：将关于页面的项目地址按钮从GitHub替换为Gitee
     修改理由：考虑到国内用户访问Gitee更稳定
     测试情况：已在本地测试，功能正常
     相关Issue：无
     ```

   ##### 2.2 版本更新（合并到主分支）
   - 标题：`1.5.0`
   - 正文：

     ```
     【修复bug】修复了取色点拖动时坐标计算错误的问题；
     【修复bug】修复了高DPI屏幕下图标显示模糊的bug；
     【新功能】新增颜色导出功能，支持JSON和CSS格式；
     【样式修改】优化了色卡面板的布局；
     【文档更新】更新了使用说明和开发规范。
     ```

---

## 11. 调试规范

### 11.1 日志输出

- 使用 print 或 logging 输出调试信息
- 关键操作添加日志
- 异常捕获并输出错误信息

### 11.2 常见问题排查

| 问题 | 排查方法 |
|:---:|:---:|
| 图片无法加载 | 检查文件路径和格式 |
| 取色点无法拖动 | 检查事件处理和坐标计算 |
| 颜色值不正确 | 检查坐标映射和颜色转换 |
| 界面显示异常 | 检查样式表和布局设置 |

---

## 11. 设置面板与关于对话框规范

### 11.1 设置面板 (SettingsInterface)

设置面板使用 `QWidget` 作为基类，与其他功能面板保持一致。

**规范要求：**
- 使用 `QWidget` 作为基类，直接使用 `QVBoxLayout(self)` 设置布局
- 使用 `SettingCardGroup` 组织相关设置项
- 使用 `PushSettingCard` 创建带按钮的设置项
- 按钮宽度应设置为固定值（推荐 130px），确保文字完整显示
- 设置面板放在导航栏底部 (`NavigationItemPosition.BOTTOM`)
- **注意**：不使用 `ScrollArea` 作为基类，以避免出现额外的滚动容器和圆角边框

```python
from PySide6.QtWidgets import QWidget, QVBoxLayout
from qfluentwidgets import SettingCardGroup, PushSettingCard, FluentIcon

class SettingsInterface(QWidget):
    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(36, 36, 36, 36)
        
        # 创建分组
        self.help_group = SettingCardGroup("帮助", self)
        
        # 创建带按钮的设置卡片
        self.update_card = PushSettingCard(
            "检查更新",           # 按钮文字
            FluentIcon.DOWNLOAD,  # 图标
            "版本更新",           # 标题
            "检查软件是否有新版本可用",  # 描述
            self.help_group       # 父组件
        )
        # 设置按钮固定宽度，确保文字完整显示
        self.update_card.button.setFixedWidth(130)
```

### 11.2 关于对话框 (AboutDialog)

关于对话框使用 `QDialog` 作为基类，使用 `QPlainTextEdit` 显示纯文本内容。

**规范要求：**
- 使用 `QPlainTextEdit` 显示纯文本内容
- 设置只读模式 (`setReadOnly(True)`)
- 屏蔽原生右键菜单 (重写 `contextMenuEvent` 方法)
- 不使用确认按钮，用户可通过点击窗口关闭按钮关闭对话框
- 内容包含：项目简介、开发团队、开源项目使用说明

```python
from PySide6.QtWidgets import QDialog, QVBoxLayout, QPlainTextEdit

class AboutDialog(QDialog):
    def setup_ui(self):
        layout = QVBoxLayout(self)

        # 纯文本编辑器显示内容
        self.text_edit = QPlainTextEdit(self)
        self.text_edit.setReadOnly(True)
        self.text_edit.setPlainText(self._get_about_text())
        layout.addWidget(self.text_edit, stretch=1)
        # 不添加确认按钮

    def contextMenuEvent(self, event):
        """屏蔽原生右键菜单"""
        event.ignore()
```

---

## 12. 状态保存规范

### 12.1 配置管理模块

使用 `config_manager.py` 统一管理应用程序状态的保存和加载。

**规范要求：**
- 配置文件使用 JSON 格式，存储在用户主目录下的 `.color_card/config.json`
- 使用 `ConfigManager` 类处理配置的加载和保存
- 使用单例模式获取全局配置管理器实例
- 配置变更时立即保存，确保状态不丢失

**配置结构：**
```json
{
    "version": "1.0",
    "settings": {
        "hex_visible": true
    },
    "window": {
        "width": 940,
        "height": 660
    }
}
```

**使用示例：**
```python
from config_manager import get_config_manager

# 获取配置管理器
config_manager = get_config_manager()

# 加载配置
config = config_manager.load()

# 获取配置项
hex_visible = config_manager.get('settings.hex_visible', True)

# 设置配置项
config_manager.set('settings.hex_visible', False)
config_manager.save()
```

### 12.2 状态保存实现规范

**在主窗口中：**
- 在 `__init__` 中加载配置并应用到界面
- 重写 `closeEvent` 方法保存配置

```python
class MainWindow(FluentWindow):
    def __init__(self):
        super().__init__()
        
        # 加载配置
        self._config_manager = get_config_manager()
        self._config = self._config_manager.load()
        
        # 应用窗口大小配置
        window_config = self._config.get('window', {})
        self.resize(window_config.get('width', 940), window_config.get('height', 660))
    
    def closeEvent(self, event):
        """窗口关闭事件，保存配置"""
        self._config_manager.set('window.width', self.width())
        self._config_manager.set('window.height', self.height())
        self._config_manager.save()
        event.accept()
```

**在设置界面中：**
- 初始化时从配置加载初始状态
- 状态改变时保存到配置

```python
class SettingsInterface(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._config_manager = get_config_manager()
        # 从配置加载初始状态
        self._hex_visible = self._config_manager.get('settings.hex_visible', True)
    
    def _on_hex_display_changed(self, checked):
        """状态改变时保存配置"""
        self._hex_visible = checked
        self._config_manager.set('settings.hex_visible', checked)
        self._config_manager.save()
        self.hex_display_changed.emit(checked)
```

### 12.3 新增配置项规范

添加新的配置项时，需要：
1. 在 `ConfigManager._load_default_config()` 中添加默认值
2. 在相关组件中实现配置的加载和应用
3. 在状态改变时调用 `config_manager.save()`
4. 更新本文档，说明新配置项的用途

---

## 13. 扩展开发建议

### 13.1 潜在功能扩展

- 导出颜色方案（JSON、CSS、ASE 等格式）
- 历史记录功能
- 配色规则检查（对比度、色相等）
- 更多颜色空间支持（CMYK、Pantone 等）
- 图片批量处理

### 13.2 代码扩展原则

- 保持组件化设计
- 新功能应放在独立模块
- 使用信号槽进行组件通信
- 保持向后兼容

---

## 14. 总结

本规范基于 Color Extractor 项目的现有代码结构制定，旨在确保代码的一致性、可维护性和可扩展性。所有开发者应遵循本规范进行开发。

规范将根据项目发展进行更新，以适应新的功能需求和技术变化。

---

## 版本历史

| 版本 | 日期 | 变更内容 |
|:---:|:---:|:---:|
| 3.9 | 2026-02-04 | 新增多色彩模式支持功能：支持 HSB、LAB、HSL、CMYK、RGB 五种色彩模式；用户可通过设置面板选择显示任意两种模式；添加色彩模式配置规范（5.4节）；更新 `color_utils.py`、`color_card.py`、`settings_interface.py` 实现动态色彩模式切换 |
| 3.8 | 2026-02-04 | 优化导航栏 Logo 显示规范（4.1.1节）：添加高 DPI 屏幕支持，使用 `devicePixelRatio()` 和 `setDevicePixelRatio()` 确保图标在高分辨率屏幕上清晰显示；增大图标请求尺寸从 32px 到 64px |
| 3.7 | 2026-02-04 | 新增直方图点击交互功能：点击直方图 Zone 区域在图片中高亮显示对应亮度范围；更新 Zone 分区摄影术语（黑色/阴影/暗部/中间调/亮部/高光/白色/极白） |
| 3.6 | 2026-02-04 | 新增 Windows 任务栏图标显示支持；添加 `icon_utils.py` 模块；添加任务栏图标显示规范（4.1.2节）；更新项目结构说明 |
| 3.5 | 2026-02-03 | 修复明度直方图计算问题；添加 sRGB Gamma 校正；优化直方图显示效果；更新明度计算规范（5.2节） |
| 3.4 | 2026-02-03 | 新增版本管理器模块 `version.py`；添加版本管理器使用规范（10.2节）；更新项目结构说明 |
| 3.3 | 2026-02-03 | 新增导航栏 Logo 显示功能；隐藏返回按钮；添加导航栏 Logo 与返回按钮规范（4.1.1节） |
| 3.2 | 2026-02-03 | 新增状态保存功能；添加配置管理模块 `config_manager.py`；添加状态保存规范（第12章） |
| 3.1 | 2026-02-03 | 新增16进制颜色值显示功能；添加设置面板开关控制；更新界面布局规范 |
| 3.0 | 2026-02-03 | 更新设置面板规范，将基类从 ScrollArea 改为 QWidget，与其他面板保持一致 |
| 2.9 | 2026-02-03 | 更新关于对话框规范，将 QTextBrowser 改为 QPlainTextEdit，添加右键菜单屏蔽要求 |
| 2.8 | 2026-02-03 | 完善样式设置规范，添加主题感知颜色使用规范（4.5.1-4.5.4），明确禁止使用硬编码颜色值 |
| 2.7 | 2026-02-03 | 添加设置面板与关于对话框规范 |
| 2.6 | 2026-02-03 | 添加双面板图片清除同步规范；完善信号命名规范中的同步信号示例 |
| 2.5 | 2026-02-03 | 添加明度提取功能规范；添加性能优化规范（多线程加载、延迟执行、采样优化、双面板同步） |
| 2.4 | 2026-02-03 | 更新提交信息规范，添加 Pull Request 提交格式和详细示例 |
| 2.3 | 2026-02-03 | 添加 zoom_viewer 组件规范，支持拖动时放大显示 |
| 2.2 | 2026-02-03 | 添加右键菜单规范（RoundMenu、Action 使用规范） |
| 2.1 | 2026-02-03 | 将 PyQt6 替换为 PySide6 |
| 2.0 | 2026-02-03 | 更新为基于 PySide6-Fluent-Widgets 的开发规范 |
| 1.0 | 2026-02-03 | 初始版本，基于项目现有代码结构制定 |
