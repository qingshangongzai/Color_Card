# PyQt6 应用程序状态栏图标显示参考文档

本文档介绍如何在 PyQt6 应用程序中正确显示 Windows 任务栏图标，确保打包后的 EXE 文件也能正常显示自定义图标。

## 目录

1. [核心原理](#核心原理)
2. [实现步骤](#实现步骤)
3. [完整代码示例](#完整代码示例)
4. [关键要点](#关键要点)
5. [常见问题](#常见问题)

---

## 核心原理

Windows 任务栏图标显示需要解决两个核心问题：

### 1. AppUserModelID 设置

Windows 使用 AppUserModelID 来识别和分组任务栏上的应用程序。如果不设置，Windows 会将 Python 解释器作为默认分组，导致图标显示异常。

```python
# 必须在创建任何窗口之前调用
ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID("YourCompany.YourApp.1.0")
```

### 2. 任务栏图标修复

即使设置了 AppUserModelID，有时任务栏仍可能显示默认的 Python 图标。需要通过 Windows API 强制刷新窗口图标。

---

## 实现步骤

### 步骤 1：导入必要的模块

```python
import sys
import os
import ctypes
from PyQt6.QtWidgets import QApplication, QMainWindow
from PyQt6.QtGui import QIcon
```

### 步骤 2：设置 AppUserModelID

```python
def set_app_user_model_id():
    """设置 AppUserModelID - 必须在创建 QApplication 之前调用"""
    if os.name != 'nt':  # 仅 Windows 需要
        return False
    
    try:
        # 格式：CompanyName.AppName.Version
        app_id = 'YourCompany.YourAppName.1.0.0'
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(app_id)
        print(f"[DEBUG] AppUserModelID 设置成功: {app_id}")
        return True
    except Exception as e:
        print(f"[DEBUG] 设置 AppUserModelID 失败: {e}")
        return False
```

### 步骤 3：修复任务栏图标函数

```python
# 全局变量：跟踪每个窗口的图标修复状态
_TASKBAR_ICON_FIXED_WINDOWS = {}

def fix_windows_taskbar_icon_for_window(window):
    """为特定窗口修复 Windows 任务栏图标
    
    Args:
        window: PyQt6 窗口对象 (QMainWindow 或 QDialog)
    
    Returns:
        bool: 修复成功返回 True，失败返回 False
    """
    if os.name != 'nt':
        return False
    
    # 使用窗口对象的 id 作为键，为每个窗口单独跟踪修复状态
    window_id = id(window)
    global _TASKBAR_ICON_FIXED_WINDOWS
    
    # 检查此窗口是否已经修复过
    if window_id in _TASKBAR_ICON_FIXED_WINDOWS and _TASKBAR_ICON_FIXED_WINDOWS[window_id]:
        return False
    
    try:
        # 确保窗口已经显示
        if not window.isVisible():
            window.show()
        window.raise_()
        window.activateWindow()
        
        # 使用 Qt 方法获取窗口句柄
        hwnd = int(window.winId())
        
        # 查找图标文件（支持 .ico 和 .png）
        icon_files = ["logo.ico", "logo.png"]
        icon_path = None
        for icon_file in icon_files:
            if os.path.exists(icon_file):
                icon_path = icon_file
                break
        
        if not icon_path:
            print("[DEBUG] 未找到图标文件用于任务栏修复")
            return False
        
        # 使用 ctypes 设置图标
        user32 = ctypes.windll.user32
        
        # 加载图标
        if icon_path.lower().endswith('.ico'):
            h_icon = user32.LoadImageW(
                None, icon_path,
                1,  # IMAGE_ICON
                0, 0,  # 使用实际大小
                0x00000010  # LR_LOADFROMFILE
            )
        else:
            # 对于 PNG 等格式，需要先加载为位图
            from PyQt6.QtGui import QPixmap
            pixmap = QPixmap(icon_path)
            if not pixmap.isNull():
                h_icon = pixmap.toImage().bits()
            else:
                print("[DEBUG] 无法加载 PNG 图标文件")
                return False
        
        if h_icon:
            # 设置图标（大图标和小图标）
            user32.SendMessageW(hwnd, 0x0080, 1, h_icon)  # WM_SETICON, ICON_BIG
            user32.SendMessageW(hwnd, 0x0080, 0, h_icon)  # WM_SETICON, ICON_SMALL
            
            # 强制刷新任务栏
            user32.UpdateWindow(hwnd)
            
            print(f"[DEBUG] 任务栏图标修复成功: {icon_path}")
            
            # 标记此窗口已修复
            _TASKBAR_ICON_FIXED_WINDOWS[window_id] = True
            return True
        
        print("[DEBUG] 图标句柄创建失败")
        return False
        
    except Exception as e:
        print(f"[DEBUG] 修复任务栏图标失败: {e}")
        return False
```

### 步骤 4：加载图标函数

```python
def load_icon_universal():
    """统一的图标加载函数，适用于所有环境
    
    Returns:
        QIcon: 应用程序图标对象
    """
    # 尝试多种图标格式和路径
    icon_files = ["logo.ico", "logo.png"]
    
    for icon_file in icon_files:
        if os.path.exists(icon_file):
            icon = QIcon(icon_file)
            if not icon.isNull():
                return icon
    
    # 如果找不到图标，创建后备图标
    return create_fallback_icon()

def create_fallback_icon():
    """创建后备图标（当找不到图标文件时使用）"""
    try:
        from PyQt6.QtGui import QPixmap, QColor, QPainter
        from PyQt6.QtCore import Qt
        
        # 创建一个简单的蓝色图标
        pixmap = QPixmap(32, 32)
        pixmap.fill(QColor("#66ccff"))
        
        painter = QPainter(pixmap)
        painter.setPen(QColor('white'))
        painter.drawText(pixmap.rect(), Qt.AlignmentFlag.AlignCenter, "APP")
        painter.end()
        
        return QIcon(pixmap)
    except Exception:
        return QIcon()
```

### 步骤 5：窗口混入类

```python
from PyQt6.QtCore import QTimer, pyqtSignal

class WindowIconMixin:
    """窗口图标修复混入类，提供统一的任务栏图标修复功能"""
    
    icon_fixed = pyqtSignal(bool)
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._icon_fixed = False
        self._fix_timer = None
    
    def setup_icon_fixing(self, delay_ms=100):
        """设置图标修复，在窗口显示后调用
        
        Args:
            delay_ms: 延迟时间（毫秒），默认 100ms
        """
        if self._icon_fixed:
            return
        
        if os.name == 'nt':
            self._fix_timer = QTimer()
            self._fix_timer.setSingleShot(True)
            self._fix_timer.timeout.connect(self._fix_icon_safe)
            self._fix_timer.start(delay_ms)
    
    def _fix_icon_safe(self):
        """安全修复任务栏图标"""
        try:
            if self._icon_fixed:
                return True
            
            success = fix_windows_taskbar_icon_for_window(self)
            self._icon_fixed = True
            self.icon_fixed.emit(success)
            return success
        except Exception as e:
            print(f"[ERROR] 任务栏图标修复失败: {e}")
            self.icon_fixed.emit(False)
            return False
    
    def fix_taskbar_icon(self):
        """修复任务栏图标 - 兼容旧接口"""
        return self._fix_icon_safe()
```

---

## 完整代码示例

### main.py

```python
# 标准库模块导入
import sys
import os
import ctypes

# ========== 第 1 步：在导入 PyQt6 之前设置 AppUserModelID ==========
# 这必须在创建 QApplication 之前调用！

def set_app_user_model_id():
    """设置 AppUserModelID"""
    if os.name != 'nt':
        return False
    
    try:
        # 格式：CompanyName.AppName.Version
        app_id = 'YourCompany.YourApp.1.0.0'
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(app_id)
        print(f"[DEBUG] AppUserModelID 设置成功: {app_id}")
        return True
    except Exception as e:
        print(f"[DEBUG] 设置 AppUserModelID 失败: {e}")
        return False

# 立即调用（在导入 PyQt6 之前）
set_app_user_model_id()

# ========== 第 2 步：导入 PyQt6 模块 ==========
from PyQt6.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QPushButton
from PyQt6.QtGui import QIcon
from PyQt6.QtCore import Qt, QTimer

# ========== 第 3 步：图标加载函数 ==========

def load_icon_universal():
    """加载应用程序图标"""
    icon_files = ["logo.ico", "logo.png"]
    
    for icon_file in icon_files:
        if os.path.exists(icon_file):
            icon = QIcon(icon_file)
            if not icon.isNull():
                return icon
    
    # 后备图标
    from PyQt6.QtGui import QPixmap, QColor, QPainter
    pixmap = QPixmap(32, 32)
    pixmap.fill(QColor("#66ccff"))
    return QIcon(pixmap)

# ========== 第 4 步：任务栏图标修复函数 ==========

_TASKBAR_ICON_FIXED_WINDOWS = {}

def fix_windows_taskbar_icon_for_window(window):
    """修复 Windows 任务栏图标"""
    if os.name != 'nt':
        return False
    
    window_id = id(window)
    global _TASKBAR_ICON_FIXED_WINDOWS
    
    if window_id in _TASKBAR_ICON_FIXED_WINDOWS and _TASKBAR_ICON_FIXED_WINDOWS[window_id]:
        return False
    
    try:
        if not window.isVisible():
            window.show()
        window.raise_()
        window.activateWindow()
        
        hwnd = int(window.winId())
        
        # 查找图标文件
        icon_path = None
        for icon_file in ["logo.ico", "logo.png"]:
            if os.path.exists(icon_file):
                icon_path = icon_file
                break
        
        if not icon_path:
            return False
        
        user32 = ctypes.windll.user32
        
        if icon_path.lower().endswith('.ico'):
            h_icon = user32.LoadImageW(
                None, icon_path, 1, 0, 0, 0x00000010
            )
        else:
            from PyQt6.QtGui import QPixmap
            pixmap = QPixmap(icon_path)
            h_icon = pixmap.toImage().bits() if not pixmap.isNull() else None
        
        if h_icon:
            user32.SendMessageW(hwnd, 0x0080, 1, h_icon)  # ICON_BIG
            user32.SendMessageW(hwnd, 0x0080, 0, h_icon)  # ICON_SMALL
            user32.UpdateWindow(hwnd)
            
            _TASKBAR_ICON_FIXED_WINDOWS[window_id] = True
            return True
        
        return False
        
    except Exception as e:
        print(f"[DEBUG] 修复任务栏图标失败: {e}")
        return False

# ========== 第 5 步：主窗口类 ==========

class MainWindow(QMainWindow):
    """应用程序主窗口"""
    
    def __init__(self):
        super().__init__()
        
        # 设置窗口基本属性
        self.setWindowTitle("My Application")
        self.setMinimumSize(800, 600)
        
        # 设置窗口图标
        self.app_icon = load_icon_universal()
        self.setWindowIcon(self.app_icon)
        
        # 创建中央部件
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # 创建布局
        layout = QVBoxLayout(central_widget)
        
        # 添加示例按钮
        button = QPushButton("Click Me")
        layout.addWidget(button)
        
        # 修复任务栏图标（在窗口显示后调用）
        QTimer.singleShot(100, self.fix_taskbar_icon)
    
    def fix_taskbar_icon(self):
        """修复任务栏图标"""
        fix_windows_taskbar_icon_for_window(self)

# ========== 第 6 步：应用程序入口 ==========

def main():
    # 创建 QApplication
    app = QApplication(sys.argv)
    
    # 设置应用程序图标（重要！）
    app_icon = load_icon_universal()
    app.setWindowIcon(app_icon)
    
    # 创建并显示主窗口
    window = MainWindow()
    window.show()
    
    # 运行应用程序
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
```

---

## 关键要点

### 1. 调用顺序至关重要

```
1. 设置 AppUserModelID（必须在导入 PyQt6 之前或创建 QApplication 之前）
2. 创建 QApplication
3. 设置应用程序图标（app.setWindowIcon）
4. 创建主窗口
5. 设置窗口图标（window.setWindowIcon）
6. 显示窗口
7. 修复任务栏图标（窗口显示后调用）
```

### 2. 图标文件位置

将图标文件放在以下位置之一：
- 应用程序根目录
- `assets/` 子目录
- `logo/` 子目录

支持的格式：
- `.ico`（推荐，Windows 原生支持）
- `.png`（需要额外处理）

### 3. PyInstaller 打包注意事项

使用 PyInstaller 打包时，需要在 spec 文件中包含图标文件：

```python
# your_app.spec
a = Analysis(
    ['main.py'],
    datas=[('logo.ico', '.'), ('logo.png', '.')],  # 包含图标文件
    ...
)
```

或者在命令行中：

```bash
pyinstaller --add-data "logo.ico;." --add-data "logo.png;." main.py
```

### 4. 多窗口应用程序

对于多窗口应用程序，每个窗口都需要单独修复任务栏图标：

```python
class DialogWindow(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowIcon(load_icon_universal())
        QTimer.singleShot(100, lambda: fix_windows_taskbar_icon_for_window(self))
```

---

## 常见问题

### Q1: 任务栏图标仍然显示 Python 图标

**解决方案：**
1. 确保 `set_app_user_model_id()` 在创建 `QApplication` 之前调用
2. 确保图标文件路径正确且文件存在
3. 尝试增加修复调用的延迟时间（例如 200ms 或 500ms）

### Q2: 打包后的 EXE 无法显示图标

**解决方案：**
1. 确保在 PyInstaller spec 文件中正确包含图标文件
2. 使用 `sys._MEIPASS` 处理打包后的路径：

```python
def get_base_path():
    if getattr(sys, 'frozen', False):
        if hasattr(sys, '_MEIPASS'):
            return sys._MEIPASS
        return os.path.dirname(sys.executable)
    return os.path.dirname(os.path.abspath(__file__))
```

### Q3: 图标显示模糊或尺寸不对

**解决方案：**
1. 使用 `.ico` 格式，包含多种尺寸（16x16, 32x32, 48x48, 256x256）
2. 使用在线工具生成多尺寸 ICO 文件

### Q4: 多窗口应用程序中某些窗口图标不显示

**解决方案：**
1. 确保每个窗口都调用了 `setWindowIcon()`
2. 确保每个窗口都调用了 `fix_windows_taskbar_icon_for_window()`
3. 检查 `_TASKBAR_ICON_FIXED_WINDOWS` 字典是否正确跟踪每个窗口

---

## 参考资源

- [Microsoft Docs: Application User Model IDs](https://docs.microsoft.com/en-us/windows/win32/shell/appids)
- [PyQt6 Documentation](https://www.riverbankcomputing.com/static/Docs/PyQt6/)
- [Windows API: SetCurrentProcessExplicitAppUserModelID](https://docs.microsoft.com/en-us/windows/win32/api/shobjidl_core/nf-shobjidl_core-setcurrentprocessexplicitappusermodelid)

---

*文档版本：1.0*  
*适用平台：Windows 10/11*  
*Python 版本：3.11+*  
*PyQt6 版本：6.4+*
