# Color Card 开发经验总结

## 1. 配色生成功能开发经验

### 1.1 算法设计原则

**配色生成算法参数设计：**

- 不同配色方案的采样点数量应根据色彩理论确定
- 同色系：4个（同一色相，不同饱和度）
- 邻近色：4个（基准色±30°范围内）
- 互补色：5个（基准色一侧3个，互补色一侧2个）
- 分离补色：3个（基准色+两个分离补色）
- 双补色：4个（两组互补色）

**饱和度参数设计：**

- 所有配色生成函数应接受 `base_saturation` 参数（默认100）
- 基于基准饱和度生成变化的饱和度序列，而非固定值
- 保持色彩和谐性的同时，支持随机饱和度变化

```python
def generate_monochromatic(hue: float, count: int = 4, base_saturation: float = 100):
    saturations = [
        base_saturation,
        max(20, base_saturation * 0.75),
        max(20, base_saturation * 0.5),
        max(20, base_saturation * 0.25)
    ]
```

**算法实现注意事项：**

- 函数签名要统一，避免参数错位（如 `angle` 和 `count` 的顺序）
- 使用明确的 `if-elif` 分支调用不同生成器，而非字典映射
- 色相计算注意取模运算 `(hue + 180) % 360`
- 饱和度计算确保最小值不低于20，保证颜色可见性

### 1.2 UI组件设计经验

**动态卡片数量管理：**

```python
def _update_card_count(self):
    scheme_counts = {
        'monochromatic': 4,
        'analogous': 4,
        'complementary': 5,
        'split_complementary': 3,
        'double_complementary': 4
    }
    count = scheme_counts.get(self._current_scheme, 5)
    self.color_panel.set_card_count(count)
```

**组件样式统一：**

- 复用现有组件的样式逻辑（如 `ColorModeContainer`）
- 提取公共样式函数（`get_text_color`, `get_placeholder_color` 等）
- 保持卡片布局一致，便于用户认知

### 1.3 配置管理最佳实践

**设置同步机制：**

- 使用信号槽机制进行跨界面通信
- 设置界面发送信号，主窗口中转，目标界面接收
- 避免直接引用，降低耦合度

```python
self.hex_display_changed.connect(
    self.color_scheme_interface.update_display_settings
)

def update_display_settings(self, hex_visible=None, color_modes=None):
    if hex_visible is not None:
        self.color_panel.set_hex_visible(hex_visible)
```

### 1.4 色轮交互设计

**明度调整与色轮联动：**

- 全局明度值直接对应HSB色彩空间的B值（Brightness）
- 滑块范围：10-100，直接对应B值百分比
- 明度降低时，采样点向中心移动；明度增加时，向外移动
- 色轮本身的颜色亮度也随之变化
- 所有采样点使用统一的全局明度值，忽略原始配色方案中的B值差异

```python
def _generate_wheel_cache(self):
    brightness_value = self._global_brightness / 100.0

def _draw_scheme_points(self, painter):
    global_brightness_value = self._global_brightness
    adjusted_b = global_brightness_value
```

### 1.5 qfluentwidgets 使用注意事项

**ComboBox 数据存储：**

- `addItem(text, data)` 不会存储数据（data为None）
- 需要使用 `setItemData(index, data)` 单独设置

```python
combo.addItem("同色系")
combo.setItemData(0, "monochromatic")
```

---

## 2. 布局设计最佳实践

### 2.1 网格布局自适应宽度经验

**问题描述：**
当使用 QGridLayout 显示多行色卡，且每行色卡数量不同时（如第一行6个，第三行4个），无法实现每行独立占满整行宽度。

**根本原因：**
- QGridLayout 的所有行共享相同的列宽
- 不同行的列数不同会导致拉伸效果不一致
- 设置 `setColumnStretch` 只在列数相同时有效

**解决方案：**
改用 **垂直布局 + 水平布局** 的组合方式：

```python
self.cards_layout = QVBoxLayout()
self.cards_layout.setSpacing(10)

columns = self._calculate_columns(len(colors))

current_row_layout = None
for i, color in enumerate(colors):
    if i % columns == 0:
        current_row_layout = QHBoxLayout()
        current_row_layout.setContentsMargins(0, 0, 0, 0)
        current_row_layout.setSpacing(10)
        self.cards_layout.addLayout(current_row_layout)
    
    card = ColorCard()
    current_row_layout.addWidget(card, stretch=1)
```

**清空布局的方法：**

```python
def _clear_color_cards(self):
    for card in self._color_cards:
        card.deleteLater()
    self._color_cards.clear()
    
    while self.cards_layout.count():
        item = self.cards_layout.takeAt(0)
        if item.layout():
            while item.layout().count():
                child = item.layout().takeAt(0)
                if child.widget():
                    child.widget().deleteLater()
```

**决策原则：**
- 每行列数相同 → 使用 QGridLayout
- 每行列数不同 → 使用垂直+水平组合布局

### 2.2 QSplitter 使用经验

- 使用 `setHandleWidth(0)` 隐藏分隔条，保持界面整洁
- 使用 `QSplitter` 分隔区域可避免窗口压缩时组件重叠
- **注意**：所有 QSplitter 都应该设置 `setHandleWidth(0)`

```python
splitter = QSplitter(Qt.Orientation.Vertical)
splitter.setHandleWidth(0)
splitter.addWidget(upper_widget)
splitter.addWidget(lower_widget)
```

### 2.3 工具栏/按钮容器间距规范

- 工具栏容器应该设置合理的边距，避免按钮紧贴边缘
- 推荐设置：`setContentsMargins(0, 8, 0, 8)` 给上下留出 8px 间距
- 容器高度应该与边距协调，如边距 8px 时，最大高度应 >= 50px

```python
toolbar = QWidget()
toolbar.setMaximumHeight(50)
toolbar.setStyleSheet("background: transparent;")
layout = QHBoxLayout(toolbar)
layout.setContentsMargins(0, 8, 0, 8)
layout.setSpacing(10)
```

### 2.4 布局拉伸与对齐的冲突

- `layout.setAlignment(Qt.AlignmentFlag.AlignCenter)` 会阻止子控件拉伸填满父布局
- 需要拉伸填满时，应移除对齐设置，使用 `stretch` 参数控制比例

```python
layout.addWidget(widget, stretch=1)
```

### 2.5 控件自适应大小的关键设置

- 父布局：`addWidget(widget, stretch=1)`
- 子控件：`setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)`
- 移除固定尺寸限制，改用 `setMinimumSize()` 设置最小尺寸

```python
widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
widget.setMinimumSize(200, 200)
layout.addWidget(widget, stretch=1)
```

### 2.6 多层嵌套布局的拉伸传递

- 每一层布局都需要设置 `stretch` 参数，才能让拉伸效果传递到最内层控件

```python
outer_layout.addWidget(inner_container, stretch=1)
inner_layout.addWidget(actual_widget, stretch=1)
```

### 2.7 避免重叠的布局策略

- 使用 `QSplitter` 分隔区域，而不是普通布局
- 设置合理的 `setMinimumHeight()`，避免控件被压缩到无法显示
- 对于复杂面板，考虑使用 `QScrollArea` 提供滚动支持

### 2.8 渐进式压缩设计原则

当窗口需要被压缩到很小时，应该设计多层次的压缩策略：

1. **第一阶段：正常压缩**
   - 保持所有内容可见，按比例缩小各区域
   - 设置合理的 `minimumHeight`，确保基本可读性

2. **第二阶段：紧凑模式**
   - 降低 `minimumHeight` 到更小值（如从160降到120）
   - 减小间距（`setSpacing` 从5降到3）
   - 减小边距（`setContentsMargins` 减小）
   - 缩小控件尺寸（按钮高度从28降到24）

3. **第三阶段：极限压缩**
   - 使用 `QScrollArea` 包裹内容
   - 或者隐藏非关键信息
   - 设置窗口绝对最小尺寸 `setMinimumSize()`

**实际案例 - 色卡面板压缩：**

```python
self.setMinimumHeight(120)
self.color_block.setMinimumHeight(30)
self.values_container.setMinimumHeight(45)
self.hex_container.setMinimumHeight(26)
layout.setSpacing(3)
```

**关键经验：**
- 不要只降低一个组件的最小高度，要**整体协调降低**
- 压缩时同步减小**间距、边距、控件尺寸**
- 测试时应该**逐步压缩窗口**，观察每个阶段的显示效果

---

## 3. 收藏功能开发经验

### 3.1 动态卡片数量管理

- 收藏项的色卡数量应根据实际保存的颜色数量动态创建
- 避免固定数量的卡片，提高空间利用率和视觉一致性

```python
def _load_favorite_data(self):
    colors = self._favorite_data.get('colors', [])
    self._clear_color_cards()
    self._create_color_cards(len(colors))
    for i, card in enumerate(self._color_cards):
        if i < len(colors):
            card.update_color(colors[i])
```

### 3.2 跨界面实时刷新机制

- 收藏添加后需要立即在其他界面可见
- 使用主窗口中转信号，避免界面间直接引用

```python
def refresh_favorites(self):
    if hasattr(self, 'favorites_interface'):
        self.favorites_interface.refresh_favorites()

self.main_window.refresh_favorites()
```

---

## 4. 导入导出功能开发经验

### 4.1 JSON数据格式设计

- 包含版本号便于后续数据迁移
- 包含导出时间戳便于追踪
- 数据与元数据分离

```python
def export_favorites(self, file_path: str) -> bool:
    favorites = self.get('favorites', [])
    export_data = {
        "version": "1.0",
        "export_time": datetime.now().isoformat(),
        "favorites": favorites
    }
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(export_data, f, ensure_ascii=False, indent=2)
```

### 4.2 导入模式选择

- 提供追加和替换两种模式
- 使用MessageBox进行用户确认
- 数据验证后再导入

```python
def import_favorites(self, file_path: str, mode: str = 'append') -> tuple:
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        if 'favorites' not in data:
            return False, 0, "无效的数据格式"
        
        imported = data['favorites']
        
        if mode == 'replace':
            self.set('favorites', imported)
        else:
            existing = self.get('favorites', [])
            existing.extend(imported)
            self.set('favorites', existing)
        
        self.save()
        return True, len(imported), ""
    except Exception as e:
        return False, 0, str(e)
```

---

## 5. MessageBox使用最佳实践

### 5.1 关键原则：不要手动断开信号连接

- qfluentwidgets的MessageBox内部使用信号槽机制管理按钮点击
- 手动调用`disconnect()`会破坏内部机制，导致按钮无响应

```python
msg_box = MessageBox("选择导入模式", "请选择导入方式", self)
msg_box.yesButton.setText("追加")
msg_box.cancelButton.setText("替换")
result = msg_box.exec()
if result == 1:
    mode = 'append'
else:
    mode = 'replace'
```

### 5.2 自定义按钮文本

- 使用`setText()`方法修改默认按钮文本
- 通过`exec()`返回值判断用户选择（1表示确认，0表示取消）

---

## 6. 配置数据迁移实践

### 6.1 向后兼容性处理

- 添加版本号便于识别旧数据格式
- 提供迁移方法自动升级旧数据

```python
def _migrate_favorites_data(self):
    favorites = self.get('favorites', [])
    migrated = []
    
    for fav in favorites:
        if 'id' not in fav:
            migrated.append({
                'id': datetime.now().isoformat(),
                'name': fav.get('name', '未命名'),
                'colors': fav.get('colors', []),
                'created_at': datetime.now().isoformat(),
                'source': fav.get('source', 'unknown')
            })
        else:
            migrated.append(fav)
    
    if migrated != favorites:
        self.set('favorites', migrated)
        self.save()
```

---

## 7. 内置色彩多段显示经验

### 7.1 问题背景

内置色彩面板中的配色颜色数量不一（4-24个），需要在有限空间内合理显示所有颜色。

### 7.2 显示模式分类

| 显示模式 | 适用场景 | 颜色分配 | 切换方式 |
|:---:|:---|:---|:---|
| `single` | 颜色数量少（≤4个） | 直接显示所有颜色 | 无切换按钮 |
| `sequential` | 标准顺序色（10-12个） | 两段均分显示 | 浅色组/深色组切换 |
| `triple` | 颜色较多（12-16个） | 三段均分显示 | 前半/中间/后半循环切换 |
| `quad` | 颜色很多（24个） | 四段均分显示（每段6个） | 第一段/第二段/第三段/第四段循环切换 |
| `diverging` | 发散色（ColorBrewer） | 以中间为界分左右 | 左半/右半切换 |
| `qualitative` | 定性色（ColorBrewer） | 两段均分显示 | 前半/后半切换 |

### 7.3 实现要点

**动态分配颜色数量：**

```python
half_count = total_colors // 2
if self._shade_mode == 'light':
    colors = [colors_dict.get(i, '') for i in range(half_count)]
else:
    colors = [colors_dict.get(i, '') for i in range(half_count, total_colors)]
```

**系列类型判断：**

```python
def _get_series_type(self) -> str:
    if self._series_key.startswith(('catppuccin', 'gruvbox')):
        return 'quad'
    if self._series_key.startswith(('rose_pine', 'solarized')):
        return 'triple'
    if self._series_key.startswith(('nord', 'dracula')):
        return 'single'
    return 'sequential'
```

### 7.4 关键经验

1. **根据颜色数量选择显示模式**
   - ≤4个颜色：使用 `single` 模式
   - 5-10个颜色：使用 `sequential` 模式
   - 11-16个颜色：使用 `triple` 模式
   - ≥20个颜色：使用 `quad` 模式

2. **保持切换按钮一致性**
   - 除 `single` 模式外，其他模式都显示切换按钮
   - 按钮使用循环切换逻辑

3. **动态计算优于固定值**
   - 使用 `total_colors // n` 计算每段数量，而非硬编码

---

## 8. 版权完善经验

### 8.1 主要经验

1. **提前规划**
   - 制定详细的版权完善计划
   - 分阶段执行，逐步完善
   - 建立执行记录，跟踪进度

2. **统一格式**
   - 建立统一的文本格式规范
   - 所有许可证文件格式保持一致
   - 便于维护和更新

3. **完整收集**
   - 不仅收集第三方库，还要收集工具链
   - 每个组件都要有完整的版权信息
   - 建立 THIRD_PARTY_LICENSES.md 汇总文档

4. **引用优化**
   - 对于使用相同许可证的组件，可以引用主许可证
   - 避免重复粘贴相同的许可证文本
   - LGPL 需要明确说明引用 GPL 的条款

5. **持续维护**
   - 新增依赖时同步更新许可证信息
   - 定期检查许可证信息的准确性
   - 保持与项目实际使用的依赖一致
