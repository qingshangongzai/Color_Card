# 配色数据重构计划

## 一、现状分析

### 1.1 JSON格式现状

当前项目包含13个配色JSON文件，格式存在以下不一致：

|文件 |元数据字段 |颜色存储方式 |特殊字段 |
|---|---|---|---|
|nice_palettes.json |`palettes` 数组 |直接颜色列表 |无 name/name_en |
|open_color.json |`source`, `url` |`colors` 对象 |标准格式 |
|tailwind_colors.json |`source`, `url` |`colors` 对象 |标准格式 |
|material_design.json |`source`, `url` |`colors` 对象 |标准格式 |
|colorbrewer.json |`source`, `url` |`colors` 对象 |有 `type` 字段 |
|catppuccin.json |`description`, `source` |`colors` 对象 |有 `count` 字段 |
|nord.json |`description`, `source` |`colors` 对象 |有 `count` 字段 |
|dracula.json |`description`, `source` |`colors` 对象 |有 `count` 字段 |
|其他主题文件 |类似上述 |`colors` 对象 |各有差异 |

### 1.2 代码冗余问题

`core/color_data.py` 文件约1550行，存在大量重复代码：

```text
重复模式：
- _load_xxx_data()     → 13个几乎相同的函数
- _get_xxx_data()      → 13个几乎相同的函数  
- get_xxx_series_names() → 13个几乎相同的函数
- get_xxx_color_series() → 13个几乎相同的函数
- get_xxx_light_shades() → 多个类似函数
- get_xxx_dark_shades()  → 多个类似函数
```

### 1.3 UI层扩展困难

`ui/preset_color_widgets.py` 中：

- `set_data_source()` 方法有13个 if-elif 分支
- 每个配色源需要独立的 `_load_xxx_series()` 方法
- 新增配色源需要修改至少4处代码

### 1.4 分组硬编码问题

当前配色分组逻辑完全硬编码在 Python 代码中（`ui/interfaces.py`）：

```python
# Open Color 分组定义
OPEN_COLOR_GROUPS = [
    (["gray", "red", "pink", "grape"], "灰/红/粉/紫组"),
    (["violet", "indigo", "blue", "cyan"], "紫/蓝/青组"),
    (["teal", "green", "lime", "yellow", "orange"], "绿/黄/橙组"),
]

# Material Design 分组定义
MATERIAL_GROUPS = [
    (["red", "pink", "purple", "deep_purple"], "红/粉/紫组"),
    (["indigo", "blue", "light_blue", "cyan"], "蓝/青组"),
    # ... 每个配色源都需要单独定义
]
```

**问题**：

- 新增配色源必须修改代码添加分组
- 社区贡献者无法自定义分组方式
- 分组逻辑与数据分离，维护困难

### 1.5 配色管理导出格式

当前配色管理面板导出的JSON格式与内置配色JSON格式不一致，无法直接作为配色源使用。


---

## 二、重构目标


1. **统一JSON格式**：建立标准化的配色JSON格式规范
2. **JSON内部分组**：将分组定义从代码迁移到JSON文件中
3. **简化加载函数**：使用配置驱动 + 自动发现机制
4. **UI扩展接口**：新增配色只需添加JSON文件，零代码修改
5. **大数据量加载优化**：配色组超过50组时自动使用多线程分批加载
6. **社区贡献支持**：配色管理导出格式与标准格式统一


---

## 三、统一JSON格式规范

### 3.1 核心设计原则

- **统一格式**：配色管理页面和内置色彩页面使用同一种JSON格式
- **JSON内部分组**：不在Python代码里硬编码分组，而是在JSON中定义`groups`字段
- **向后兼容**：`groups`字段为可选，没有时采用默认显示方式

### 3.2 标准格式（系列型）

适用于有多个颜色系列的配色方案：

```json
{
  "version": "1.0",
  "id": "material_design",
  "name": "Material Design",
  "name_zh": "Material Design 配色",
  "description": "Google Material Design 官方配色系统",
  "author": "Google",
  "category": "design_system",
  "type": "series",
  "series": {
    "red": {
      "name": "红色",
      "name_en": "Red",
      "colors": ["#ffebee", "#ffcdd2", "#ef9a9a", "#e57373", "#ef5350", 
                 "#f44336", "#e53935", "#d32f2f", "#c62828", "#b71c1c"]
    },
    "pink": {
      "name": "粉色",
      "name_en": "Pink",
      "colors": ["#fce4ec", "#f8bbd9", "#f48fb1", "#f06292", "#ec407a",
                 "#e91e63", "#d81b60", "#c2185b", "#ad1457", "#880e4f"]
    }
  },
  "groups": [
    {
      "name": "红/粉/紫组",
      "keys": ["red", "pink", "purple", "deep_purple"]
    },
    {
      "name": "蓝/青组",
      "keys": ["indigo", "blue", "light_blue", "cyan"]
    },
    {
      "name": "绿色系",
      "keys": ["teal", "green", "light_green", "lime"]
    },
    {
      "name": "黄/橙组",
      "keys": ["yellow", "amber", "orange", "deep_orange"]
    },
    {
      "name": "棕/灰组",
      "keys": ["brown", "grey", "blue_grey"]
    }
  ]
}
```

### 3.3 配色组格式（Palette型）

适用于无系列的配色集合：

```json
{
  "version": "1.0",
  "id": "nice_palettes",
  "name": "Nice Color Palettes",
  "name_zh": "精选配色组",
  "description": "500组精选配色方案",
  "author": "mrmrs",
  "category": "palette",
  "type": "palettes",
  "palettes": [
    {
      "name": "配色 #1",
      "colors": ["#69d2e7", "#a7dbd8", "#e0e4cc", "#f38630", "#fa6900"]
    }
  ],
  "groups": [
    {"name": "第 1-50 组", "range": [0, 50]},
    {"name": "第 51-100 组", "range": [50, 100]},
    {"name": "第 101-150 组", "range": [100, 150]},
    {"name": "第 151-200 组", "range": [150, 200]},
    {"name": "第 201-250 组", "range": [200, 250]},
    {"name": "第 251-300 组", "range": [250, 300]},
    {"name": "第 301-350 组", "range": [300, 350]},
    {"name": "第 351-400 组", "range": [350, 400]},
    {"name": "第 401-450 组", "range": [400, 450]},
    {"name": "第 451-500 组", "range": [450, 500]}
  ]
}
```

### 3.4 无分组格式（主题型）

适用于系列数量少的主题配色，不需要分组：

```json
{
  "version": "1.0",
  "id": "nord",
  "name": "Nord",
  "name_zh": "Nord 主题",
  "description": "北极蓝调主题配色",
  "author": "Arctic Ice Studio",
  "category": "theme",
  "type": "series",
  "series": {
    "nord0": {"name": "极夜黑", "colors": ["#2E3440", "#3B4252", "#434C5E", "#4C566A"]},
    "nord1": {"name": "雪地白", "colors": ["#D8DEE9", "#E5E9F0", "#ECEFF4"]},
    "nord2": {"name": "冰川蓝", "colors": ["#8FBCBB", "#88C0D0", "#81A1C1", "#5E81AC"]}
  }
}
```

### 3.5 用户导出格式（社区贡献）

```json
{
  "version": "1.0",
  "id": "user_palettes_20240101",
  "name": "My Color Palettes",
  "name_zh": "我的配色收藏",
  "description": "个人收藏的配色方案",
  "author": "用户名",
  "created_at": "2024-01-01T12:00:00",
  "category": "user_palette",
  "type": "palettes",
  "palettes": [
    {
      "name": "日落渐变",
      "colors": ["#FF6B6B", "#FFA07A", "#FFD93D", "#6BCB77", "#4D96FF"]
    }
  ]
}
```

### 3.6 字段说明

|字段 |类型 |必填 |说明 |
|---|---|---|---|
|`version` |string |是 |格式版本号 |
|`id` |string |是 |唯一标识符 |
|`name` |string |是 |配色方案名称（英文） |
|`name_zh` |string |否 |配色方案中文名称 |
|`description` |string |否 |描述信息 |
|`author` |string |是 |作者名称 |
|`created_at` |string |否 |创建时间（用户导出专用） |
|`category` |string |否 |分类：`design_system`/`theme`/`palette`/`user_palette` |
|`type` |string |是 |数据类型：`series` 或 `palettes` |
|`series` |object |条件 |颜色系列集合（`type=series`时必填） |
|`palettes` |array |条件 |配色组列表（`type=palettes`时必填） |
|`groups` |array |否 |分组定义（可选） |
|`groups[].name` |string |是 |分组显示名称 |
|`groups[].keys` |array |条件 |系列键名列表（`type=series`时使用） |
|`groups[].range` |array |条件 |索引范围`[start, end]`（`type=palettes`时使用） |
|`groups[].batch_load` |boolean |否 |是否启用分批加载（默认false） |
|`groups[].batch_size` |number |否 |每批加载数量（默认10） |
|`series.{key}.name` |string |是 |系列中文名称 |
|`series.{key}.name_en` |string |否 |系列英文名称 |
|`series.{key}.colors` |array |是 |颜色值数组（HEX格式） |

### 3.7 分组策略说明

|数据类型 |分组方式 |示例 |
|---|---|---|
|`series` |使用`keys`指定系列键名 |Material Design、Open Color |
|`palettes` |使用`range`指定索引范围 |Nice Palettes |
|无`groups` |直接显示所有数据 |Nord、Dracula（系列少） |

### 3.8 分批加载配置

对于数据量大的分组，可以在JSON中配置分批加载参数：

```json
{
  "groups": [
    {
      "name": "红/粉/紫组",
      "keys": ["red", "pink", "purple", "deep_purple"],
      "batch_load": true,
      "batch_size": 2
    }
  ]
}
```

**分批加载配置建议**：

|数据类型 |分组内数量 |建议配置 |
|---|---|---|
|series |≤ 5 |不分批 |
|series |6-15 |`batch_load: true, batch_size: 3` |
|series |> 15 |`batch_load: true, batch_size: 5` |
|palettes |≤ 20 |不分批 |
|palettes |21-50 |`batch_load: true, batch_size: 10` |
|palettes |> 50 |`batch_load: true, batch_size: 20` |


---

## 四、分阶段重构计划

### 版本规划说明

|版本 |阶段 |内容 |依赖 |
|---|---|---|---|
|**当前版本** |阶段 1.x |配色管理导入导出格式改造 |无 | ✅ 已完成
|**当前版本** |阶段 2.x |内置配色JSON格式统一 |阶段 1.x 完成 | ✅ 已完成
|**当前版本** |阶段 3.x |加载函数重构 |阶段 2.x 完成 | ✅ 已完成
|**当前版本** |阶段 4.x |UI层简化 |阶段 3.x 完成 | ⏳ 部分完成（待添加分批加载）
|**后续版本** |阶段 5.x |色彩管理面板分组功能 |阶段 4.x 完成 |


---

### 阶段 1.x：配色管理导入导出格式改造（当前版本）

**目标**：统一用户数据格式，为后续重构打基础

#### 阶段 1.1：修改导出格式 ✅ 已完成

**目标**：导出功能输出新格式

**步骤**：


1. ✅ 修改 `core/config.py` 中的 `export_favorites()` 方法
2. ~~添加导出元数据输入对话框（名称、描述、作者）~~ 已移除，元数据字段默认为空
3. ✅ 测试导出功能

**验证点**：

- ✅ 导出的JSON文件符合新格式规范
- ✅ 包含 `version`, `id`, `name`, `author`, `palettes` 等字段

**风险**：无（导出功能独立，不影响现有功能）

**实际实现说明**：

- 元数据字段（`name`, `name_zh`, `description`, `author`）默认为空字符串
- `id` 自动生成，格式为 `user_palettes_YYYYMMDD_HHMMSS`
- 颜色数据转换为纯 HEX 格式数组


---

#### 阶段 1.2：修改导入格式 ✅ 已完成

**目标**：导入功能支持新格式，移除旧格式兼容

**步骤**：


1. ✅ 修改 `core/config.py` 中的 `import_favorites()` 方法
2. ✅ 仅支持新格式，旧格式返回错误提示
3. ✅ 测试导入功能

**验证点**：

- ✅ 新格式JSON文件可正常导入
- ✅ 旧格式JSON文件返回明确的错误提示

**风险**：用户旧数据无法导入

**用户迁移方案**：


1. 发布版本前通知用户导出数据
2. 用户使用新版本导出功能重新导出
3. 新版本导入只支持新格式

**实际实现说明**：

- 导入时检测 `palettes` 字段（新格式）
- 旧格式（使用 `favorites` 字段）返回错误提示
- 导入时自动将 HEX 颜色转换为完整的颜色信息字典


---

#### 阶段 1.3：优化导出配色默认名称 ✅ 已完成

**目标**：导出的配色文件JSON的默认名称改为时间戳格式

**实现说明**：

- 修改 `ui/interfaces.py` 中的 `_on_export_clicked()` 方法
- 默认文件名从 `color_card_favorites.json` 改为 `color_card_YYYYMMDD_HHMMSS.json`
- 使用 `datetime.now().strftime('%Y%m%d_%H%M%S')` 生成时间戳


---

#### 阶段 1.4：发布版本✅ 已完成

**目标**：发布包含新导入导出格式的版本

**步骤**：


1. 更新版本号
2. 更新更新日志，说明导入导出格式变更
3. 发布版本

**用户通知内容**：

```text
【重要】配色管理导入导出格式变更

本次更新统一了配色数据的JSON格式，便于后续功能扩展和社区贡献。

请用户在更新后重新导出配色数据，旧格式文件将无法导入。
```


---

### 阶段 2.x：内置配色JSON格式统一

**目标**：将所有内置配色JSON文件转换为统一格式，包含`type`和`groups`字段

**核心策略**：先复制副本目录，在副本中完成格式转换和验证，确认无误后再替换原目录。这样不会影响应用正常加载。

#### 阶段 2.1：创建副本目录

**目标**：复制 `color_data` 目录为 `color_data_new`，作为转换工作目录

**步骤**：

1. 复制 `color_data/` 目录为 `color_data_new/`
2. 确认副本目录包含全部13个JSON文件
3. 原目录保持不变，应用继续使用原数据

**验证点**：

- 副本目录创建成功
- 文件数量与原目录一致

**风险控制**：

- 原目录完全不动，应用正常加载
- 所有转换工作在副本目录进行


---

#### 阶段 2.2：创建转换脚本 ✅ 已完成（已统一为palettes格式）

**目标**：编写自动化转换工具，统一为 `palettes` 格式

**步骤**：

1. ✅ 创建 `scripts/migrate_color_data.py` 转换脚本（已删除，任务完成后清理）
2. ✅ 脚本默认读取 `color_data/` 目录，写入 `color_data_new/` 目录
3. ✅ 实现格式检测和转换逻辑
4. ✅ 添加作者信息映射表
5. ✅ 从`ui/interfaces.py`提取分组定义，生成`groups`字段
6. ✅ **统一格式**：将 `series` 转换为 `palettes`，`keys` 转换为 `indices`

**转换规则**：

|原格式 |新格式 |
|---|---|
|`type: "series"` |移除（统一为palettes） |
|`series: {...}` |`palettes: [...]` |
|`colors: {"0": "#xxx", "1": "#xxx"}` |`colors: ["#xxx", "#xxx"]` |
|`groups[].keys` |`groups[].indices` |

**验证点**：

- ✅ 脚本可正确识别不同格式
- ✅ 转换后数据完整无误
- ✅ `groups`字段正确生成（使用indices）
- ✅ 仅操作副本目录，不影响原目录


---

#### 阶段 2.3：运行转换脚本 ✅ 已完成

**目标**：在副本目录中完成所有文件的格式转换

**步骤**：

1. ✅ 运行转换脚本，处理 `color_data/` 中的所有JSON文件
2. ✅ 检查转换日志，确认无错误
3. ✅ 逐个检查转换后的JSON文件格式

**验证点**：

- ✅ 所有13个文件转换成功
- ✅ JSON格式正确（可用JSON验证工具检查）
- ✅ 统一为 `palettes` 格式
- ✅ `groups`字段使用 `indices`

**实际结果**：

```
转换完成: 13 成功, 0 失败
验证完成: 13 成功, 0 失败
```

**风险控制**：

- 仅修改副本目录文件
- 原目录文件保持不变


---

#### 阶段 2.4：验证转换结果 ✅ 已完成

**目标**：全面验证转换后的数据正确性

**步骤**：

1. ✅ 使用JSON验证工具检查所有文件格式
2. ✅ 对比转换前后的颜色数据，确保无丢失
3. ✅ 检查元数据字段完整性
4. ✅ 检查分组定义正确性

**验证清单**：

- [x] 所有文件JSON格式有效
- [x] 颜色数据数量与原文件一致
- [x] 颜色值无变化（HEX格式正确）
- [x] 元数据字段（`id`, `name`, `author`等）正确
- [x] 统一为 `palettes` 格式
- [x] `groups`字段使用 `indices`

**风险控制**：

- 发现问题可重新运行脚本
- 原目录始终可用


---

#### 阶段 2.5：替换原目录 ✅ 已完成

**目标**：验证通过后，用新格式文件替换原文件

**状态**：已完成目录替换，新格式JSON文件已部署到 `color_data/` 目录。

**步骤**：

1. ✅ 备份原 `color_data/` 目录为 `color_data - 副本/`
2. ✅ 将新格式文件替换到 `color_data/`
3. ⏳ 验证应用加载正常（需完成阶段3加载函数重构）

**验证点**：

- ⏳ 应用可正常加载所有配色
- ⏳ 分组下拉框显示正确
- ⏳ 所有配色数据正确显示

**风险控制**：

- 保留备份目录 `color_data - 副本/`，出问题可快速回滚
- 仅在验证通过后才删除备份


---

#### 阶段 2.x 流程图

```
┌─────────────────┐
│  color_data/    │ ← 新格式JSON（已替换）
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 阶段3：重构加载  │ ← 适配新格式
└─────────────────┘
```

**当前状态**：

- ✅ JSON格式统一完成
- ✅ 目录替换完成
- ⏳ 加载函数待重构
- 出问题可轻松回滚
- 转换脚本可以独立开发和测试


---

### 阶段 3.x：加载函数重构 ✅ 已完成

**目标**：重写 `core/color_data.py`，直接支持新JSON格式，无需兼容层

**前置条件**：✅ 阶段2已完成，`color_data/` 目录已替换为新格式

#### 阶段 3.1：创建ColorSource类 ✅ 已完成

**目标**：创建配色源类，直接读取新格式JSON

**步骤**：

1. ✅ 在 `core/color_data.py` 中创建 `ColorSource` 类
2. ✅ 直接读取 `palettes` 和 `groups.indices` 字段
3. ✅ 无需兼容旧格式

**实际实现**：

- 创建了 `ColorSource` 类，包含 `id`, `name`, `description`, `author`, `category` 等属性
- 实现了 `has_groups`, `total_palettes`, `total_groups` 属性
- 实现了 `get_groups()`, `get_palettes_for_group()`, `get_all_palettes()`, `get_group_info()` 方法

**验证点**：

- ✅ `ColorSource` 类可正确读取新格式JSON
- ✅ 分组数据读取正确（使用 indices）
- ✅ 无分组时返回所有配色


---

#### 阶段 3.2：创建注册表类 ✅ 已完成

**目标**：实现配色源注册表，管理所有配色源

**步骤**：

1. ✅ 创建 `ColorSourceRegistry` 类
2. ✅ 实现自动发现 `color_data/` 目录下的JSON文件
3. ✅ 实现注册、查询等基础方法

**实际实现**：

- 使用单例模式管理配色源
- 自动发现并加载所有 JSON 文件
- 提供 `get()`, `get_all_ids()`, `get_all_sources()` 方法

**验证点**：

- ✅ 可正确发现所有配色源（13个JSON文件）
- ✅ 注册信息正确（包含分组信息）


---

#### 阶段 3.3：重写加载函数 ✅ 已完成

**目标**：重写现有加载函数，直接使用新接口

**步骤**：

1. ✅ 创建 `get_color_source_registry()` 函数
2. ✅ 创建 `get_color_source()` 函数
3. ✅ 创建 `get_all_color_sources()` 函数
4. ✅ 保留 `get_all_palettes()` 和 `get_random_palettes()` 用于随机配色
5. ✅ 删除旧的加载逻辑（约1300行冗余代码）

**验证点**：

- ✅ 接口可正确返回数据
- ✅ 应用可正常启动
- ✅ 随机配色功能正常

**实际收益**：

| 指标 | 重构前 | 重构后 |
|---|---|---|
| color_data.py 行数 | ~1550行 | ~230行 |
| 新增配色源修改点 | 4处以上 | 0处（仅添加JSON） |


---

### 阶段 4.x：UI层简化 ⏳ 部分完成

**目标**：简化 `ui/preset_color_widgets.py`，移除硬编码分组

#### 阶段 4.1：创建配色源选择器 ✅ 已完成

**目标**：实现动态配色源选择组件

**步骤**：

1. ✅ 修改 `PresetColorInterface` 类，从注册表动态生成选项列表
2. ✅ 移除硬编码的配色源下拉列表项
3. ✅ 测试选择器功能

**实际实现**：

- 在 `PresetColorInterface.__init__()` 中缓存配色源到 `_color_sources` 字典
- `setup_ui()` 中从 `get_all_color_sources()` 动态生成下拉列表

**验证点**：

- ✅ 选项列表正确（随机配色 + 13个配色源）
- ✅ 选择切换正常


---

#### 阶段 4.2：实现动态分组选择器（含分批加载） ⏳ 部分完成

**目标**：从JSON读取分组，替代硬编码分组，支持分组内分批加载

**已完成步骤**：

1. ✅ 移除 `ui/interfaces.py` 中的硬编码分组定义（`OPEN_COLOR_GROUPS`、`MATERIAL_GROUPS`等）
2. ✅ 修改分组下拉框初始化逻辑，从 `ColorSource.get_groups()` 读取
3. ✅ 实现分组切换时的动态加载

**待完成步骤**：

4. ⏳ 实现分组级别的分批加载机制（大数据量配色源需要）

**分批加载线程设计（已简化）**：

```python
class GroupLoaderThread(QThread):
    """分组数据异步加载线程"""
    
    data_ready = Signal(int, list)      # 信号：批次索引, 数据列表
    batch_finished = Signal()           # 单批完成
    loading_finished = Signal()         # 全部完成
    
    def __init__(self, source: ColorSource, group_index: int, batch_size: int = 10, parent=None):
        super().__init__(parent)
        self._source = source
        self._group_index = group_index
        self._batch_size = batch_size
        self._is_cancelled = False
        
        group_info = source.get_group_info(group_index)
        self._total_items = group_info.get("total_items", 0)
    
    def cancel(self):
        """请求取消加载"""
        self._is_cancelled = True
    
    def run(self):
        """分批加载数据"""
        import math
        total_batches = math.ceil(self._total_items / self._batch_size)
        
        for batch_idx in range(total_batches):
            if self._is_cancelled:
                return
            
            start = batch_idx * self._batch_size
            data = self._source.get_palettes_for_group_batch(
                self._group_index, start, self._batch_size
            )
            
            # 发射信号通知主线程
            self.data_ready.emit(batch_idx, data)
            self.batch_finished.emit()
            
            # 小延迟避免阻塞UI
            self.msleep(10)
        
        self.loading_finished.emit()
```

**新实现逻辑（已简化）**：

```python
def _on_source_changed(self, index):
    """配色源切换"""
    source_id = self.source_combo.currentData()
    source = ColorSourceRegistry.get(source_id)
    self._current_source = source
    
    # 清空并重建分组下拉框
    self.group_combo.clear()
    
    if source.has_groups:
        self.group_combo.show()
        for group in source.get_groups():
            self.group_combo.addItem(group["name"])
        self._on_group_changed(0)
    else:
        self.group_combo.hide()
        self._load_all_data()

def _on_group_changed(self, index):
    """分组切换"""
    # 取消当前加载
    if self._loader:
        self._loader.cancel()
        self._loader = None
    
    # 清空现有内容
    self._clear_content()
    
    source = self._current_source
    group_info = source.get_group_info(index)
    
    # 检查是否需要分批加载（根据数量判断）
    if group_info.get("total_items", 0) > 20:
        self._start_batch_loading(index)
    else:
        # 直接加载全部
        palettes = source.get_palettes_for_group(index)
        self._load_palettes_list(palettes)

def _start_batch_loading(self, group_index: int):
    """启动分批加载"""
    self._loader = GroupLoaderThread(
        self._current_source, group_index, parent=self
    )
    self._loader.data_ready.connect(self._on_batch_data_ready)
    self._loader.loading_finished.connect(self._on_loading_finished)
    self._loader.start()

def _on_batch_data_ready(self, batch_idx: int, data: list):
    """处理分批加载的数据"""
    for item in data:
        card = self._create_palette_card(item)
        self.content_layout.addWidget(card)
    
    # 强制刷新UI
    QApplication.processEvents()

def _on_loading_finished(self):
    """加载完成"""
    self._loader = None
```

**验证点**：

- 分组从JSON正确读取
- 分组切换正常
- 分批加载流畅，无卡顿
- 快速切换分组时，旧加载任务正确取消
- 所有配色源显示正确


---

#### 阶段 4.3：简化数据源设置方法 ✅ 已完成

**目标**：统一 `set_data_source()` 方法，移除冗余方法

**步骤**：

1. ✅ 重构 `set_data_source()` 方法
2. ✅ 移除所有 `_load_xxx_series()` 方法（被统一接口替代）
3. ✅ 测试所有配色源切换

**实际实现**：

- `PresetColorList.set_data_source()` 简化为统一接口
- 移除了13个 `_load_xxx_series()` 方法
- `ui/preset_color_widgets.py` 从约1347行减少到约523行
- `ui/interfaces.py` 中 `PresetColorInterface` 从约540行减少到约110行

**验证点**：

- ✅ 所有配色源可正常切换
- ✅ 加载显示正确
- ✅ 代码行数显著减少


---

### 阶段 5.x：色彩管理面板分组功能 ⏳ 待开始

**目标**：为色彩管理面板添加分组功能，与统一格式配合

**前置条件**：阶段4.x完成（UI层统一接口已实现）

#### 阶段 5.1：添加分组下拉框

**目标**：色彩管理面板始终显示分组下拉框

**步骤**：

1. 在色彩管理面板UI中添加分组下拉框
2. 实现分组动态生成逻辑
3. 实现分组切换时的数据加载

**分组规则**：

|配色组数量 |下拉框显示 |分组内容 |
|---|---|---|
|< 20 |始终显示 |单项："全部 (xx组)" |
|20-50 |始终显示 |多项：按20组分组 |
|> 50 |始终显示 |多项：按20组分组 + 分批加载 |

**分组生成逻辑（已简化，使用indices）**：

```python
GROUPING_THRESHOLDS = {
    "min_for_groups": 20,      # 分组阈值
    "group_size": 20,          # 每组大小
    "batch_threshold": 50,     # 分批加载阈值
    "batch_size": 10           # 分批大小
}

def _generate_groups(total: int) -> list:
    """生成分组配置（始终返回至少一个分组）"""
    group_size = GROUPING_THRESHOLDS["group_size"]
    min_for_groups = GROUPING_THRESHOLDS["min_for_groups"]
    
    if total < min_for_groups:
        # 不足分组标准，返回单个"全部"分组
        return [{
            "name": f"全部 ({total}组)",
            "indices": list(range(total))
        }]
    
    # 达到分组标准，按大小分组
    groups = []
    num_groups = (total + group_size - 1) // group_size
    
    for i in range(num_groups):
        start = i * group_size
        end = min((i + 1) * group_size, total)
        
        groups.append({
            "name": f"第 {start+1}-{end} 组",
            "indices": list(range(start, end))
        })
    
    return groups
```

**验证点**：

- 分组下拉框始终显示
- 配色数量变化时分组正确更新
- 分组切换正常


---

#### 阶段 5.2：导出自动分组

**目标**：导出JSON时自动生成分组配置

**步骤**：

1. 修改 `core/config.py` 中的 `export_favorites()` 方法
2. 导出时自动生成 `groups` 字段
3. 测试不同数量配色的导出

**导出逻辑（已简化）**：

```python
def export_favorites(favorites: list) -> dict:
    """导出配色，自动生成分组"""
    
    total = len(favorites)
    groups = _generate_groups(total)
    
    export_data = {
        "version": "1.0",
        "id": f"user_palettes_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
        "name": "",
        "name_zh": "",
        "description": "",
        "author": "",
        "created_at": datetime.now().isoformat(),
        "category": "user_palette",
        "palettes": [
            {
                "name": f"配色 #{i+1}",
                "colors": [color.get("hex") for color in fav.get("colors", [])]
            }
            for i, fav in enumerate(favorites)
        ],
        "groups": groups  # 始终包含分组
    }
    
    return export_data
```

**导出示例**：

少于20组：

```json
{
  "version": "1.0",
  "id": "user_palettes_20240115_143000",
  "palettes": [...],
  "groups": [
    {"name": "全部 (15组)", "indices": [0, 1, 2, ..., 14]}
  ]
}
```

达到20组以上：

```json
{
  "version": "1.0",
  "id": "user_palettes_20240115_143000",
  "palettes": [...],
  "groups": [
    {"name": "第 1-20 组", "indices": [0, 1, ..., 19]},
    {"name": "第 21-40 组", "indices": [20, 21, ..., 39]},
    {"name": "第 41-60 组", "indices": [40, 41, ..., 59]},
    {"name": "第 61-80 组", "indices": [60, 61, ..., 79]},
    {"name": "第 81-85 组", "indices": [80, 81, ..., 84]}
  ]
}
```

**验证点**：

- 导出JSON包含`groups`字段
- 分组配置正确
- 导出的JSON可直接作为配色源使用


---

#### 阶段 5.3：分批加载支持

**目标**：配色数量大时支持分批加载

**步骤**：


1. 复用阶段 4.x 的 `GroupLoaderThread` 线程
2. 实现色彩管理面板的分批加载逻辑
3. 测试大数据量加载

**验证点**：

- 大数据量加载流畅
- 快速切换分组时正确取消旧任务


---

## 五、社区贡献流程

### 5.1 用户导出配色


1. 用户在配色管理面板点击「导出」
2. 导出为标准格式JSON文件（可选包含`groups`字段）
3. 用户可在JSON中自定义分组

### 5.2 社区PR流程

```text
用户导出 → GitHub Issue/PR → 审核通过 → 合并到 color_data/community/
                                    ↓
                              自动发现并加载（包含自定义分组）
```

### 5.3 社区配色目录结构

```text
color_data/
├── open_color.json          # 官方配色（含groups）
├── tailwind_colors.json     # 官方配色（含groups）
├── ...
└── community/               # 社区贡献
    ├── user_palette_001.json
    └── ...
```

### 5.4 社区贡献示例

贡献者可以在JSON中定义自己的分组方式，包括分批加载配置：

**示例1：系列型配色（带分批加载）**

```json
{
  "version": "1.0",
  "id": "my_custom_series",
  "name": "My Custom Series",
  "type": "series",
  "series": {
    "warm1": {"name": "暖色1", "colors": [...]},
    "warm2": {"name": "暖色2", "colors": [...]},
    "warm3": {"name": "暖色3", "colors": [...]},
    "cool1": {"name": "冷色1", "colors": [...]},
    "cool2": {"name": "冷色2", "colors": [...]},
    "cool3": {"name": "冷色3", "colors": [...]}
  },
  "groups": [
    {
      "name": "暖色调",
      "keys": ["warm1", "warm2", "warm3"],
      "batch_load": true,
      "batch_size": 2
    },
    {
      "name": "冷色调",
      "keys": ["cool1", "cool2", "cool3"],
      "batch_load": true,
      "batch_size": 2
    }
  ]
}
```

**示例2：配色组型（带分批加载）**

```json
{
  "version": "1.0",
  "id": "my_custom_palettes",
  "name": "My Custom Palettes",
  "type": "palettes",
  "palettes": [...],
  "groups": [
    {"name": "暖色调", "range": [0, 20], "batch_load": true, "batch_size": 5},
    {"name": "冷色调", "range": [21, 40], "batch_load": true, "batch_size": 5},
    {"name": "中性色", "range": [41, 50], "batch_load": false}
  ]
}
```


---

## 六、预期收益

|指标 |重构前 |重构后 |
|---|---|---|
|color_data.py 行数 |~1550行 |~300行 |
|新增配色源修改点 |4处以上 |0处（仅添加JSON） |
|JSON格式统一度 |30% |100% |
|分组定义位置 |Python代码硬编码 |JSON文件内定义 |
|社区贡献支持 |无 |完整支持（含自定义分组） |
|大数据量加载 |卡顿 |流畅（多线程+分组） |
|色彩管理面板分组 |无 |自动分组+分批加载 |
|导出JSON可用性 |需手动编辑 |可直接作为配色源 |
|代码可维护性 |低 |高 |


---

## 七、文件清单

需要修改的文件：

- `color_data/*.json` - 13个文件格式统一，添加`type`和`groups`字段（阶段 2.x）
- `core/color_data.py` - 重构加载逻辑，添加`ColorSource`类（阶段 3.x）
- `core/config.py` - 导出格式改造（阶段 1.x）✅ 已完成；导出自动分组（阶段 5.x）
- `ui/preset_color_widgets.py` - 简化UI层，移除硬编码分组（阶段 4.x）
- `ui/interfaces.py` - **移除**硬编码分组定义（阶段 4.x）
- `ui/color_management_panel.py` - 添加分组下拉框和分批加载（阶段 5.x）

新增文件：

- `color_data/community/.gitkeep` - 社区配色目录（阶段 4.x）
- `scripts/migrate_color_data.py` - 格式转换脚本（阶段 2.x）


