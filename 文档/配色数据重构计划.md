# 配色数据重构计划

## 一、现状分析

### 1.1 JSON格式现状

当前项目包含13个配色JSON文件，格式存在以下不一致：

| 文件 | 元数据字段 | 颜色存储方式 | 特殊字段 |
|------|-----------|-------------|---------|
| nice_palettes.json | `palettes` 数组 | 直接颜色列表 | 无 name/name_en |
| open_color.json | `source`, `url` | `colors` 对象 | 标准格式 |
| tailwind_colors.json | `source`, `url` | `colors` 对象 | 标准格式 |
| material_design.json | `source`, `url` | `colors` 对象 | 标准格式 |
| colorbrewer.json | `source`, `url` | `colors` 对象 | 有 `type` 字段 |
| catppuccin.json | `description`, `source` | `colors` 对象 | 有 `count` 字段 |
| nord.json | `description`, `source` | `colors` 对象 | 有 `count` 字段 |
| dracula.json | `description`, `source` | `colors` 对象 | 有 `count` 字段 |
| 其他主题文件 | 类似上述 | `colors` 对象 | 各有差异 |

### 1.2 代码冗余问题

`core/color_data.py` 文件约1550行，存在大量重复代码：

```
重复模式：
- _load_xxx_data()     → 13个几乎相同的函数
- _get_xxx_data()      → 13个几乎相同的函数  
- get_xxx_series_names() → 13个几乎相同的函数
- get_xxx_color_series() → 13个几乎相同的函数
- get_xxx_light_shades() → 多个类似函数
- get_xxx_dark_shades()  → 多个类似函数
```

### 1.3 UI层扩展困难

`ui/preset_color_widgets.py` 中：

- `set_data_source()` 方法有13个 if-elif 分支
- 每个配色源需要独立的 `_load_xxx_series()` 方法
- 新增配色源需要修改至少4处代码

### 1.4 配色管理导出格式

当前配色管理面板导出的JSON格式与内置配色JSON格式不一致，无法直接作为配色源使用。

---

## 二、重构目标

1. **统一JSON格式**：建立标准化的配色JSON格式规范
2. **简化加载函数**：使用配置驱动 + 自动发现机制
3. **UI扩展接口**：新增配色只需添加JSON文件，零代码修改
4. **大数据量加载优化**：配色组超过50组时自动使用多线程分批加载
5. **社区贡献支持**：配色管理导出格式与标准格式统一

---

## 三、统一JSON格式规范

### 3.1 标准格式（系列型）

适用于有多个颜色系列的配色方案：

```json
{
  "version": "1.0",
  "id": "open_color",
  "name": "Open Color",
  "name_zh": "Open Color",
  "description": "开源配色方案",
  "author": "Open Color 团队",
  "category": "design_system",
  "series": {
    "gray": {
      "name": "灰色",
      "name_en": "Gray",
      "colors": ["#F8F9FA", "#F1F3F5", "#E9ECEF", "#DEE2E6", "#CED4DA", 
                 "#ADB5BD", "#868E96", "#495057", "#343A40", "#212529"]
    }
  }
}
```

### 3.2 配色组格式（Palette型）

适用于无系列的配色集合：

```json
{
  "version": "1.0",
  "id": "nice_palettes",
  "name": "Nice Color Palettes",
  "name_zh": "精选配色组",
  "description": "500组精选配色方案",
  "author": "mrmrs",
  "category": "palette",
  "palettes": [
    {
      "name": "配色 #1",
      "colors": ["#69d2e7", "#a7dbd8", "#e0e4cc", "#f38630", "#fa6900"]
    }
  ]
}
```

### 3.3 用户导出格式（社区贡献）

```json
{
  "version": "1.0",
  "id": "user_palettes_20240101",
  "name": "My Color Palettes",
  "name_zh": "我的配色收藏",
  "description": "个人收藏的配色方案",
  "author": "用户名",
  "created_at": "2024-01-01T12:00:00",
  "category": "user_palette",
  "palettes": [
    {
      "name": "日落渐变",
      "colors": ["#FF6B6B", "#FFA07A", "#FFD93D", "#6BCB77", "#4D96FF"]
    }
  ]
}
```

### 3.4 字段说明

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `version` | string | 是 | 格式版本号 |
| `id` | string | 是 | 唯一标识符 |
| `name` | string | 是 | 配色方案名称（英文） |
| `name_zh` | string | 否 | 配色方案中文名称 |
| `description` | string | 否 | 描述信息 |
| `author` | string | 是 | 作者名称 |
| `created_at` | string | 否 | 创建时间（用户导出专用） |
| `category` | string | 否 | 分类：`design_system`/`theme`/`palette`/`user_palette` |
| `series` | object | 条件 | 颜色系列集合（系列型必填） |
| `palettes` | array | 条件 | 配色组列表（配色组型必填） |
| `series.{key}.name` | string | 是 | 系列中文名称 |
| `series.{key}.name_en` | string | 否 | 系列英文名称 |
| `series.{key}.colors` | array | 是 | 颜色值数组（HEX格式） |
| `series.{key}.type` | string | 否 | 类型（ColorBrewer专用） |

---

## 四、分阶段重构计划

### 版本规划说明

| 版本 | 阶段 | 内容 | 依赖 |
|------|------|------|------|
| **当前版本** | 阶段 1.x | 配色管理导入导出格式改造 | 无 |
| **下个版本** | 阶段 2.x | 内置配色JSON格式统一 | 阶段 1.x 完成 |
| **下个版本** | 阶段 3.x | 加载函数重构 | 阶段 2.x 完成 |
| **下个版本** | 阶段 4.x | UI层简化 | 阶段 3.x 完成 |

---

### 阶段 1.x：配色管理导入导出格式改造（当前版本）

**目标**：统一用户数据格式，为后续重构打基础

#### 阶段 1.1：修改导出格式 ✅ 已完成

**目标**：导出功能输出新格式

**步骤**：

1. ✅ 修改 `core/config.py` 中的 `export_favorites()` 方法
2. ~~添加导出元数据输入对话框（名称、描述、作者）~~ 已移除，元数据字段默认为空
3. ✅ 测试导出功能

**验证点**：
- ✅ 导出的JSON文件符合新格式规范
- ✅ 包含 `version`, `id`, `name`, `author`, `palettes` 等字段

**风险**：无（导出功能独立，不影响现有功能）

**实际实现说明**：
- 元数据字段（`name`, `name_zh`, `description`, `author`）默认为空字符串
- `id` 自动生成，格式为 `user_palettes_YYYYMMDD_HHMMSS`
- 颜色数据转换为纯 HEX 格式数组

---

#### 阶段 1.2：修改导入格式 ✅ 已完成

**目标**：导入功能支持新格式，移除旧格式兼容

**步骤**：

1. ✅ 修改 `core/config.py` 中的 `import_favorites()` 方法
2. ✅ 仅支持新格式，旧格式返回错误提示
3. ✅ 测试导入功能

**验证点**：
- ✅ 新格式JSON文件可正常导入
- ✅ 旧格式JSON文件返回明确的错误提示

**风险**：用户旧数据无法导入

**用户迁移方案**：
1. 发布版本前通知用户导出数据
2. 用户使用新版本导出功能重新导出
3. 新版本导入只支持新格式

**实际实现说明**：
- 导入时检测 `palettes` 字段（新格式）
- 旧格式（使用 `favorites` 字段）返回错误提示
- 导入时自动将 HEX 颜色转换为完整的颜色信息字典

---

#### 阶段 1.3：优化导出配色默认名称 ✅ 已完成

**目标**：导出的配色文件JSON的默认名称改为时间戳格式

**实现说明**：
- 修改 `ui/interfaces.py` 中的 `_on_export_clicked()` 方法
- 默认文件名从 `color_card_favorites.json` 改为 `color_card_YYYYMMDD_HHMMSS.json`
- 使用 `datetime.now().strftime('%Y%m%d_%H%M%S')` 生成时间戳


---

#### 阶段 1.4：发布版本

**目标**：发布包含新导入导出格式的版本

**步骤**：

1. 更新版本号
2. 更新更新日志，说明导入导出格式变更
3. 发布版本

**用户通知内容**：
```
【重要】配色管理导入导出格式变更

本次更新统一了配色数据的JSON格式，便于后续功能扩展和社区贡献。

请用户在更新后重新导出配色数据，旧格式文件将无法导入。
```

---

### 阶段 2.x：内置配色JSON格式统一（下个版本）

**目标**：将所有内置配色JSON文件转换为统一格式

#### 阶段 2.1：创建转换脚本

**目标**：编写自动化转换工具

**步骤**：

1. 创建 `scripts/migrate_color_data.py` 转换脚本
2. 实现格式检测和转换逻辑
3. 添加作者信息映射表

**转换规则**：

| 原格式 | 新格式 |
|--------|--------|
| `colors: {"0": "#xxx", "1": "#xxx"}` | `colors: ["#xxx", "#xxx"]` |
| `colors` 对象包装 | `series` 对象或 `palettes` 数组 |
| 分散的元数据字段 | 统一的 `id`, `name`, `name_zh`, `category`, `author` |

**验证点**：
- 脚本可正确识别不同格式
- 转换后数据完整无误

---

#### 阶段 2.2：转换单个文件验证

**目标**：先转换一个文件验证流程

**步骤**：

1. 选择 `open_color.json` 作为首个转换目标
2. 运行转换脚本
3. 手动检查转换结果
4. 验证应用加载正常

**验证点**：
- JSON格式正确
- 应用可正常加载该配色

**风险控制**：
- 保留原文件备份
- 仅修改一个文件，便于回滚

---

#### 阶段 2.3：批量转换所有文件

**目标**：转换剩余所有配色文件

**步骤**：

1. 批量运行转换脚本
2. 逐个检查转换结果
3. 验证应用加载所有配色正常

**验证点**：
- 所有13个文件转换成功
- 应用可正常加载所有配色

---

### 阶段 3.x：加载函数重构（下个版本）

**目标**：简化 `core/color_data.py`，消除重复代码

#### 阶段 3.1：创建注册表类

**目标**：实现配色源注册表，与现有代码并存

**步骤**：

1. 在 `core/color_data.py` 中创建 `ColorSourceRegistry` 类
2. 实现注册、加载、查询等基础方法
3. 暂不修改现有函数

**验证点**：
- 注册表类可正常工作
- 不影响现有功能

---

#### 阶段 3.2：实现自动发现

**目标**：实现配色源自动发现机制

**步骤**：

1. 实现 `auto_discover_sources()` 函数
2. 扫描 `color_data` 目录下的JSON文件
3. 自动注册配色源

**验证点**：
- 可正确发现所有配色源
- 注册信息正确

---

#### 阶段 3.3：创建统一访问接口

**目标**：提供统一的数据访问接口

**步骤**：

1. 创建 `get_color_source()` 函数
2. 创建 `get_series_names()` 函数
3. 创建 `get_series()` 函数
4. 创建 `get_palettes_batch()` 函数

**验证点**：
- 接口可正确返回数据
- 数据格式与现有函数一致

---

#### 阶段 3.4：添加兼容层

**目标**：提供向后兼容的包装函数

**步骤**：

1. 修改现有函数调用新接口
2. 保持函数签名不变
3. 添加废弃警告

**验证点**：
- 现有代码无需修改
- 功能正常

---

### 阶段 4.x：UI层简化（下个版本）

**目标**：简化 `ui/preset_color_widgets.py`

#### 阶段 4.1：创建配色源选择器

**目标**：实现动态配色源选择组件

**步骤**：

1. 创建 `ColorSourceSelector` 组件
2. 从注册表动态生成选项列表
3. 测试选择器功能

**验证点**：
- 选项列表正确
- 选择切换正常

---

#### 阶段 4.2：实现智能加载策略

**目标**：根据数据量自动选择加载方式

**步骤**：

1. 在 `PresetColorList` 中添加 `is_large_palette()` 判断
2. 实现普通加载和大数据量加载两种模式
3. 测试两种模式

**验证点**：
- 普通配色同步加载
- 大数据量配色多线程加载

---

#### 阶段 4.3：简化数据源设置方法

**目标**：统一 `set_data_source()` 方法

**步骤**：

1. 重构 `set_data_source()` 方法
2. 移除冗余的 `_load_xxx_series()` 方法
3. 测试所有配色源切换

**验证点**：
- 所有配色源可正常切换
- 加载显示正确

---

## 五、社区贡献流程

### 5.1 用户导出配色

1. 用户在配色管理面板点击「导出」
2. 填写配色方案信息（名称、描述、作者）
3. 导出为标准格式JSON文件

### 5.2 社区PR流程

```
用户导出 → GitHub Issue/PR → 审核通过 → 合并到 color_data/community/
                                    ↓
                              自动发现并加载
```

### 5.3 社区配色目录结构

```
color_data/
├── open_color.json          # 官方配色
├── tailwind_colors.json     # 官方配色
├── ...
└── community/               # 社区贡献
    ├── user_palette_001.json
    ├── user_palette_002.json
    └── ...
```

---

## 六、预期收益

| 指标 | 重构前 | 重构后 |
|------|--------|--------|
| color_data.py 行数 | ~1550行 | ~300行 |
| 新增配色源修改点 | 4处以上 | 0处（仅添加JSON） |
| JSON格式统一度 | 30% | 100% |
| 社区贡献支持 | 无 | 完整支持 |
| 大数据量加载 | 卡顿 | 流畅（多线程） |
| 代码可维护性 | 低 | 高 |

---

## 七、文件清单

需要修改的文件：
- `color_data/*.json` - 13个文件格式统一（阶段 2.x）
- `core/color_data.py` - 重构加载逻辑（阶段 3.x）
- `core/config.py` - 导出格式改造（阶段 1.x）
- `ui/preset_color_widgets.py` - 简化UI层（阶段 4.x）

新增文件：
- `color_data/community/.gitkeep` - 社区配色目录（阶段 4.x）
- `scripts/migrate_color_data.py` - 格式转换脚本（阶段 2.x）
