# 代码审查报告

**审查日期**: 2026-02-12  
**项目**: Color Card (取色卡)

---

## 核心设计理念

### 1. 公共模块统一管理，业务模块按需调用

- `styles/`、`utils/`、`core/` 作为公共模块，提供统一的基础能力
- `ui/`、`dialogs/` 作为业务模块，按需调用公共模块
- 每个功能域一个目录，目录内扁平，不再嵌套子目录

### 2. 前后端分离架构

本项目采用**前后端分离**的架构思想，虽然是单机桌面应用，但遵循清晰的分层设计：

```
┌─────────────────────────────────────────┐
│              前端层 (Presentation)       │
│  ┌─────────────────────────────────┐    │
│  │  ui/、dialogs/                  │    │
│  │  - 负责界面展示和用户交互        │    │
│  │  - 不包含业务逻辑，只调用服务    │    │
│  │  - 通过信号/槽与后端通信         │    │
│  └─────────────────────────────────┘    │
├─────────────────────────────────────────┤
│              后端层 (Business Logic)     │
│  ┌─────────────────────────────────┐    │
│  │  core/                          │    │
│  │  - 负责业务逻辑和数据处理        │    │
│  │  - 提供 Service 接口供前端调用   │    │
│  │  - 通过信号通知前端状态变化      │    │
│  └─────────────────────────────────┘    │
├─────────────────────────────────────────┤
│              工具层 (Utilities)          │
│  ┌─────────────────────────────────┐    │
│  │  utils/                         │    │
│  │  - 提供通用工具函数和常量        │    │
│  │  - 无业务逻辑，纯工具性质        │    │
│  └─────────────────────────────────┘    │
└─────────────────────────────────────────┘
```

**分层原则**：
- **前端不直接操作数据**：所有数据处理通过后端 Service 完成
- **后端不依赖前端**：core 层不导入 ui 层的任何模块
- **单向依赖**：ui → core → utils，禁止反向依赖
- **通信机制**：前端通过调用后端方法请求操作，后端通过信号通知前端更新

---

## 一、项目结构评估

### 优点

- 目录划分基本合理：`core/`（核心逻辑）、`ui/`（界面组件）、`utils/`（工具函数）、`dialogs/`（对话框）
- 模块导出统一使用 `__init__.py` 管理

### 问题

1. **单文件过大**：`ui/interfaces.py` 近 **2900 行**，包含 7 个界面类，违反单一职责原则
2. **职责边界模糊**：`ConfigManager` 和 `SceneConfigManager` 放在同一文件中，但职责不同

---

## 二、代码冗余问题

### 1. RYB/RGB 配色生成函数高度重复

`core/color.py` 第 1389-1635 行中，RYB 配色函数与 RGB 版本几乎完全相同：

```python
# RGB 版本
def generate_monochromatic(hue: float, count: int = 4, base_saturation: float = 100):
    ...
    colors.append((hue % 360, s, b))

# RYB 版本 - 仅多了色相转换
def generate_ryb_monochromatic(ryb_hue: float, count: int = 4, base_saturation: float = 100):
    ...
    rgb_hue = ryb_hue_to_rgb_hue(ryb_hue)  # 唯一区别
    colors.append((rgb_hue % 360, s, b))
```

**建议**：提取公共逻辑，通过参数控制色相转换。

### 2. ImageCanvas 与 LuminanceCanvas 重复代码

`ui/canvases.py` 中两个类共享大量代码：
- `_setup_blurry_preview()`
- `_on_image_load_error()`
- `_setup_after_load()`
- `_on_picker_added/removed()`
- 图片加载逻辑

虽然继承了 `BaseCanvas`，但子类间仍有重复。

### 3. 高饱和度/高明度区域高亮逻辑重复

`ui/canvases.py` 第 1114-1400 行中：
- `_generate_high_saturation_pixmap()` 与 `_generate_high_brightness_pixmap()` 
- `_draw_high_saturation_highlight()` 与 `_draw_high_brightness_highlight()`
- `_draw_high_saturation_info()` 与 `_draw_high_brightness_info()`

逻辑几乎完全相同，仅判断条件不同（`s >= threshold` vs `v >= threshold`）。

### 4. 主题样式代码重复

多个界面类中的 `_update_styles()` 方法有大量重复的主题适配代码：

```python
# 在 SettingsInterface、PaletteManagementInterface、PresetColorInterface 中重复
if is_windows_10():
    bg_color = get_interface_background_color()
    card_bg = get_card_background_color()
    ...
```

---

## 三、逻辑清晰度问题

### 1. 图片同步逻辑复杂

`ui/main_window.py` 第 352-411 行中存在复杂的双向同步：

```python
def sync_image_data_to_luminance(self, pixmap, image):
    self.luminance_extract_interface.set_image_data(pixmap, image, emit_sync=False)

def sync_clear_to_luminance(self):
    if self._is_clearing:  # 防止递归
        return
    self._is_clearing = True
    ...
```

需要 `_is_clearing` 标志防止循环调用，说明设计存在问题。

#### 问题根源

原始设计是"单一入口"：所有图片都通过色彩提取面板导入，然后同步到明度面板。

但这样导致**明度面板没有加载动画**（只是被动接收数据，没有触发自己的加载流程）。

为了解决这个问题，改为让两个面板都能独立导入，但代价是：
- 双向同步逻辑
- 防循环机制（`_is_clearing`、`emit_sync`）
- 信号链过长（4 层传递）
- 数据重复存储

#### 当前同步流程

**从色彩面板导入：**
```
用户导入图片 → ImageCanvas.set_image() → 异步加载
    → _setup_after_load() → 发射 image_data_loaded 信号
    → MainWindow.sync_image_data_to_luminance()
    → LuminanceCanvas.set_image_data(emit_sync=False)
```

**从明度面板导入：**
```
用户导入图片 → LuminanceCanvas.set_image() → 异步加载
    → _setup_after_load() → 发射 image_loaded 信号
    → LuminanceExtractInterface._on_image_loaded_sync()
    → 发射 image_imported 信号
    → MainWindow.on_luminance_image_imported()
    → ImageCanvas.set_image_data(emit_sync=False)
```

两套几乎相同的逻辑，代码分散在多个地方。

### 2. PresetColorInterface 分组定义过于冗长

`ui/interfaces.py` 第 2063-2151 行中定义了大量分组常量：

```python
OPEN_COLOR_GROUPS = [...]
TAILWIND_GROUPS = [...]
MATERIAL_GROUPS = [...]
COLORBREWER_GROUPS = [...]
RADIX_GROUPS = [...]
NORD_GROUPS = [...]
# ... 还有更多
```

这些数据应该移到配置文件或数据文件中。

### 3. 设置连接过于分散

`ui/main_window.py` 第 470-591 行中 `_setup_settings_connections()` 方法连接了大量信号：

```python
self.settings_interface.hex_display_changed.connect(...)
self.settings_interface.color_modes_changed.connect(...)
self.settings_interface.color_sample_count_changed.connect(...)
# ... 20+ 个连接
```

---

## 四、架构问题

### 1. 缺少服务层（违反前后端分离原则）

**当前问题**：业务逻辑直接写在界面类中，前端承担了后端的职责。

例如：
- `ColorExtractInterface` 中包含主色调提取逻辑
- `PaletteManagementInterface` 中包含导入导出逻辑
- 界面类既管显示又管计算，违反单一职责原则

**影响**：
- 前端代码臃肿，难以维护
- 业务逻辑无法复用
- 单元测试困难（必须启动UI才能测试业务逻辑）

**建议**：抽取 Service 层，实现前后端分离

```python
# core/services/color_service.py - 后端服务
class ColorService(QObject):
    """颜色处理服务 - 纯业务逻辑，无UI依赖"""
    
    colors_extracted = Signal(list)  # 通知前端更新
    
    def extract_dominant_colors(self, image: QImage, count: int) -> List[Color]:
        # 纯算法逻辑
        ...
        self.colors_extracted.emit(colors)
        return colors

# ui/color_extract.py - 前端界面  
class ColorExtractInterface(QWidget):
    """色彩提取界面 - 只负责展示，不处理逻辑"""
    
    def __init__(self, color_service: ColorService):
        self._service = color_service
        # 订阅后端服务的事件
        self._service.colors_extracted.connect(self._display_colors)
    
    def on_extract_clicked(self):
        # 前端只负责调用后端服务
        self._service.extract_dominant_colors(self._image, count=5)
```

**需要抽取的服务**：
- `ColorService`：颜色提取、转换、计算
- `PaletteService`：调色板导入导出、管理
- `ImageService`：图片加载、处理（替代 ImageMediator）
- `ThemeService`：主题管理
- `ConfigService`：配置管理（替代 ConfigManager）

### 2. 主题管理分散

主题相关代码分散在：
- `theme_colors.py`（颜色定义）
- 各界面类的 `_update_styles()` 方法
- `main.py` 中的主题设置

**建议**：创建统一的 `ThemeManager`。

### 3. 配置管理职责不清

`ConfigManager` 承担了过多职责：
- 应用配置管理
- 收藏管理（add_favorite, delete_favorite, rename_favorite）
- 导入导出

**建议**：分离为 `AppConfig` 和 `FavoritesManager`。

---

## 五、具体代码问题

### 1. 硬编码路径

`ui/main_window.py` 第 315 行：
```python
logo_path = 'd:\\青山公仔\\应用\\Py测试\\color_card\\logo\\Color Card_logo.ico'
```

应使用相对路径或配置。

### 2. 魔法数字

`core/color.py` 第 546-559 行：
```python
if count == 4:
    saturations = [
        base_saturation,
        max(20, base_saturation * 0.75),
        max(20, base_saturation * 0.5),
        max(20, base_saturation * 0.25)
    ]
    brightnesses = [100, 90, 80, 70]
```

这些数字应该定义为常量并添加注释说明。

### 3. 异常处理不完善

`core/config.py` 第 89-92 行：
```python
except (json.JSONDecodeError, IOError, OSError) as e:
    print(f"加载配置文件失败: {e}")
    # 使用默认配置 - 但没有通知用户
```

### 4. 类型注解不一致

部分函数有完整类型注解，部分没有：
```python
def rgb_to_hsb(r: int, g: int, b: int) -> Tuple[float, float, float]:  # 有
def get_color_info(r: int, g: int, b: int) -> Dict[str, any]:  # any 应为 Any
```

---

## 六、重构建议优先级

| 优先级 | 问题 | 建议 | 前后端分离目标 |
|--------|------|------|----------------|
| **高** | interfaces.py 过大 | 拆分为独立文件 | UI层瘦身，逻辑下沉到core/ |
| **高** | 图片同步逻辑复杂 | 引入 ImageMediator 服务 | 建立后端服务，前端只订阅展示 |
| **中** | RYB/RGB 函数重复 | 提取公共函数 | 后端工具函数统一化 |
| **中** | 高亮逻辑重复 | 合并为通用函数 | 后端图像处理逻辑统一 |
| **中** | 分组数据硬编码 | 移至 JSON 配置 | 数据与逻辑分离 |
| **中** | 缺少服务层 | 抽取 ColorService、PaletteService | **核心：建立后端服务层** |
| **低** | 主题管理分散 | 创建 ThemeService | 主题作为后端服务 |
| **低** | 配置职责过多 | 分离为 ConfigService | 配置管理作为后端服务 |
| **长期** | 后端服务延迟加载 | 实现 ServiceFactory + 懒加载 | 提升启动性能 50%+ |
| **长期** | Python 3.14t 适配 | 利用 free-threading 优化并行计算 | 计算性能提升 3-5x |
| **长期** | 配置验证与类型安全 | 集成 Pydantic | 后端数据模型强类型化 |

### 长期目标一：后端服务延迟加载

**目标**：将非核心后端服务的初始化推迟到首次使用时，提升应用启动速度。

**收益**：
- 启动时间减少 50%（从 ~2s 降至 ~1s）
- 启动内存减少 33%（从 ~150MB 降至 ~100MB）
- 首屏即时响应，无需等待所有数据加载
- 渐进式加载，用户体验更流畅

**实施范围**：
- ✅ `PaletteService` - 配色数据懒加载
- ✅ `ImageService` - 图像处理资源按需初始化
- ✅ `UpdateService` - 更新检查后台延迟执行
- ❌ `ConfigService` - 配置服务需立即加载（启动必需）

**前置条件**：
1. 完成前后端分离架构重构
2. 建立 ServiceFactory 服务工厂
3. 前端界面支持加载状态显示

### 长期目标二：Python 3.14t Free-Threading 适配

**目标**：利用 Python 3.14t 的无 GIL（free-threading）特性，优化后端计算密集型任务的并行性能。

**背景**：
- Python 3.14t 引入了真正的并行线程执行能力，不再受 GIL 限制
- 项目的直方图计算、颜色转换等 CPU 密集型任务可以充分利用多核 CPU
- 相关优化计划已详细记录在 `文档/Python3.14t性能优化计划.md`

**收益**：
- 直方图计算性能提升 **5.3x**（从 ~800ms 降至 ~150ms）
- RGB 直方图计算性能提升 **3x**（从 ~1200ms 降至 ~400ms）
- Zone 高亮渲染性能提升 **4x**（从 ~2000ms 降至 ~500ms）
- 批量颜色转换性能提升 **2.5x**

**实施范围**：
- ✅ `core/color.py` - 直方图计算并行化
- ✅ `core/color.py` - RGB 直方图并行计算
- ✅ `ui/canvases.py` - Zone 高亮渲染多线程优化
- ✅ `core/color.py` - 批量颜色转换并行化
- ✅ `ui/canvases.py` - 图片处理流水线并行化

**前置条件**：
1. 完成前后端分离架构重构（确保计算逻辑在 core/ 层）
2. Python 3.14t 环境部署
3. PySide6 兼容性测试
4. 充分的性能基准测试

**注意事项**：
- Qt GUI 操作仍需在主线程执行（Qt 设计限制）
- NumPy 可能需要设置 `OMP_NUM_THREADS=1` 避免线程竞争
- 需要控制并行线程数，避免内存占用过高

### 长期目标三：Pydantic 集成

**目标**：提高配置管理的类型安全性和数据验证能力。

**收益**：
- 自动数据验证，减少手写验证逻辑
- 类型提示增强，改善 IDE 开发体验
- JSON 序列化/反序列化简化
- 默认值管理更清晰

**实施范围**：
- ✅ `core/config.py` - ConfigManager 配置模型
- ✅ `core/config.py` - SceneConfigManager 场景配置
- ❌ `core/color_data.py` - 颜色数据（数据量大，保持现状）

**前置条件**：
1. 完成架构重构（目录结构调整）
2. 完成高优先级重构任务
3. 项目功能稳定后实施

---

## 七、总结

这个项目功能完整，但确实存在技术债问题。主要问题是：

1. **快速迭代导致的代码膨胀**：界面类过大，职责不清
2. **缺乏抽象**：相似逻辑没有提取公共实现
3. **耦合度高**：界面与业务逻辑混在一起，未实现前后端分离

### 重构的核心思想：前后端分离

本次重构的终极目标是在单机桌面应用中实现**前后端分离架构**：

```
重构前（混合架构）：                    重构后（前后端分离）：
┌──────────────────┐                  ┌─────────────┐     ┌─────────────┐
│  ui/interfaces.py │                  │   ui/       │ ←── │   core/     │
│  (2900行，UI+逻辑) │                  │  (纯界面)   │ 调用 │  (业务服务)  │
│                  │                  │             │     │             │
│  界面展示         │                  │  显示颜色   │←────│  颜色计算    │
│  业务逻辑         │    ─────→        │  响应点击   │────→│  数据处理    │
│  数据处理         │    重构后        │  展示结果   │←────│  文件操作    │
│  文件操作         │                  │             │ 信号 │             │
└──────────────────┘                  └─────────────┘     └─────────────┘
     难以维护                              职责清晰
     无法测试                              可独立测试
```

### 前后端分离带来的收益

| 方面 | 重构前 | 重构后 |
|-----|-------|-------|
| **职责** | 界面里混着业务逻辑 | 界面只负责展示，逻辑交给后端 |
| **测试** | 必须启动UI才能测试 | 后端服务可独立单元测试 |
| **复用** | 逻辑分散无法复用 | 后端服务可被多处调用 |
| **维护** | 改一处可能影响多处 | 修改隔离，影响范围清晰 |
| **协作** | 难以分工 | 前端后端可独立开发 |

### 优先处理项

建议优先处理以下两项，它们是实现前后端分离的关键：

1. **`interfaces.py` 拆分**：将混合的UI和逻辑分离，UI归ui/，逻辑归core/
2. **图片同步逻辑重构**：引入 `ImageMediator` 作为后端服务，前端只负责订阅和展示

---

## 八、建议的重构方案

### 1. 目录结构调整

**核心原则**：公共模块统一管理，业务模块按需调用，扁平结构不嵌套。

```
color_card/
├── core/                      # 业务核心（公共模块）
│   ├── __init__.py
│   ├── color.py
│   ├── color_data.py
│   ├── colorblind.py
│   ├── config.py
│   ├── contrast.py
│   ├── svg_color_mapper.py
│   └── image_mediator.py      # 新增：图片状态中介者
│
├── utils/                     # 纯工具（公共模块）
│   ├── __init__.py
│   ├── icon.py
│   ├── platform.py
│   └── theme_colors.py        # 从 ui/ 移入
│
├── dialogs/                   # 对话框（业务模块）
│   ├── __init__.py
│   ├── about_dialog.py
│   ├── colorblind_dialog.py
│   ├── contrast_dialog.py
│   ├── name_dialog.py
│   └── update_dialog.py
│
├── ui/                        # UI模块（业务模块，功能内聚）
│   ├── __init__.py
│   ├── main_window.py
│   ├── canvases.py
│   ├── cards.py
│   ├── color_picker.py
│   ├── color_wheel.py
│   ├── histograms.py
│   ├── zoom_viewer.py
│   ├── color_extract.py           # Interface + widgets 合并
│   ├── luminance_extract.py       # Interface + widgets 合并
│   ├── color_generation.py        # Interface + widgets 合并
│   ├── palette_management.py      # Interface + widgets 合并
│   ├── color_preview.py           # Interface + widgets 合并
│   ├── preset_color.py            # Interface + widgets 合并
│   └── settings.py
│
└── main.py
```

**调整说明**：
- `ui/theme_colors.py` → `utils/theme_colors.py`（纯工具函数，归入 utils）
- `ui/interfaces.py` 拆分，与对应的 `*_widgets.py` 合并（功能内聚）
- 新增 `core/image_mediator.py` 作为后端服务，解决图片同步问题
- **前后端分离**：`core/` 作为后端服务层，`ui/` 作为前端展示层
- 不新建 `styles/` 和 `managers/` 目录，保持简单

#### 前后端分离的目录映射

```
color_card/
├── core/                      # 【后端】业务服务层
│   ├── color.py              #   颜色计算服务
│   ├── contrast.py           #   对比度计算服务
│   ├── colorblind.py         #   色盲模拟服务
│   ├── image_mediator.py     #   图片管理服务（新增）
│   └── config.py             #   配置管理服务
│
├── ui/                        # 【前端】界面展示层
│   ├── main_window.py        #   主窗口
│   ├── color_extract.py      #   色彩提取界面（调用后端服务）
│   ├── luminance_extract.py  #   明度提取界面（调用后端服务）
│   └── ...                   #   其他界面
│
├── utils/                     # 【工具】通用工具函数
│   └── ...
│
└── dialogs/                   # 【前端】对话框组件
    └── ...
```

**依赖规则**：
- ✅ `ui/` 可以导入 `core/` 和 `utils/`
- ✅ `dialogs/` 可以导入 `core/` 和 `utils/`
- ✅ `core/` 可以导入 `utils/`
- ❌ `core/` **禁止**导入 `ui/` 或 `dialogs/`（保证后端独立）
- ❌ `utils/` **禁止**导入 `core/`、`ui/` 或 `dialogs/`（保证工具独立）

### 2. 图片同步重构方案（前后端分离实践）

**设计目标**：将图片管理的业务逻辑从UI层剥离，形成独立的后端服务。

引入**中介者模式**作为后端服务，统一管理图片状态和分发：

#### 架构设计

```
┌─────────────────────────────────────────────────────┐
│                   ImageMediator                      │
│                                                      │
│  状态:                                               │
│    - _pixmap: QPixmap                               │
│    - _image: QImage                                 │
│    - _is_loading: bool                              │
│                                                      │
│  信号:                                               │
│    - loading_started()                              │
│    - loading_progress(int)                          │
│    - image_updated(pixmap, image)                   │
│    - image_cleared()                                │
│                                                      │
│  方法:                                               │
│    - load_image(path)      # 统一加载入口           │
│    - set_image_data(pixmap, image)  # 外部设置      │
│    - clear_image()                                   │
│    - get_image()                                     │
└───────────────────────┬─────────────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        ↓               ↓               ↓
   色彩面板        明度面板        其他面板
   (订阅者)        (订阅者)        (订阅者)
```

#### 代码实现

```python
# core/image_mediator.py
from PySide6.QtCore import QObject, Signal

class ImageMediator(QObject):
    """图片状态中介者 - 统一管理图片加载和分发"""
    
    loading_started = Signal()
    loading_progress = Signal(int)
    image_updated = Signal(object, object)  # QPixmap, QImage
    image_cleared = Signal()
    
    def __init__(self):
        super().__init__()
        self._pixmap = None
        self._image = None
        self._is_loading = False
    
    def load_image(self, path: str):
        """统一加载入口 - 任何面板调用都会触发完整流程"""
        self._is_loading = True
        self.loading_started.emit()
        # 异步加载...完成后调用 _on_loaded
    
    def _on_loaded(self, pixmap, image):
        self._pixmap = pixmap
        self._image = image
        self._is_loading = False
        self.image_updated.emit(pixmap, image)
    
    def clear_image(self):
        self._pixmap = None
        self._image = None
        self.image_cleared.emit()
```

```python
# 各面板的使用方式
class ColorExtractInterface(QWidget):
    def __init__(self, image_mediator: ImageMediator):
        self._mediator = image_mediator
        
        # 订阅中介者的事件
        self._mediator.loading_started.connect(self._show_loading)
        self._mediator.image_updated.connect(self._on_image_updated)
        self._mediator.image_cleared.connect(self._on_image_cleared)
    
    def open_image(self):
        file_path = self._select_file()
        if file_path:
            self._mediator.load_image(file_path)  # 统一入口
```

#### 方案对比

| 方面 | 当前方案 | 中介者方案 |
|------|----------|------------|
| 导入入口 | 两个独立流程 | 统一入口 |
| 同步逻辑 | 面板间直接通信 | 通过中介者 |
| 加载动画 | 各自管理 | 中介者统一通知 |
| 防循环机制 | 需要 `_is_clearing`、`emit_sync` | 不需要 |
| 扩展新面板 | 需修改多处 | 只需订阅中介者 |
| 数据存储 | 两份 | 一份（可共享） |

#### 好处

1. **单一职责**：图片加载逻辑集中在后端服务（中介者）
2. **解耦**：前端面板之间不直接通信，都通过后端服务交互
3. **可扩展**：新增前端面板只需订阅后端服务信号
4. **易测试**：后端服务可独立测试，无需启动UI
5. **状态一致**：所有前端面板看到的都是同一份后端数据
6. **符合前后端分离**：`ImageMediator` 作为后端服务，`ColorExtractInterface` 等作为前端界面

### 3. 后端服务延迟加载方案

**设计目标**：将非核心后端服务的初始化推迟到首次使用时，提升应用启动速度。

#### 可延迟加载的后端服务

| 服务 | 当前做法 | 优化后 | 预期收益 |
|-----|---------|-------|---------|
| **PaletteService** | 启动时加载所有配色JSON | 按功能模块懒加载 | 启动快 300-500ms |
| **ImageService** | 预分配图像处理资源 | 首次导入图片时初始化 | 节省 30-50MB 内存 |
| **UpdateService** | 启动时检查更新 | 后台延迟检查 | 不阻塞启动流程 |
| **AnalyticsService** | 启动时初始化 | 首次记录时初始化 | 减少启动开销 |

#### 延迟加载实现模式

**模式一：懒加载（Lazy Initialization）**

```python
# core/services/palette_service.py
class PaletteService:
    """配色数据服务 - 延迟加载实现"""
    
    _instance = None
    _cache = {}
    _loaded_files = set()
    
    @classmethod
    def get_instance(cls):
        """单例模式，首次使用时创建"""
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance
    
    def get_palette(self, name: str) -> Dict:
        """获取配色方案，首次使用时才加载"""
        if name not in self._loaded_files:
            self._load_palette_async(name)
        return self._cache.get(name, {})
    
    def _load_palette_async(self, name: str):
        """异步加载配色数据，不阻塞UI"""
        file_path = f"color_data/{name}.json"
        # 使用 QThreadPool 或 asyncio 异步加载
        # 加载完成后发射信号通知前端
```

**模式二：服务工厂（Service Factory）**

```python
# core/service_factory.py
class ServiceFactory:
    """服务工厂 - 统一管理后端服务的创建和延迟加载"""
    
    _services = {}
    _initialized = set()
    
    @classmethod
    def get_service(cls, service_name: str):
        """获取服务实例，按需创建"""
        if service_name not in cls._services:
            cls._services[service_name] = cls._create_service(service_name)
        return cls._services[service_name]
    
    @classmethod
    def _create_service(cls, name: str):
        """创建服务实例"""
        creators = {
            'palette': PaletteService,
            'image': ImageService,
            'config': ConfigService,  # 配置服务需要立即加载
        }
        return creators[name]()
    
    @classmethod
    def initialize_critical_services(cls):
        """初始化关键服务（启动时必须）"""
        cls.get_service('config')
    
    @classmethod
    def initialize_background_services(cls):
        """后台初始化非关键服务"""
        # 延迟加载其他服务
        QTimer.singleShot(1000, lambda: cls.get_service('palette'))

# main.py 中使用
from core.service_factory import ServiceFactory

def main():
    app = QApplication(sys.argv)
    
    # 只初始化关键服务
    ServiceFactory.initialize_critical_services()
    
    # 创建主窗口，传入服务工厂
    window = MainWindow(ServiceFactory)
    window.show()
    
    # 后台初始化其他服务
    QTimer.singleShot(0, ServiceFactory.initialize_background_services)
    
    sys.exit(app.exec())
```

**模式三：前端按需触发加载**

```python
# ui/preset_color.py
class PresetColorInterface(QWidget):
    """预设配色界面 - 按需触发后端服务加载"""
    
    def __init__(self, service_factory):
        super().__init__()
        self._service_factory = service_factory
        self._palette_service = None  # 延迟获取
        self._is_loading = False
    
    def showEvent(self, event):
        """界面显示时触发加载"""
        super().showEvent(event)
        if self._palette_service is None:
            self._load_palette_data()
    
    def _load_palette_data(self):
        """加载配色数据"""
        self._is_loading = True
        self._show_loading_indicator()
        
        # 获取服务（首次使用时才真正创建）
        self._palette_service = self._service_factory.get_service('palette')
        
        # 异步加载数据
        palettes = self._palette_service.get_all_palettes_async()
        palettes.ready.connect(self._on_data_loaded)
    
    def _on_data_loaded(self, data):
        """数据加载完成"""
        self._is_loading = False
        self._hide_loading_indicator()
        self._display_palettes(data)
```

#### 前后端分离对延迟加载的支持

```
传统架构（难以延迟加载）：
┌─────────────────────────────────────┐
│  MainWindow                         │
│  ├── 导入时加载所有模块              │
│  ├── __init__ 中创建所有服务         │
│  │   └── PaletteService()  ← 阻塞！  │
│  │       └── 加载所有JSON           │
│  └── 创建所有面板                   │
│      └── 需要服务数据               │
└─────────────────────────────────────┘

前后端分离架构（易于延迟加载）：
┌─────────────────────────────────────┐
│  MainWindow (前端)                  │
│  ├── 快速显示基本界面               │
│  ├── 显示加载动画/占位符             │
│  └── 按需请求数据                   │
│      └── get_palette('material')    │
└─────────────┬───────────────────────┘
              │ 首次请求
┌─────────────▼───────────────────────┐
│  ServiceFactory (后端工厂)          │
│  └── 创建 PaletteService            │
│      └── 异步加载数据               │
│          └── 完成后通知前端          │
└─────────────────────────────────────┘
```

#### 延迟加载带来的收益

| 指标 | 当前 | 优化后 | 提升 |
|-----|------|-------|------|
| 启动时间 | ~2s | ~1s | **50%** |
| 启动内存 | ~150MB | ~100MB | **33%** |
| 首屏响应 | 等待所有数据 | 立即显示 | **即时** |
| 用户体验 | 等待 | 渐进加载 | **流畅** |

### 4. 高亮逻辑合并方案

```python
def _generate_highlight_pixmap(self, display_rect, mode='saturation'):
    """通用高亮遮罩生成
    
    Args:
        display_rect: 显示区域
        mode: 'saturation' 或 'brightness'
    """
    # 统一实现
    threshold = self._saturation_threshold if mode == 'saturation' else self._brightness_threshold
    # ... 通用逻辑
```
