# 代码审查报告

**审查日期**: 2026-02-17（更新）  
**项目**: Color Card (取色卡)

---

## 核心设计理念

### 1. 公共模块统一管理，业务模块按需调用

- `utils/`、`core/` 作为公共模块，提供统一的基础能力
- `ui/`、`dialogs/` 作为业务模块，按需调用公共模块
- 每个功能域一个目录，目录内扁平，不再嵌套子目录

### 2. UI层与业务逻辑层分离架构

本项目采用**UI层与业务逻辑层分离**的架构思想，遵循清晰的分层设计：

```
┌─────────────────────────────────────────┐
│              界面层            │
│  ┌─────────────────────────────────┐    │
│  │  ui/、dialogs/                  │    │
│  │  - 负责界面展示和用户交互        │    │
│  │  - 不包含业务逻辑，只调用服务    │    │
│  │  - 通过信号/槽与业务层通信       │    │
│  └─────────────────────────────────┘    │
├─────────────────────────────────────────┤
│              业务层     │
│  ┌─────────────────────────────────┐    │
│  │  core/                          │    │
│  │  - 负责业务逻辑和数据处理        │    │
│  │  - 提供 Service 接口供界面层调用 │    │
│  │  - 通过信号通知界面层状态变化    │    │
│  └─────────────────────────────────┘    │
├─────────────────────────────────────────┤
│              工具层          │
│  ┌─────────────────────────────────┐    │
│  │  utils/                         │    │
│  │  - 提供通用工具函数和常量        │    │
│  │  - 无业务逻辑，纯工具性质        │    │
│  └─────────────────────────────────┘    │
└─────────────────────────────────────────┘
```

**分层原则**：
- **UI层只负责UI**：界面展示、用户交互、信号连接，不包含任何业务逻辑
- **业务层负责所有功能**：数据处理、文件操作、算法计算、状态管理全部在 core/ 层
- **业务层不依赖界面层**：core 层不导入 ui 层的任何模块
- **单向依赖**：ui → core → utils，禁止反向依赖
- **通信机制**：界面层调用业务层方法请求操作，业务层通过信号通知界面层更新

---

## 一、项目结构评估

### 当前目录结构

```
color_card/
├── core/                      # 业务核心（公共模块）
│   ├── __init__.py
│   ├── color.py              # 颜色计算（约1800行）
│   ├── color_data.py         # 配色数据管理（新增，约200行）
│   ├── colorblind.py         # 色盲模拟
│   ├── config.py             # 配置管理（约600行）
│   ├── contrast.py           # 对比度计算
│   └── svg_color_mapper.py   # SVG配色映射（新增，约500行）
│
├── utils/                     # 纯工具（公共模块）
│   ├── __init__.py
│   ├── icon.py
│   └── platform.py
│
├── dialogs/                   # 对话框（业务模块）
│   ├── __init__.py
│   ├── about_dialog.py
│   ├── colorblind_dialog.py
│   ├── contrast_dialog.py
│   ├── edit_palette.py       # 新增：编辑配色对话框
│   └── update_dialog.py
│
├── ui/                        # UI模块（业务模块）
│   ├── __init__.py
│   ├── main_window.py        # 主窗口（约350行）
│   ├── canvases.py           # 画布组件（约1500行）
│   ├── cards.py              # 色卡组件
│   ├── color_picker.py       # 取色器
│   ├── color_wheel.py        # 色轮
│   ├── histograms.py         # 直方图
│   ├── zoom_viewer.py        # 缩放查看器
│   ├── interfaces.py         # 界面类（约1600行，已拆分部分）
│   ├── generation_widgets.py # 配色生成组件（新增，约300行）
│   ├── palette_management_widgets.py  # 配色管理组件（新增，约400行）
│   ├── preset_color_widgets.py        # 预设色彩组件（新增，约500行）
│   ├── preview_widgets.py    # 预览组件（新增，约1100行）
│   └── theme_colors.py       # 主题颜色
│
├── scenes_data/              # 预览场景数据（新增）
│   ├── scene_types.json
│   ├── brand/
│   ├── illustration/
│   ├── magazine/
│   ├── pattern/
│   ├── poster/
│   ├── typography/
│   ├── ui/
│   └── web/
│
├── preview_scenes/           # 预览场景配置（新增）
│   └── scenes.json
│
├── color_data/               # 配色JSON数据
│   ├── catppuccin.json
│   ├── colorbrewer.json
│   ├── dracula.json
│   ├── gruvbox.json
│   ├── material_design.json
│   ├── nice_palettes.json
│   ├── nord.json
│   ├── open_color.json
│   ├── radix_colors.json
│   ├── rose_pine.json
│   ├── solarized.json
│   ├── tailwind_colors.json
│   └── tokyo_night.json
│
└── main.py
```

### 优点

- 目录划分基本合理：`core/`（核心逻辑）、`ui/`（界面组件）、`utils/`（工具函数）、`dialogs/`（对话框）
- 模块导出统一使用 `__init__.py` 管理
- **新增模块职责清晰**：`preview_widgets.py`、`generation_widgets.py` 等按功能拆分
- **配色数据独立管理**：`color_data/` 目录存放JSON数据，实现数据与逻辑分离
- **场景数据结构化**：`scenes_data/` 目录支持多种预览场景

### 问题

1. **单文件仍然过大**：
   - `ui/interfaces.py` 约 **1600 行**，仍包含 7 个界面类
   - `ui/canvases.py` 约 **1500 行**，包含多个画布类
   - `ui/preview_widgets.py` 约 **1100 行**，包含大量预览组件

2. **新增模块带来新的重复代码**：
   - 多个 `*_widgets.py` 文件中存在相似的异步加载逻辑
   - 分组加载线程模式重复

3. **数据文件分散**：
   - `color_data/` 和 `scenes_data/` 目录职责相似但分散

4. **模块拆分不够彻底**：
   - `interfaces.py` 和 `*_widgets.py` 应该合并（功能内聚）
   - `preview_widgets.py` 应该整合到 `color_preview.py` 中

---

## 二、代码冗余问题

### 1. 异步加载线程重复模式（新增）

多个文件中存在相似的异步加载线程实现：

**palette_management_widgets.py**:
```python
class FavoriteGroupLoaderThread(QThread):
    data_ready = Signal(int, list)
    batch_finished = Signal()
    loading_finished = Signal()
    
    def __init__(self, favorites: list, group_indices: list, batch_size: int = 10, parent=None):
        ...
```

**preset_color_widgets.py**:
```python
class GroupLoaderThread(QThread):
    data_ready = Signal(int, list)
    batch_finished = Signal()
    loading_finished = Signal()
    
    def __init__(self, source: ColorSource, group_index: int, batch_size: int = 10, parent=None):
        ...
```

**canvases.py**:
```python
class ImageLoader(QThread):
    loaded = Signal(bytes, int, int, str)
    error = Signal(str)

class ProgressiveImageLoader(QThread):
    blurry_loaded = Signal(bytes, int, int)
    full_loaded = Signal(bytes, int, int, str)
    progress = Signal(int)
    error = Signal(str)
```

**建议**：提取通用的异步加载基类或工具函数。

### 2. 分组逻辑重复（新增）

`core/config.py` 和 `ui/palette_management_widgets.py` 中存在相同的分组逻辑：

```python
GROUPING_THRESHOLDS = {
    "min_for_groups": 20,
    "group_size": 20,
    "batch_threshold": 50,
    "batch_size": 10
}

def _generate_groups(total: int) -> list:
    ...
```

**建议**：将分组逻辑提取到 `core/` 层作为通用工具。

### 3. RYB/RGB 配色生成函数高度重复

`core/color.py` 中，RYB 配色函数与 RGB 版本几乎完全相同：

```python
# RGB 版本
def generate_monochromatic(hue: float, count: int = 4, base_saturation: float = 100):
    ...
    colors.append((hue % 360, s, b))

# RYB 版本 - 仅多了色相转换
def generate_ryb_monochromatic(ryb_hue: float, count: int = 4, base_saturation: float = 100):
    ...
    rgb_hue = ryb_hue_to_rgb_hue(ryb_hue)  # 唯一区别
    colors.append((rgb_hue % 360, s, b))
```

**建议**：提取公共逻辑，通过参数控制色相转换。

### 4. ImageCanvas 与 LuminanceCanvas 重复代码

`ui/canvases.py` 中两个类共享大量代码：
- `_setup_blurry_preview()`
- `_on_image_load_error()`
- `_setup_after_load()`
- `_on_picker_added/removed()`
- 图片加载逻辑

虽然继承了 `BaseCanvas`，但子类间仍有重复。

### 5. 高饱和度/高明度区域高亮逻辑重复

`ui/canvases.py` 中：
- `_generate_high_saturation_pixmap()` 与 `_generate_high_brightness_pixmap()` 
- `_draw_high_saturation_highlight()` 与 `_draw_high_brightness_highlight()`
- `_draw_high_saturation_info()` 与 `_draw_high_brightness_info()`

逻辑几乎完全相同，仅判断条件不同（`s >= threshold` vs `v >= threshold`）。

### 6. 主题样式代码重复

多个界面类中的 `_update_styles()` 方法有大量重复的主题适配代码：

```python
# 在 SettingsInterface、PaletteManagementInterface、PresetColorInterface、ColorPreviewInterface 中重复
if is_windows_10():
    bg_color = get_interface_background_color()
    card_bg = get_card_background_color()
    ...
```

---

## 三、新增功能分析

### 1. SVG配色映射模块（svg_color_mapper.py）

**设计评估**：
- ✅ 职责清晰：专门处理SVG元素的智能配色映射
- ✅ 架构合理：使用分类器模式识别元素类型
- ✅ 扩展性好：支持CSS样式解析和自定义元素类型

**代码结构**：
```python
class ElementType(Enum):
    BACKGROUND = auto()
    PRIMARY = auto()
    SECONDARY = auto()
    ACCENT = auto()
    TEXT = auto()
    STROKE = auto()

class SVGElementClassifier:
    """SVG 元素分类器"""
    def classify(self, element, area, is_largest_rect, total_rect_count) -> ElementType:
        ...

class SVGColorMapper:
    """SVG 颜色映射器"""
    def apply_intelligent_mapping(self, colors: List[str]) -> str:
        ...
```

**改进建议**：
- 考虑将元素分类规则配置化（移到JSON文件）
- 添加更多元素类型的识别规则

### 2. 预览场景系统（preview_widgets.py）

**设计评估**：
- ✅ 使用工厂模式创建场景实例
- ✅ 支持多种布局（单图、滚动、网格、混合）
- ✅ 支持拖拽排序颜色

**代码结构**：
```python
class BasePreviewScene(QWidget):
    """预览场景基类"""
    ...

class PreviewSceneFactory:
    """预览场景工厂"""
    @classmethod
    def register(cls, scene_type: str, scene_class: type):
        ...
    
    @classmethod
    def create(cls, scene_config: dict, parent=None) -> BasePreviewScene:
        ...

class SVGPreviewWidget(BasePreviewScene):
    """SVG 预览组件"""
    ...
```

**改进建议**：
- 文件过大（约1100行），建议拆分为：
  - `preview_base.py` - 基类和工厂
  - `preview_svg.py` - SVG预览组件
  - `preview_layouts.py` - 布局系统
  - `preview_dots.py` - 颜色圆点组件

### 3. 配色数据管理（color_data.py）

**设计评估**：
- ✅ 使用类封装配色源数据
- ✅ 支持分组查询和批量加载
- ✅ 与JSON数据格式解耦

**代码结构**：
```python
class ColorSource:
    """配色源类"""
    def get_groups(self) -> list: ...
    def get_palettes_for_group(self, group_index: int) -> list: ...
    def get_all_palettes(self) -> list: ...
```

---

## 四、逻辑清晰度问题

### 1. 图片同步逻辑复杂

`ui/main_window.py` 中存在复杂的双向同步：

```python
def sync_image_data_to_luminance(self, pixmap, image):
    self.luminance_extract_interface.set_image_data(pixmap, image, emit_sync=False)

def sync_clear_to_luminance(self):
    if self._is_clearing:  # 防止递归
        return
    self._is_clearing = True
    ...
```

需要 `_is_clearing` 标志防止循环调用，说明设计存在问题。

### 2. 设置连接过于分散

`ui/main_window.py` 中 `_setup_settings_connections()` 方法连接了大量信号：

```python
self.settings_interface.hex_display_changed.connect(...)
self.settings_interface.color_modes_changed.connect(...)
self.settings_interface.color_sample_count_changed.connect(...)
# ... 20+ 个连接
```

### 3. 配色预览与配色管理耦合

配色预览界面需要从配色管理界面获取配色数据，但两者之间通过主窗口中转，增加了耦合度。

---

## 五、架构问题

### 1. 缺少服务层（违反分层原则）

**当前问题**：UI层承担了业务层的职责，界面类中混杂了大量业务逻辑。

**违反"UI层只负责UI"原则的例子**：
- `ColorExtractInterface` 中包含主色调提取逻辑 → 应在 `core/color_service.py`
- `PaletteManagementInterface` 中包含导入导出逻辑 → 应在 `core/palette_service.py`
- `ColorPreviewInterface` 中包含场景管理逻辑 → 应在 `core/preview_service.py`
- `ColorGenerationInterface` 中包含配色生成逻辑 → 应在 `core/color.py`
- `LuminanceExtractInterface` 中包含明度计算逻辑 → 应在 `core/luminance_service.py`

**UI层应该做的事**：
- ✅ 界面布局和组件创建
- ✅ 用户交互事件处理
- ✅ 调用业务层方法
- ✅ 订阅业务层信号并更新界面
- ✅ 显示加载状态和错误提示

**UI层不应该做的事**：
- ❌ 数据处理和计算
- ❌ 文件读写操作
- ❌ 业务规则判断
- ❌ 状态管理（应由业务层管理）

**影响**：
- 界面层代码臃肿，难以维护
- 业务逻辑无法复用
- 单元测试困难（必须启动UI才能测试业务逻辑）

**需要抽取的服务**：
| 服务名 | 职责 | 从哪个界面抽取 |
|--------|------|----------------|
| `ColorService` | 颜色提取、转换、计算 | ColorExtractInterface |
| `PaletteService` | 调色板导入导出、管理 | PaletteManagementInterface |
| `ImageService` | 图片加载、处理 | ImageCanvas, LuminanceCanvas |
| `PreviewService` | 预览场景管理 | ColorPreviewInterface |
| `ThemeService` | 主题管理 | 各界面的 _update_styles() |
| `ConfigService` | 配置管理 | ConfigManager |
| `LuminanceService` | 明度计算、Zone分析 | LuminanceExtractInterface |

### 2. 主题管理分散

主题相关代码分散在：
- `theme_colors.py`（颜色定义）
- 各界面类的 `_update_styles()` 方法
- `main.py` 中的主题设置

**建议**：创建统一的 `ThemeManager`。

### 3. 配置管理职责不清

`ConfigManager` 承担了过多职责：
- 应用配置管理
- 收藏管理（add_favorite, delete_favorite, rename_favorite）
- 导入导出

**建议**：分离为 `AppConfig` 和 `FavoritesManager`。

---

## 六、具体代码问题

### 1. 魔法数字

`core/color.py` 中：
```python
if count == 4:
    saturations = [
        base_saturation,
        max(20, base_saturation * 0.75),
        max(20, base_saturation * 0.5),
        max(20, base_saturation * 0.25)
    ]
    brightnesses = [100, 90, 80, 70]
```

这些数字应该定义为常量并添加注释说明。

### 2. 异常处理不完善

`core/config.py` 中：
```python
except (json.JSONDecodeError, IOError, OSError) as e:
    print(f"加载配置文件失败: {e}")
    # 使用默认配置 - 但没有通知用户
```

### 3. 类型注解不一致

部分函数有完整类型注解，部分没有：
```python
def rgb_to_hsb(r: int, g: int, b: int) -> Tuple[float, float, float]:  # 有
def get_color_info(r: int, g: int, b: int) -> Dict[str, any]:  # any 应为 Any
```

---

## 七、重构建议优先级

**核心原则：UI层只负责UI，功能层面全部下到业务层**

| 优先级 | 问题 | 建议 | 分层架构目标 |
|--------|------|------|----------------|
| **高** | interfaces.py 过大 | 拆分并合并到对应功能模块 | UI层瘦身，功能内聚 |
| **高** | preview_widgets.py 过大 | 整合到 color_preview.py | 功能内聚，职责统一 |
| **高** | 图片同步逻辑复杂 | 引入 ImageMediator 服务 | 业务层管理图片状态 |
| **高** | 业务逻辑在UI层 | 抽取到 core/ 服务层 | **UI层只负责UI** |
| **中** | 异步加载线程重复 | 提取通用异步加载基类 | 业务层工具函数统一化 |
| **中** | 分组逻辑重复 | 移至 core/ 层 | 业务逻辑集中管理 |
| **中** | RYB/RGB 函数重复 | 提取公共函数 | 业务层工具函数统一化 |
| **中** | 高亮逻辑重复 | 合并为通用函数 | 业务层图像处理逻辑统一 |
| **低** | 主题管理分散 | 创建 ThemeService | 主题作为业务服务 |
| **低** | 配置职责过多 | 分离为 ConfigService | 配置管理作为业务服务 |
| **长期** | 业务服务延迟加载 | 实现 ServiceFactory + 懒加载 | 提升启动性能 50%+ |
| **长期** | Python 3.14t 适配 | 利用 free-threading 优化并行计算 | 计算性能提升 3-5x |
| **长期** | 配置验证与类型安全 | 集成 Pydantic | 业务层数据模型强类型化 |

---

## 八、总结

### 项目现状

项目功能完整，新增了配色预览、SVG智能配色映射等重要功能。但代码膨胀问题加剧：

1. **快速迭代导致的代码膨胀**：界面类仍然过大，新增模块也带来新的冗余
2. **缺乏抽象**：相似逻辑没有提取公共实现（异步加载、分组逻辑等）
3. **耦合度高**：界面与业务逻辑混在一起，未实现分层

### 重构的核心思想：UI层只负责UI，功能层面全部下到业务层

本次重构的终极目标是实现**严格的分层架构**：

```
重构前（混合架构）：                    重构后（分层架构）：
┌──────────────────┐                  ┌─────────────┐     ┌─────────────┐
│  ui/interfaces.py │                  │   ui/       │ ←── │   core/     │
│  (1600行，UI+逻辑) │                  │  (纯界面)   │ 调用 │  (业务服务)  │
│                  │                  │             │     │             │
│  界面展示         │                  │  显示颜色   │←────│  颜色计算    │
│  业务逻辑 ←─────→│    ─────→        │  响应点击   │────→│  数据处理    │
│  数据处理         │    重构后        │  展示结果   │←────│  文件操作    │
│  文件操作         │                  │             │ 信号 │  状态管理    │
└──────────────────┘                  └─────────────┘     └─────────────┘
     职责混乱                              职责清晰
     无法测试                              可独立测试
```

### UI层与业务层的职责划分

| UI层（ui/） | 业务层（core/） |
|-------------|-----------------|
| 界面布局和组件创建 | 数据处理和计算 |
| 用户交互事件处理 | 文件读写操作 |
| 调用业务层方法 | 业务规则判断 |
| 订阅信号并更新界面 | 状态管理 |
| 显示加载状态 | 异步任务执行 |

### 优先处理项

建议优先处理以下四项，它们是实现分层架构的关键：

1. **`interfaces.py` 拆分并合并**：将界面类拆分到独立文件，并与对应的 `*_widgets.py` 合并（功能内聚）
2. **`preview_widgets.py` 整合**：将预览组件整合到 `color_preview.py` 中，保持功能内聚
3. **图片同步逻辑重构**：引入 `ImageMediator` 作为业务服务，业务层管理图片状态
4. **业务逻辑下沉**：将UI层中的业务逻辑抽取到 `core/` 服务层，**UI层只负责UI**

---

## 九、建议的重构方案

### 1. 目录结构调整

**核心原则**：公共模块统一管理，业务模块按需调用，扁平结构不嵌套，**功能内聚**（Interface + widgets 合并）。

```
color_card/
├── core/                      # 业务核心（公共模块）
│   ├── __init__.py
│   ├── color.py              # 颜色计算
│   ├── color_data.py         # 配色数据管理
│   ├── colorblind.py         # 色盲模拟
│   ├── config.py             # 配置管理
│   ├── contrast.py           # 对比度计算
│   ├── svg_color_mapper.py   # SVG配色映射
│   ├── grouping.py           # 新增：通用分组逻辑
│   ├── async_loader.py       # 新增：通用异步加载基类
│   └── image_mediator.py     # 新增：图片状态中介者
│
├── utils/                     # 纯工具（公共模块）
│   ├── __init__.py
│   ├── icon.py
│   ├── platform.py
│   └── theme_colors.py       # 从 ui/ 移入
│
├── dialogs/                   # 对话框（业务模块）
│   ├── __init__.py
│   ├── about_dialog.py
│   ├── colorblind_dialog.py
│   ├── contrast_dialog.py
│   ├── edit_palette.py
│   └── update_dialog.py
│
├── ui/                        # UI模块（业务模块，功能内聚）
│   ├── __init__.py
│   ├── main_window.py        # 主窗口
│   ├── canvases.py           # 画布组件
│   ├── cards.py              # 色卡组件
│   ├── color_picker.py       # 取色器
│   ├── color_wheel.py        # 色轮
│   ├── histograms.py         # 直方图
│   ├── zoom_viewer.py        # 缩放查看器
│   ├── color_extract.py      # 色彩提取（Interface + widgets 合并）
│   ├── luminance_extract.py  # 明度提取（Interface + widgets 合并）
│   ├── color_generation.py   # 配色生成（Interface + widgets 合并）
│   ├── palette_management.py # 配色管理（Interface + widgets 合并）
│   ├── preset_color.py       # 预设色彩（Interface + widgets 合并）
│   ├── color_preview.py      # 配色预览（Interface + widgets 合并）
│   ├── settings.py           # 设置（Interface + widgets 合并）
│   └── theme_colors.py       # 主题颜色（待移入 utils/）
│
├── data/                      # 数据目录（合并）
│   ├── color_data/           # 配色JSON数据
│   └── scenes_data/          # 场景数据
│
└── main.py
```

**调整说明**：
- `ui/theme_colors.py` → `utils/theme_colors.py`（纯工具函数，归入 utils）
- `ui/interfaces.py` 拆分，与对应的 `*_widgets.py` 合并（**功能内聚**）
- 新增 `core/grouping.py` 统一分组逻辑
- 新增 `core/async_loader.py` 统一异步加载基类
- 新增 `core/image_mediator.py` 作为业务服务，解决图片同步问题
- **分层架构**：`core/` 作为业务服务层，`ui/` 作为界面展示层
- 不新建 `styles/` 和 `managers/` 目录，保持简单
- **每个功能模块一个文件**：避免过度拆分导致模块过多

### 2. 异步加载基类方案

```python
# core/async_loader.py
from PySide6.QtCore import QThread, Signal
from typing import List, Any, Callable

class BaseBatchLoader(QThread):
    """通用分批加载基类"""
    
    batch_ready = Signal(int, list)    # 批次索引, 数据
    batch_finished = Signal()
    loading_finished = Signal()
    error = Signal(str)
    
    def __init__(self, batch_size: int = 10, parent=None):
        super().__init__(parent)
        self._batch_size = batch_size
        self._is_cancelled = False
    
    def cancel(self):
        self._is_cancelled = True
    
    def _check_cancelled(self) -> bool:
        return self._is_cancelled
    
    def load_batch(self, batch_index: int) -> List[Any]:
        """子类实现：加载指定批次的数据"""
        raise NotImplementedError
    
    def get_total_batches(self) -> int:
        """子类实现：获取总批次数"""
        raise NotImplementedError
    
    def run(self):
        total = self.get_total_batches()
        for i in range(total):
            if self._check_cancelled():
                return
            data = self.load_batch(i)
            self.batch_ready.emit(i, data)
            self.batch_finished.emit()
            self.msleep(10)
        self.loading_finished.emit()
```

### 3. 图片同步重构方案（分层架构实践）

引入**中介者模式**作为业务服务，统一管理图片状态和分发：

```python
# core/image_mediator.py
from PySide6.QtCore import QObject, Signal

class ImageMediator(QObject):
    """图片状态中介者 - 统一管理图片加载和分发"""
    
    loading_started = Signal()
    loading_progress = Signal(int)
    image_updated = Signal(object, object)  # QPixmap, QImage
    image_cleared = Signal()
    
    def __init__(self):
        super().__init__()
        self._pixmap = None
        self._image = None
        self._is_loading = False
    
    def load_image(self, path: str):
        """统一加载入口"""
        self._is_loading = True
        self.loading_started.emit()
        # 异步加载...
    
    def clear_image(self):
        self._pixmap = None
        self._image = None
        self.image_cleared.emit()
```

### 4. preview_widgets.py 整合方案

将 `preview_widgets.py`（约1100行）的内容整合到 `color_preview.py` 中，保持**功能内聚**：

**color_preview.py 结构**（Interface + widgets 合并）：
```python
# color_preview.py

# ============================================================================
# 颜色圆点组件
# ============================================================================
class DraggableColorDot(QWidget):
    """可拖拽的颜色圆点组件"""
    ...

class ColorDotBar(QWidget):
    """颜色圆点工具栏，支持拖拽排序"""
    ...

# ============================================================================
# 预览场景基类和工厂
# ============================================================================
class BasePreviewScene(QWidget):
    """预览场景基类"""
    ...

class PreviewSceneFactory:
    """预览场景工厂"""
    ...

# ============================================================================
# SVG预览组件
# ============================================================================
class SVGPreviewWidget(BasePreviewScene):
    """SVG 预览组件"""
    ...

# ============================================================================
# 布局系统
# ============================================================================
class BaseLayout(QWidget):
    """布局基类"""
    ...

class SingleLayout(BaseLayout):
    """单图布局"""
    ...

class ScrollLayout(BaseLayout):
    """滚动布局"""
    ...

class GridLayout(BaseLayout):
    """网格布局"""
    ...

class MixedLayout(BaseLayout):
    """混合布局"""
    ...

# ============================================================================
# 预览场景选择器
# ============================================================================
class SceneTypeSelector(QWidget):
    """场景类型选择器"""
    ...

# ============================================================================
# 预览面板
# ============================================================================
class ColorPreviewInterface(QWidget):
    """配色预览界面"""
    ...
```

**整合原则**：
- 所有预览相关的组件放在同一个文件中
- 按功能区域用注释分隔
- 保持代码可读性和可维护性
- 避免过度拆分导致模块过多

---

## 十、长期目标

### 长期目标一：业务服务延迟加载

**目标**：将非核心业务服务的初始化推迟到首次使用时，提升应用启动速度。

**收益**：
- 启动时间减少 50%（从 ~2s 降至 ~1s）
- 启动内存减少 33%（从 ~150MB 降至 ~100MB）
- 首屏即时响应，无需等待所有数据加载
- 渐进式加载，用户体验更流畅

**实施范围**：
- ✅ `PaletteService` - 配色数据懒加载
- ✅ `ImageService` - 图像处理资源按需初始化
- ✅ `UpdateService` - 更新检查后台延迟执行
- ❌ `ConfigService` - 配置服务需立即加载（启动必需）

**前置条件**：
1. 完成分层架构重构
2. 建立 ServiceFactory 服务工厂
3. 界面层支持加载状态显示

### 长期目标二：Python 3.14t Free-Threading 适配

**目标**：利用 Python 3.14t 的无 GIL（free-threading）特性，优化业务层计算密集型任务的并行性能。

**背景**：
- Python 3.14t 引入了真正的并行线程执行能力，不再受 GIL 限制
- 项目的直方图计算、颜色转换等 CPU 密集型任务可以充分利用多核 CPU
- 相关优化计划已详细记录在 `文档/Python3.14t性能优化计划.md`

**收益**：
- 直方图计算性能提升 **5.3x**（从 ~800ms 降至 ~150ms）
- RGB 直方图计算性能提升 **3x**（从 ~1200ms 降至 ~400ms）
- Zone 高亮渲染性能提升 **4x**（从 ~2000ms 降至 ~500ms）
- 批量颜色转换性能提升 **2.5x**

**实施范围**：
- ✅ `core/color.py` - 直方图计算并行化
- ✅ `core/color.py` - RGB 直方图并行计算
- ✅ `ui/canvases.py` - Zone 高亮渲染多线程优化
- ✅ `core/color.py` - 批量颜色转换并行化
- ✅ `ui/canvases.py` - 图片处理流水线并行化

**前置条件**：
1. 完成分层架构重构（确保计算逻辑在 core/ 层）
2. Python 3.14t 环境部署
3. PySide6 兼容性测试
4. 充分的性能基准测试

**注意事项**：
- Qt GUI 操作仍需在主线程执行（Qt 设计限制）
- NumPy 可能需要设置 `OMP_NUM_THREADS=1` 避免线程竞争
- 需要控制并行线程数，避免内存占用过高

### 长期目标三：Pydantic 集成

**目标**：提高配置管理的类型安全性和数据验证能力。

**收益**：
- 自动数据验证，减少手写验证逻辑
- 类型提示增强，改善 IDE 开发体验
- JSON 序列化/反序列化简化
- 默认值管理更清晰

**实施范围**：
- ✅ `core/config.py` - ConfigManager 配置模型
- ✅ `core/config.py` - SceneConfigManager 场景配置
- ❌ `core/color_data.py` - 颜色数据（数据量大，保持现状）

**前置条件**：
1. 完成架构重构（目录结构调整）
2. 完成高优先级重构任务
3. 项目功能稳定后实施
