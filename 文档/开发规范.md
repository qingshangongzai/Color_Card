# Color Card 开发规范

## 1. 概述

### 1.1 项目简介

Color Card（取色卡）是一个基于 PySide6 开发的图片颜色分析工具，用于从图片中提取颜色信息和分析明度分布，支持多种色彩模式显示。

**核心功能：**

- 图片导入（JPG、PNG、BMP、GIF）
- 色彩提取：5个可拖动取色点，实时显示色彩值
- 多色彩模式：HSB、LAB、HSL、CMYK、RGB
- 明度提取与直方图可视化
- 双面板数据同步

### 1.2 开发环境

- **操作系统**：Windows 10/11
- **Python 版本**：3.11+
- **GUI 框架**：PySide6 + PySide6-Fluent-Widgets
- **推荐 IDE**：VS Code、PyCharm、Trae

### 1.3 项目结构

```
color_card/
├── main.py                 # 程序入口
├── version.py              # 版本管理模块
├── requirements.txt        # 项目依赖
├── README.md               # 项目文档
├── LICENSE                 # 开源许可证
├── 开发规范.md              # 本文件
├── core/                   # 核心功能模块目录
│   ├── __init__.py
│   ├── async_loader.py    # 异步加载基类模块（BaseBatchLoader）
│   ├── color.py           # 颜色处理模块（颜色转换、明度计算、配色生成算法）
│   ├── colorblind.py      # 色盲模拟模块（色盲类型定义、LMS色彩空间转换、色盲模拟算法）
│   ├── color_data.py      # 颜色数据管理模块（延迟加载各颜色库数据）
│   ├── config.py          # 配置管理模块（收藏管理、场景配置管理、场景类型管理）
│   ├── contrast.py        # 对比度检查模块（WCAG对比度计算、等级判断）
│   ├── grouping.py        # 通用分组逻辑模块（GROUPING_THRESHOLDS、generate_groups、should_use_batch_loading）
│   ├── image_mediator.py  # 图片状态中介者模块（统一管理图片状态，实现面板间解耦同步）
│   └── svg_color_mapper.py # SVG智能配色映射模块（SVG解析、元素分类、智能配色映射）
├── scenes_data/           # 场景数据目录（内置SVG模板和布局配置）
│   ├── scene_types.json   # 场景类型定义
│   ├── ui/                # 手机UI场景
│   ├── web/               # 网页场景
│   ├── illustration/      # 插画场景
│   ├── typography/        # 排版场景
│   ├── brand/             # 品牌场景
│   ├── poster/            # 海报场景
│   ├── pattern/           # 图案场景
│   └── magazine/          # 杂志场景
├── ui/                     # UI模块目录（扁平化结构）
│   ├── __init__.py        # 统一导出接口
│   ├── main_window.py     # 主窗口类
│   ├── canvases.py        # 画布模块（BaseCanvas、ImageCanvas、LuminanceCanvas、ProgressiveImageLoader）
│   ├── cards.py           # 卡片组件模块（ColorCard、LuminanceCard及基类）
│   ├── histograms.py      # 直方图组件模块
│   ├── color_picker.py    # 颜色选择器模块
│   ├── color_wheel.py     # 颜色轮模块（HSBColorWheel、InteractiveColorWheel）
│   ├── color_extract.py   # 色彩提取界面模块（ColorExtractInterface、DominantColorExtractor）
│   ├── color_generation.py # 配色生成模块（GenerationColorInfoCard、GenerationColorPanel、ColorGenerationInterface）
│   ├── luminance_extract.py # 明度提取界面模块（LuminanceExtractInterface）
│   ├── palette_management.py # 配色管理模块（PaletteManagementColorCard、PaletteManagementCard、PaletteManagementList、PaletteManagementInterface）
│   ├── preset_color.py    # 内置色彩模块（PresetColorCard、PaletteCard、PresetColorList、PresetColorInterface）
│   ├── color_preview.py   # 配色预览模块（ColorPreviewInterface、DraggableColorDot、ColorDotBar、BasePreviewScene、PreviewSceneFactory、SVGPreviewWidget、PreviewSceneSelector、PreviewToolbar、MixedPreviewPanel、布局系统：BaseLayout、SingleLayout、ScrollVLayout、ScrollHLayout、GridLayout、MixedLayout、LayoutFactory）
│   ├── zoom_viewer.py     # 缩放查看器模块
│   ├── settings.py        # 设置界面模块（SettingsInterface）
│   └── theme_colors.py    # 主题颜色管理模块（统一颜色管理、主题感知颜色获取）
├── dialogs/               # 对话框模块目录
│   ├── __init__.py
│   ├── about_dialog.py    # 关于对话框
│   ├── colorblind_dialog.py # 色盲模拟预览对话框
│   ├── contrast_dialog.py # 对比度检查对话框
│   ├── edit_palette.py    # 编辑配色对话框（添加/编辑配色）
│   └── update_dialog.py   # 更新检查对话框
├── utils/                 # 工具函数模块目录
│   ├── __init__.py
│   ├── icon.py            # 图标工具模块
│   ├── layout.py          # 布局工具模块（calculate_grid_columns）
│   └── platform.py        # 平台相关工具模块
└── color_data/            # 颜色数据目录（JSON格式）
    ├── open_color.json    # Open Color 颜色库
    ├── tailwind_colors.json # Tailwind CSS 颜色库
    ├── material_design.json # Material Design 颜色库
    ├── nord.json          # Nord 颜色库
    ├── dracula.json       # Dracula 颜色库
    ├── colorbrewer.json   # ColorBrewer 颜色库
    ├── radix_colors.json  # Radix Colors 颜色库
    ├── nice_palettes.json # Nice Color Palettes 配色方案
    ├── rose_pine.json     # Rosé Pine 颜色库
    ├── solarized.json     # Solarized 颜色库
    ├── catppuccin.json    # Catppuccin 颜色库
    ├── gruvbox.json       # Gruvbox 颜色库
    └── tokyo_night.json   # Tokyo Night 颜色库
```

---

## 2. 代码组织规范

### 2.1 文件命名规范

- 采用小写字母和下划线命名，如 `color_utils.py`
- 核心功能模块使用清晰的描述性名称
- 合并后的模块使用复数形式命名，如 `cards.py`、`histograms.py`、`canvases.py`

### 2.2 模块划分

|模块类型 |职责 |示例文件 |
|:---:|:---:|:---:|
|入口模块 |应用程序入口 |`main.py` |
|核心模块 |颜色处理、配置管理 |`core/color.py`, `core/config.py` |
|UI 模块 |界面组件和面板 |`ui/canvases.py`, `ui/cards.py` |
|对话框模块 |弹出对话框 |`dialogs/about_dialog.py` |
|工具模块 |通用功能 |`utils/icon.py`, `utils/platform.py` |

### 2.3 目录结构原则

**扁平化结构（2级目录）：**

```
color_card/           ← 第1级
├── core/            ← 第2级
├── ui/              ← 第2级（扁平化，直接包含所有UI文件）
├── dialogs/         ← 第2级
└── utils/           ← 第2级
```

**设计原则：**

- 避免过度嵌套（不超过2级目录）
- 将紧密相关的类合并到同一文件，减少文件数量，提高内聚性
- 保持功能模块化，职责明确

**核心理念：UI层和业务层分层，公共模块统一管理，业务模块按需调用；UI层只负责UI，功能层面全部下到业务层**

### 2.4 导入规范

**导入顺序：** 标准库 → 第三方库 → 项目模块

**规范要求：**

- 按模块类型分组导入，添加清晰的分组注释
- 定期清理未使用的导入
- 合并同一模块的多次导入
- 优先使用绝对导入

```python
# 标准库导入
import sys
import math
from pathlib import Path

# 第三方库导入
from PySide6.QtWidgets import QApplication, QMainWindow
from PySide6.QtCore import Qt, Signal
from qfluentwidgets import FluentWindow

# 项目模块导入
from core import get_color_info, get_config_manager
from ui import MainWindow
```

**导入清理示例：**

```python
# 修改前
from styles import UnifiedStyleHelper
from styles import get_global_font_manager

# 修改后
from styles import UnifiedStyleHelper, get_global_font_manager
```


---

## 3. 代码编写规范

### 3.1 基本规范

- 遵循 **PEP 8** 代码风格规范
- 使用 4 个空格缩进
- 行长度限制在 100 字符以内
- 保持代码简洁，删除无用的调试代码和临时测试代码

### 3.2 代码清理原则

**修改代码时应同步进行以下清理：**

- 删除未使用的变量、函数、导入和注释
- 合并重复的逻辑和相似的功能
- 检查并清除相关的重复冗余代码
- 保持代码整洁，提高代码复用性

**清理示例：**

```python
# 修改前
import json
import re

def calculate():
    temp = 0  # 未使用的变量
    return result

# 修改后（删除未使用的导入和变量）
def calculate():
    return result
```

### 3.3 命名规范

**详细规范请参阅** 

|类型 |规范 |示例 |
|:---:|:---:|:---:|
|类名 |驼峰命名法 |`ColorPicker`, `ImageCanvas` |
|函数/方法 |小写+下划线 |`extract_color()` |
|变量 |小写+下划线 |`picker_positions` |
|常量 |大写+下划线 |`PICKER_RADIUS = 12` |
|私有属性 |单下划线前缀 |`_dragging` |
|信号 |小写+下划线 |`color_picked = Signal(int, tuple)` |

### 3.4 异常处理规范

**基本原则：**

- 避免使用裸 `except:` 或 `except Exception:`
- 应指定具体异常类型
- 提供详细的错误信息，便于调试

**示例：**

```python
# 错误示例
except Exception:
    pass

# 正确示例
except (OSError, ValueError) as e:
    error_msg = f"文件读取失败: {str(e)}"
    print(error_msg)
```

### 3.5 文档字符串规范

**基本原则：**

- 所有公共类和方法必须添加文档字符串
- 使用简洁的中文描述，避免冗余
- 类文档字符串保持简洁（单行或简短段落）
- 方法文档字符串包含 Args、Returns 说明

**精简示例：**

```python
# 类文档字符串（简洁）
class ImageCanvas(QWidget):
    """图片显示画布，支持取色点拖动"""
    pass

# 方法文档字符串（完整但简洁）
def set_image(self, image_path):
    """加载并显示图片
    
    Args:
        image_path: 图片文件的完整路径
    """
    pass

# 带返回值的文档字符串
def get_color_info(self, r, g, b):
    """获取颜色信息
    
    Args:
        r: 红色通道值 (0-255)
        g: 绿色通道值 (0-255)
        b: 蓝色通道值 (0-255)
    
    Returns:
        dict: 包含RGB、HSB、LAB、HEX颜色信息的字典
    """
    pass
```

### 3.6 信号命名规范

- 信号名使用小写+下划线
- 添加注释说明信号参数

```python
class ImageCanvas(QWidget):
    color_picked = Signal(int, tuple)      # 信号：索引, RGB颜色
    image_loaded = Signal(str)              # 信号：图片路径
    image_cleared = Signal()                # 信号：图片已清空
```

### 3.7 主题与样式规范

#### 3.7.1 主题切换实现规范

**使用 qfluentwidgets 的主题系统：**

- 使用 `setTheme(Theme.LIGHT/DARK)` 切换主题
- 使用 `isDarkTheme()` 检测当前主题
- 使用 `qconfig.themeChangedFinished` 信号监听主题变化

**示例代码：**

```python
from qfluentwidgets import setTheme, Theme, isDarkTheme, qconfig

# 切换主题
def toggle_theme():
    if isDarkTheme():
        setTheme(Theme.LIGHT)
    else:
        setTheme(Theme.DARK)

# 监听主题变化
qconfig.themeChangedFinished.connect(self._update_styles)
```

#### 3.7.2 颜色管理规范

**集中管理颜色值：**

- 所有颜色值应定义在 `theme_colors.py` 中
- 使用函数返回 QColor，支持主题感知
- 避免在组件中硬编码颜色值

**颜色函数命名规范：**

```python
# 背景颜色

def get_card_background_color():
    return QColor(42, 42, 42) if isDarkTheme() else QColor(255, 255, 255)

# 文本颜色

def get_text_color(secondary=False):
    if isDarkTheme():
        return QColor(160, 160, 160) if secondary else QColor(255, 255, 255)
    else:
        return QColor(120, 120, 120) if secondary else QColor(40, 40, 40)
```

#### 3.7.3 主题自适应组件实现

**必须实现** `_update_styles()` 方法：

- 在 `__init__` 中调用 `_update_styles()` 初始化样式
- 连接 `qconfig.themeChangedFinished` 信号
- 根据 `isDarkTheme()` 返回不同颜色值

**示例：**

```python
class MyWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
        self._update_styles()
        qconfig.themeChangedFinished.connect(self._update_styles)

    def _update_styles(self):
        """更新样式以适配主题"""
        if isDarkTheme():
            label_color = "#ffffff"
            value_color = "#ffffff"
        else:
            label_color = "#333333"
            value_color = "#333333"

        self.label.setStyleSheet(f"color: {label_color};")
```

#### 3.7.4 样式表使用规范

**避免使用** `!important`：

- 优先使用组件特定的选择器
- 如必须使用，确保在主题切换后重新应用

**自定义标题栏按钮样式：**

```python
# 在主题切换后重新应用样式

def _toggle_theme(self):
    if isDarkTheme():
        setTheme(Theme.LIGHT)
    else:
        setTheme(Theme.DARK)
    # 重新应用自定义样式
    self._apply_custom_style()
```

#### 3.7.5 Windows 原生标题栏深色模式

**使用 Windows DWM API 设置原生标题栏主题：**

对于继承自 `QDialog` 的对话框，使用 Windows DWM (Desktop Window Manager) API 设置原生标题栏的沉浸式深色模式。

**实现步骤：**


1. **创建工具函数**（放在 `utils/platform.py`）：

```python
import ctypes
import sys

DWMWA_USE_IMMERSIVE_DARK_MODE = 20

def set_window_title_bar_theme(window, is_dark=False):
    """为窗口设置标题栏主题（Windows 10+）"""
    try:
        if sys.platform != "win32":
            return False
        
        window_handle = window.windowHandle()
        if not window_handle:
            return False
        
        hwnd = int(window_handle.winId())
        value = ctypes.c_int(1 if is_dark else 0)
        
        result = ctypes.windll.dwmapi.DwmSetWindowAttribute(
            hwnd,
            DWMWA_USE_IMMERSIVE_DARK_MODE,
            ctypes.byref(value),
            ctypes.sizeof(value)
        )
        return result == 0
    except Exception:
        return False
```


2. **在对话框中应用**（使用 `showEvent` 避免闪烁）：

```python
from qfluentwidgets import isDarkTheme, qconfig
from utils import set_window_title_bar_theme

class MyDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        # ... 其他初始化代码 ...
        
        # 监听主题变化（用于更新已打开的对话框）
        qconfig.themeChangedFinished.connect(self._update_title_bar_theme)
    
    def showEvent(self, event):
        """窗口显示前设置标题栏主题，避免闪烁"""
        self._update_title_bar_theme()
        super().showEvent(event)
    
    def _update_title_bar_theme(self):
        """更新标题栏主题"""
        set_window_title_bar_theme(self, isDarkTheme())
```

**关键要点：**

- 使用 `showEvent` 在窗口显示前设置标题栏主题，避免闪烁
- 连接 `qconfig.themeChangedFinished` 信号，支持已打开对话框的主题切换
- 仅支持 Windows 10 版本 2004 (Build 19041) 及以上，Windows 11 完全支持
- 非 Windows 平台静默跳过，不影响程序运行


---

## 4. 基类设计规范

### 4.1 画布基类 (BaseCanvas)

**文件位置：** `ui/canvases.py`

**职责：**

- 提供图片加载、显示的基础功能
- 实现坐标转换（画布坐标 ↔ 图片坐标）
- 管理图片相对坐标系统
- 提供右键菜单框架

**子类必须实现的方法：**

```python
def _on_image_loaded(self):
    """图片加载后的处理（子类重写）"""
    pass

def _on_image_cleared(self):
    """图片清空后的处理（子类重写）"""
    pass

def _draw_overlay(self, painter: QPainter):
    """绘制叠加内容（子类必须实现）"""
    raise NotImplementedError("子类必须实现 _draw_overlay 方法")
```

### 4.2 卡片基类 (BaseCard / BaseCardPanel)

**文件位置：** `ui/cards.py`

**职责：**

- 提供统一的卡片接口
- 管理卡片列表（BaseCardPanel）
- 支持批量清空卡片

**设计原则：**

- 保持接口简洁（setup_ui, clear）
- 灵活的卡片创建方法
- 清晰的职责分离

### 4.3 直方图基类 (BaseHistogram)

**文件位置：** `ui/histograms.py`

**职责：**

- 提供通用的数据管理（set_data, clear）
- 提供通用的绘制框架（paintEvent）
- 定义抽象方法接口

**子类必须实现的方法：**

```python
def _draw_histogram(self, painter: QPainter):
    """绘制直方图（子类必须实现）"""
    raise NotImplementedError("子类必须实现 _draw_histogram 方法")

def _draw_custom_overlay(self, painter: QPainter):
    """绘制自定义叠加内容（子类重写）"""
    pass

def _draw_labels(self, painter: QPainter):
    """绘制标签（子类重写）"""
    pass
```

### 4.4 基类设计原则


1. **单一职责**：每个基类只负责一类功能
2. **接口清晰**：抽象方法明确，子类职责清晰
3. **可扩展性**：便于添加新的子类实现
4. **代码复用**：提取公共逻辑，消除重复代码


---

## 5. PySide6 开发规范

### 5.1 Fluent Widgets 使用规范

- 主窗口继承 `FluentWindow`
- 使用 `setTheme()` 设置主题
- 使用 `setThemeColor()` 设置主题色

```python
from qfluentwidgets import FluentWindow, setTheme, Theme, FluentIcon

setTheme(Theme.AUTO)
setThemeColor('#0078d4')

class MainWindow(FluentWindow):
    def setup_navigation(self):
        self.addSubInterface(
            self.interface,
            FluentIcon.PALETTE,
            "界面名称"
        )
```

### 5.2 界面组织规范

- 每个功能模块创建独立的 `QWidget` 子类
- 界面类使用 `setObjectName()` 设置唯一标识

```python
class ColorExtractInterface(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName('colorExtractInterface')
        self.setup_ui()
        self.setup_connections()
```

### 5.3 信号与槽

- 信号连接应在初始化时完成
- 槽函数命名使用 `on_` 前缀
- **防止双向同步循环**：当两个面板需要相互同步数据时，使用标志位或参数控制信号发射，避免无限循环

```python
# 信号连接
self.image_canvas.color_picked.connect(self.on_color_picked)

# 槽函数实现
def on_color_picked(self, index, rgb):
    """颜色提取回调"""
    pass

# 防止双向同步循环的示例
def set_image_data(self, pixmap, image, emit_sync=True):
    """设置图片数据
    
    Args:
        pixmap: QPixmap 对象
        image: QImage 对象
        emit_sync: 是否发射同步信号（默认True，从其他面板同步时设为False）
    """
    self._original_pixmap = pixmap
    self._image = image
    
    # 只在独立导入时发射同步信号，防止双向循环
    if emit_sync:
        self.image_loaded.emit(file_path)
        self.image_data_loaded.emit(pixmap, image)

# 从其他面板同步时禁用信号发射
# 面板A导入图片 → 同步到面板B（emit_sync=False）
# 面板B不会发射信号回到面板A，打破循环
```

### 5.3.1 图片状态中介者（ImageMediator）

使用 `ImageMediator` 统一管理图片状态，实现面板间的解耦同步：

```python
from core import ImageMediator

# 创建中介者实例
self._image_mediator = ImageMediator(self)

# 连接信号
self._image_mediator.image_updated.connect(self._on_image_updated)
self._image_mediator.image_cleared.connect(self._on_image_cleared)

# 设置图片（带来源标识，防止循环）
self._image_mediator.set_image(pixmap, image, 'color')

# 清空图片
self._image_mediator.clear_image('color')
```

**清空同步规范：**

界面类应提供 `clear_all(emit_signal=True)` 方法统一处理所有清空操作：

```python
def clear_all(self, emit_signal: bool = True):
    """清空所有相关内容
    
    Args:
        emit_signal: 是否发射清空信号（默认True，从其他面板同步时设为False）
    """
    self.image_canvas.clear_image(emit_signal)
    self.color_card_panel.clear_all()
    self.hsb_color_wheel.clear_sample_points()
    self.rgb_histogram_widget.clear()
    self.hue_histogram_widget.clear()

def clear_image(self):
    """清空图片（供外部调用，会发射信号同步到其他面板）"""
    self.clear_all(emit_signal=True)
```

**要点：**
- 使用 `clear_all()` 统一处理所有组件的清理，避免遗漏
- 通过 `emit_signal` 参数控制是否触发同步，防止循环
- 从其他面板同步清空时，使用 `clear_all(emit_signal=False)`

### 5.4 自定义控件规范

- 继承自合适的 QWidget 子类
- 重写 `paintEvent` 实现自定义绘制

```python
class ColorPicker(QWidget):
    """可拖动的圆形取色点"""
    
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        # 绘制代码...
```

### 5.5 样式设置规范

#### 5.5.1 颜色管理规范

**核心原则：禁止在组件中直接使用硬编码颜色值**

所有颜色必须通过 `ui/theme_colors.py` 模块统一管理：

```python
# 正确用法 - 从主题颜色模块导入
from ui.theme_colors import get_text_color, get_canvas_background_color

# 获取主题感知的文本颜色
text_color = get_text_color()

# 获取固定颜色（如图片显示器背景）
bg_color = get_canvas_background_color()  # 固定灰黑色 #2a2a2a
```

**禁止的做法：**

```python
# 错误 - 硬编码颜色值
painter.setPen(QColor(255, 255, 255))
widget.setStyleSheet("background-color: #2a2a2a;")
```

#### 5.5.2 主题颜色模块 (ui/theme_colors.py)

**设计原则：**

- **集中管理**：所有颜色值集中在 theme_colors.py 中定义
- **主题感知**：颜色函数根据当前主题（深色/浅色）自动返回对应颜色
- **分类清晰**：按用途分类（背景色、文本色、边框色、控件颜色等）

**颜色分类：**

|分类 |函数示例 |说明 |
|:---:|:---|:---|
|背景色 |`get_canvas_background_color()` |图片显示器背景（固定 #2a2a2a） |
|背景色 |`get_card_background_color()` |卡片背景（主题感知） |
|背景色 |`get_histogram_background_color()` |直方图背景（固定 #2a2a2a） |
|文本色 |`get_text_color()` |主文本颜色（主题感知） |
|文本色 |`get_secondary_text_color()` |次要文本颜色（主题感知） |
|文本色 |`get_title_color()` |标题颜色（主题感知） |
|边框色 |`get_border_color()` |边框颜色（主题感知） |
|控件色 |`get_picker_border_color()` |取色点边框颜色 |
|控件色 |`get_picker_fill_color()` |取色点填充颜色 |
|Zone色 |`get_zone_background_color()` |Zone框背景颜色 |
|Zone色 |`get_zone_text_color()` |Zone框文字颜色 |

**添加新颜色的步骤：**


1. 在 `ui/theme_colors.py` 中添加颜色函数
2. 根据用途选择合适的分类
3. 确定是固定颜色还是主题感知颜色
4. 在相关组件中使用新函数

#### 5.5.3 主题设置

- 使用 `setTheme()` 设置全局主题
- 使用 `isDarkTheme()` 检测当前主题
- 使用 `setThemeColor()` 设置主题色

```python
from qfluentwidgets import FluentWindow, setTheme, Theme, FluentIcon, setThemeColor

setTheme(Theme.AUTO)
setThemeColor('#0078d4')

class MainWindow(FluentWindow):
    pass
```

#### 5.5.4 禁用Qt原生功能规范

**核心原则：新组件应禁用不符合项目需求的Qt原生功能**

Qt控件默认提供的某些功能可能与项目设计不符，应在创建组件时主动禁用。

**需要禁用的常见原生功能：**

|功能 |禁用方法 |适用场景 |
|:---:|:---|:---|
|右键上下文菜单 |`setContextMenuPolicy(Qt.ContextMenuPolicy.NoContextMenu)` |输入框、标签等不需要原生编辑菜单的控件 |
|原生工具提示 |不调用 `setToolTip()` 或设置为空字符串 |使用自定义提示或不需要提示的按钮 |
|焦点虚线框 |`setFocusPolicy(Qt.FocusPolicy.NoFocus)` 或样式表 |不需要键盘焦点的装饰性控件 |

**示例 - 禁用输入框右键菜单：**

```python
from PySide6.QtWidgets import QLineEdit
from PySide6.QtCore import Qt

# 创建输入框并禁用原生右键菜单
self.hex_input = QLineEdit()
self.hex_input.setContextMenuPolicy(Qt.ContextMenuPolicy.NoContextMenu)
```

**注意事项：**

- 仅在确实不需要原生功能时禁用
- 如果需要自定义右键菜单，应使用 `RoundMenu` 替代
- 禁用工具提示时，确保用户通过其他方式了解按钮功能

### 5.6 右键菜单规范

- 使用 `RoundMenu` 创建 Fluent 风格的右键菜单
- 使用 `Action` 创建菜单项

```python
from qfluentwidgets import RoundMenu, Action, FluentIcon

def contextMenuEvent(self, event):
    menu = RoundMenu("")
    change_action = Action(FluentIcon.PHOTO, "更换图片")
    menu.addAction(change_action)
    menu.exec(event.globalPos())
```


---

## 6. 颜色处理规范

### 6.1 颜色空间转换

- 所有颜色转换函数放在 `core/color.py`
- 返回结果包含完整的颜色信息

```python
def get_color_info(r, g, b):
    """获取颜色的完整信息"""
    return {
        'rgb': (r, g, b),
        'hsb': (h, s, v),
        'lab': (l, a, b),
        'hex': rgb_to_hex(r, g, b)
    }
```

### 6.2 明度计算规范

使用 Rec. 709 标准计算亮度值，包含 sRGB Gamma 校正。

```python
def get_luminance(r: int, g: int, b: int) -> int:
    """计算像素的明度值 (0-255)
    
    使用 Rec. 709 标准计算亮度值，包含 sRGB Gamma 校正
    这是 Lightroom、Photoshop 等专业软件使用的标准方法
    """
    # 步骤1: 归一化到 0-1 范围
    r_norm, g_norm, b_norm = r / 255.0, g / 255.0, b / 255.0

    # 步骤2: sRGB Gamma 解码（转换到线性空间）
    def srgb_to_linear(c):
        if c <= 0.04045:
            return c / 12.92
        else:
            return ((c + 0.055) / 1.055) ** 2.4

    r_linear = srgb_to_linear(r_norm)
    g_linear = srgb_to_linear(g_norm)
    b_linear = srgb_to_linear(b_norm)

    # 步骤3: 在线性空间应用 Rec. 709 权重
    luminance_linear = 0.2126 * r_linear + 0.7152 * g_linear + 0.0722 * b_linear

    # 步骤4-5: 编码回 sRGB 空间并转换到 0-255
    # ...
```

### 6.3 Zone 分区规范

采用 Adobe 官方标准的 5 个明度区域：

|区域 |明度范围 |英文名 |描述 |
|:---:|:---:|:---:|:---|
|黑色 |0%–10% |Blacks |黑点区域，最暗的部分 |
|阴影 |10%–30% |Shadows |阴影区域，较暗的色调 |
|中间调 |30%–70% |Midtones |中间亮度区域，由 Exposure/Contrast 负责调整 |
|高光 |70%–90% |Highlights |高光区域，较亮的色调 |
|白色 |90%–100% |Whites |白点区域，最亮的部分 |

**技术映射（0-255 值到 Adobe 区域）：**

|Zone |明度范围 |Adobe 区域 |
|:---:|:---:|:---:|
|Zone 0 |0-25 |黑色(Blacks) |
|Zone 1 |26-51 |黑色(Blacks) |
|Zone 2 |52-76 |阴影(Shadows) |
|Zone 3 |77-102 |中间调(Midtones) |
|Zone 4 |103-128 |中间调(Midtones) |
|Zone 5 |129-153 |中间调(Midtones) |
|Zone 6 |154-179 |中间调(Midtones) |
|Zone 7 |180-204 |高光(Highlights) |
|Zone 8 |205-255 |白色(Whites) |


---

## 7. 图片处理规范

### 7.1 图片加载规范

- 保留原始高分辨率图片
- 使用 `QPixmap` 用于显示，`QImage` 用于像素读取
- 使用多线程异步加载大图片

### 7.2 坐标映射规范

**核心原则：** 采样点位置使用**图片相对坐标**（归一化坐标 0.0-1.0）存储。

|坐标类型 |说明 |范围 |
|:---:|:---|:---:|
|相对坐标 |相对于图片的归一化坐标 |0.0-1.0 |
|画布坐标 |相对于画布控件的像素坐标 |像素值 |

```python
# 相对坐标 → 画布坐标
canvas_x = disp_x + rel_x * disp_w

# 画布坐标 → 相对坐标
rel_x = (canvas_x - disp_x) / disp_w
```

### 7.3 性能优化规范

**基本策略：**

- 使用 `QThread` 在子线程读取图片文件
- 使用 `QTimer.singleShot()` 延迟执行耗时操作
- 直方图计算使用采样优化

**QThread 取消机制：**

- 使用标志位机制实现线程取消，避免使用 `wait()` 阻塞UI线程
- 在 `run()` 方法的关键检查点检查取消标志
- 不等待旧线程结束，立即启动新线程

```python
class ImageLoader(QThread):
    """图片加载线程（支持取消）"""
    
    def __init__(self, image_path: str) -> None:
        super().__init__()
        self._image_path = image_path
        self._is_cancelled = False  # 取消标志
    
    def cancel(self) -> None:
        """请求取消加载（线程安全）"""
        self._is_cancelled = True
    
    def _check_cancelled(self) -> bool:
        """检查是否被取消"""
        return self._is_cancelled
    
    def run(self) -> None:
        """在子线程中加载图片"""
        try:
            with Image.open(self._image_path) as pil_image:
                # 关键检查点1
                if self._check_cancelled():
                    return
                
                # 耗时操作前检查
                if self._check_cancelled():
                    return
                
                # 执行耗时操作...
                
                # 关键检查点2
                if self._check_cancelled():
                    return
                    
        except Exception as e:
            if not self._check_cancelled():
                self.error.emit(str(e))

# 使用示例（非阻塞切换）
def set_image(self, image_path: str) -> None:
    # 取消旧线程（非阻塞）
    if self._loader is not None:
        self._loader.cancel()
        # 注意：不调用 wait()，避免阻塞UI线程
        self._loader = None
    
    # 立即启动新线程
    self._loader = ImageLoader(image_path)
    self._loader.start()
```

**UI性能优化：**

- 批量更新UI时使用 `setUpdatesEnabled(False/True)` 包裹更新操作
- 避免在循环中频繁更新UI，先收集数据再批量更新
- 使用 `try-finally` 确保 `setUpdatesEnabled(True)` 一定会执行

```python
# 批量更新UI示例
def update_table_data(self):
    self.table.setUpdatesEnabled(False)
    try:
        for row in range(self.table.rowCount()):
            self.table.setItem(row, 0, item)
    finally:
        self.table.setUpdatesEnabled(True)
```

**数据结构优化：**

- 将列表转换为集合，将查找时间复杂度从 O(n) 降到 O(1)
- 缓存计算结果，避免重复计算和I/O操作
- 缓存应在数据变化时自动失效，确保数据一致性

**应用启动优化策略：**

- **界面预创建策略**：启动时创建所有界面，避免切换时的视觉闪烁
  - 优点：切换流畅，无延迟
  - 缺点：启动时间增加
- **组件缓存延迟生成**：耗时计算（如色轮逐像素渲染）延迟到首次绘制时执行
  - 使用 `QTimer.singleShot(0, self._generate_cache)` 异步生成
  - 生成期间先显示简单背景，完成后刷新

**示例 - 色轮缓存延迟生成：**

```python
def paintEvent(self, event):
    painter = QPainter(self)
    painter.setRenderHint(QPainter.RenderHint.Antialiasing)

    # 检查是否需要重新生成缓存
    if not self._cache_valid:
        # 延迟生成缓存，避免阻塞启动
        if not self._pending_generation:
            self._pending_generation = True
            QTimer.singleShot(0, self._generate_wheel_cache_async)
        # 绘制简单背景
        painter.fillRect(self.rect(), self._get_theme_colors()['bg'])
    elif self._wheel_cache:
        # 绘制缓存的色环背景
        painter.drawPixmap(0, 0, self._wheel_cache)

    # 绘制其他内容...

def _generate_wheel_cache_async(self):
    """异步生成色轮缓存"""
    self._pending_generation = False
    self._generate_wheel_cache()
    self.update()
```

**决策原则：**

- 界面结构简单 → 预创建所有界面
- 界面结构复杂/组件初始化耗时 → 延迟创建（需确保切换无闪烁）
- 绘制密集型组件（色轮、直方图） → 延迟生成缓存


---

## 8. 配色数据JSON格式规范

### 8.1 概述

配色数据统一使用 `palettes` 格式存储，支持分组配置和社区贡献。所有配色JSON文件位于 `color_data/` 目录。

### 8.2 标准格式

```json
{
  "version": "1.0",
  "id": "material_design",
  "name": "Material Design",
  "name_zh": "Material Design 配色",
  "description": "Google Material Design 官方配色系统",
  "author": "Google",
  "category": "design_system",
  "palettes": [
    {
      "name": "红色",
      "colors": ["#ffebee", "#ffcdd2", "#ef9a9a", "#e57373", "#f44336"]
    }
  ],
  "groups": [
    {
      "name": "红/粉/紫组",
      "indices": [0, 1, 2, 3]
    }
  ]
}
```

### 8.3 字段说明

|字段 |类型 |必填 |说明 |
|:---|:---:|:---:|:---|
|`version` |string |是 |格式版本号，当前为 "1.0" |
|`id` |string |是 |唯一标识符 |
|`name` |string |是 |配色方案名称（英文） |
|`name_zh` |string |否 |配色方案中文名称 |
|`description` |string |否 |描述信息 |
|`author` |string |是 |作者名称 |
|`category` |string |否 |分类：`design_system`/`theme`/`palette`/`user_palette` |
|`palettes` |array |是 |配色组列表 |
|`palettes[].name` |string |是 |配色组名称 |
|`palettes[].colors` |array |是 |颜色值数组（HEX格式） |
|`groups` |array |否 |分组定义（可选） |
|`groups[].name` |string |是 |分组显示名称 |
|`groups[].indices` |array |是 |配色组索引列表 |

### 8.4 分组配置

分组用于将大量配色按逻辑分类显示，提升浏览体验。

**分组规则**：

|配色组数量 |分组方式 |示例 |
|:---:|:---|:---|
|< 20 |单分组 |"全部 (15组)" |
|≥ 20 |按20组分组 |"第 1-20 组"、"第 21-40 组" |

**分组示例**：

```json
{
  "groups": [
    {"name": "全部 (15组)", "indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]}
  ]
}
```

### 8.5 社区贡献

添加新的配色源只需在 `color_data/` 目录下放置符合格式的JSON文件，应用启动时会自动发现并加载。

**贡献步骤**：

1. 创建符合标准格式的JSON文件
2. 将文件放置到 `color_data/` 目录
3. 重启应用，新配色源自动出现在内置色彩面板

**导出配色作为贡献**：

用户可在配色管理面板导出配色，导出的JSON文件符合标准格式，可直接作为配色源使用。

---

## 9. 场景配置化规范

### 9.1 概述

配色预览功能采用**纯SVG模板模式**，所有场景统一使用SVG格式，支持内置模板和用户自定义模板。

### 9.2 目录结构

**场景数据目录** (`scenes_data/`)：

```
scenes_data/                     # 场景数据目录（打包后只读）
├── scene_types.json             # 场景类型定义
├── ui/                          # 手机UI场景
│   ├── default.svg              # 内置模板
│   └── layout.json              # 布局配置
├── web/                         # 网页场景
│   ├── default.svg
│   └── layout.json
├── illustration/                # 插画场景
├── typography/                  # 排版场景
├── brand/                       # 品牌场景
├── poster/                      # 海报场景
├── pattern/                     # 图案场景
└── magazine/                    # 杂志场景
```

**用户数据存储** (`~/.color_card/config.json`)：

```json
{
  "scene_templates": {
    "ui": [{"path": "D:/设计素材/my_ui.svg", "name": "我的UI模板"}],
    "web": [{"path": "E:/项目文件/my_web.svg", "name": "网页模板1"}]
  }
}
```

### 9.3 场景类型定义

**scene_types.json**：

```json
{
  "version": "3.0",
  "scene_types": [
    {"id": "ui", "name": "手机UI", "icon": "phone", "builtin": true},
    {"id": "web", "name": "网页", "icon": "web", "builtin": true},
    {"id": "illustration", "name": "插画", "icon": "brush", "builtin": true},
    {"id": "typography", "name": "排版", "icon": "font", "builtin": true},
    {"id": "brand", "name": "品牌", "icon": "tag", "builtin": true},
    {"id": "poster", "name": "海报", "icon": "image", "builtin": true},
    {"id": "pattern", "name": "图案", "icon": "grid", "builtin": true},
    {"id": "magazine", "name": "杂志", "icon": "book", "builtin": true},
    {"id": "custom", "name": "自定义", "icon": "svg", "builtin": false}
  ]
}
```

### 9.4 布局配置

**layout.json**：

```json
{
  "layout": {
    "type": "scroll_v",
    "item_size": 200,
    "spacing": 10
  }
}
```

**内置布局类型**：

| 类型ID | 描述 | 效果 |
|--------|------|------|
| `single` | 单图模式 | 一次显示一个，左右切换 |
| `scroll_v` | 垂直滚动 | 多个SVG垂直排列，可滚动 |
| `scroll_h` | 水平滚动 | 多个SVG水平排列，可滚动 |
| `grid_2x2` | 2x2网格 | 4个SVG网格展示 |
| `grid_3x2` | 3x2网格 | 6个SVG网格展示 |
| `mixed` | 混合布局 | 左侧2x2网格 + 右侧大图 |

### 9.5 场景管理

**使用 SceneTypeManager**：

```python
from core import get_scene_type_manager

manager = get_scene_type_manager()

# 获取所有场景类型
scene_types = manager.get_all_scene_types()

# 获取场景的所有模板（内置 + 用户）
templates = manager.get_all_templates("ui")

# 获取内置SVG路径
builtin_path = manager.get_builtin_svg_path("ui")

# 获取布局配置
layout_config = manager.get_layout_config("ui")
```

### 9.6 用户模板管理

**使用 ConfigManager**：

```python
from core import get_config_manager

config_manager = get_config_manager()

# 获取场景的用户模板
templates = config_manager.get_scene_templates_by_type("ui")

# 添加用户模板
config_manager.add_scene_template("ui", {
    "path": "D:/设计素材/my_ui.svg",
    "name": "我的UI模板",
    "added_at": "2026-02-16"
})

# 删除用户模板
config_manager.remove_scene_template("ui", "D:/设计素材/my_ui.svg")
config_manager.save()
```

### 9.7 SVG颜色映射

**使用 SVGColorMapper**：

SVG模板使用语义化 `class` 命名规范，支持智能配色映射。

#### 9.7.1 元素分类依据

| 优先级 | 依据 | 示例 |
|:------:|------|------|
| 1 | class 属性关键词 | `class="background"` → 背景 |
| 2 | id 属性关键词 | `id="main-title"` → 文字 |
| 3 | 标签类型 + 面积 | 最大矩形 → 背景 |

#### 9.7.2 支持的关键词

| 元素类型 | class/id 关键词 | 颜色映射 |
|---------|----------------|---------|
| 背景 | `background`, `bg`, `back` | 配色[0] |
| 主元素 | `primary`, `main` | 配色[1] |
| 次要元素 | `secondary`, `sub` | 配色[2] |
| 强调元素 | `accent`, `highlight` | 配色[3] |
| 文字 | `text`, `title`, `label` | 配色[4] |
| 描边 | `stroke`, `border`, `line` | 配色[4] |

#### 9.7.3 映射策略

**背景元素检测标准**（满足任一条件即视为有背景）：
1. 有 fill 元素面积超过画布面积的 50%，且不是固定颜色元素
2. 有元素的 class 属性包含 "background" 且不是固定颜色元素
3. 有元素的 element_type 为 BACKGROUND 且不是固定颜色元素

**有背景元素时**：
```
背景色 → 配色[0]
其他颜色 → 配色[1..n]（循环）
```

**无背景元素（透明背景）时**：
```
容器背景 → 配色[0]
SVG内部元素 → 配色[1..n]（循环）
```

#### 9.7.4 SVG模板示例

```svg
<!-- 标准语义化SVG模板示例 -->
<svg viewBox="0 0 400 300">
  <!-- 背景 -->
  <rect id="background" class="background" width="400" height="300" fill="#f5f5f5"/>
  
  <!-- 主元素 -->
  <rect id="phone-frame" class="primary" x="120" y="30" width="160" height="240" rx="20" fill="#1a1a1a"/>
  
  <!-- 次要元素 -->
  <rect id="status-bar" class="secondary" x="130" y="40" width="140" height="25" rx="8" fill="#333333"/>
  
  <!-- 强调元素 -->
  <rect id="content-card" class="accent" x="130" y="75" width="140" height="60" rx="10" fill="#ff6b6b"/>
  
  <!-- 文字 -->
  <text id="title" class="text" x="200" y="120" fill="#ffffff">标题</text>
</svg>
```

#### 9.7.5 创建SVG模板规范

1. **画布尺寸**：
   - 参考尺寸：400×300（适用于单图、滚动布局）
   - 根据实际布局需求调整尺寸
   - 网格布局可使用较小尺寸（如 200×150）
   - 混合布局可根据展示区域调整
2. **命名规范**：
   - 使用语义化的 `class` 属性
   - 使用描述性的 `id` 属性
3. **颜色填充**：使用任意颜色，系统会自动替换
4. **导出格式**：使用"演示 SVG"或"内联样式"格式，避免外部CSS引用
5. **固定颜色属性**：
   - 使用 `data-fixed-color` 属性标记不参与配色映射的元素
   - `data-fixed-color="black"`：固定使用黑色（适用于文字）
   - `data-fixed-color="original"`：保持原始颜色（适用于边框、框架等）

**固定颜色示例**：

```svg
<!-- 手机UI场景示例 -->
<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
  <!-- 背景 -->
  <rect id="background" class="background" width="400" height="300" fill="#f5f5f5"/>

  <!-- 手机外框 - 保持原始颜色 -->
  <rect id="phone-frame" class="primary" x="120" y="20" width="160" height="260"
        rx="24" fill="#1a1a1a" data-fixed-color="original"/>

  <!-- 手机屏幕 -->
  <rect id="screen" class="background" x="128" y="28" width="144" height="244"
        rx="18" fill="#ffffff"/>

  <!-- 文字 - 固定使用黑色 -->
  <text id="title" class="text" x="200" y="102" text-anchor="middle"
        font-family="Arial, sans-serif" font-size="16" fill="#ffffff"
        data-fixed-color="black">首页</text>
</svg>
```

**使用场景**：

| 场景 | 元素类型 | 推荐属性值 | 说明 |
|:---:|:---:|:---:|:---|
| 手机UI | 背景 | `original` | 手机边框外的背景固定为白色 |
| 手机UI | 手机外框 | `original` | 边框颜色不应随配色变化 |
| 手机UI | 文字 | `black` | 文字应始终使用黑色确保可读性 |
| 网页 | 背景 | `original` | 网页场景背景固定为白色 |
| 网页 | 文字 | `black` | 导航、标题等文字固定黑色 |
| 网页 | 按钮文字 | `black` | 按钮内文字固定黑色 |

**容器背景处理**：

当SVG中有元素标记 `data-fixed-color="original"` 时，预览容器会自动使用白色背景（而非配色第一个颜色），确保固定颜色的元素能够正确显示。

### 9.8 右键菜单规范

所有SVG统一显示"删除模板"右键菜单：
- 内置SVG：点击后提示"内置场景，不可删除"
- 用户SVG：点击后执行删除


---

## 10. 界面布局规范

### 10.1 布局原则

- 使用布局管理器（QVBoxLayout, QHBoxLayout）
- 避免使用固定尺寸，优先使用 size policy

### 10.2 防止布局重叠的规范

**问题描述：**
当窗口被压缩（尤其是垂直方向）时，组件之间可能出现重叠，导致界面显示异常。

**根本原因：**


1. 组件设置了过大的 `minimumSize`，导致无法压缩
2. 缺少 `sizePolicy` 设置，组件无法正确响应布局变化
3. 使用 `setFixedHeight()` 等固定尺寸方法，阻止了自动调整

**解决方案：**


1. **设置合理的 minimumSize**

   ```python
   # 错误示例：最小尺寸过大，导致无法压缩
   self.setMinimumSize(600, 400)
   
   # 正确示例：根据内容设置合理的最小尺寸
   self.setMinimumSize(300, 200)
   ```
2. **使用 sizePolicy 控制扩展行为**

   ```python
   from PySide6.QtWidgets import QSizePolicy
   
   # 允许组件在水平和垂直方向上都充分扩展和压缩
   self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
   
   # 色卡面板：水平扩展，垂直优先压缩
   self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
   ```
3. **避免使用固定尺寸，使用最小/最大尺寸范围**

   ```python
   # 错误示例：固定高度，无法调整
   self.color_block.setFixedHeight(80)
   
   # 正确示例：允许在一定范围内调整
   self.color_block.setMinimumHeight(40)
   self.color_block.setMaximumHeight(80)
   ```
4. **为关键区域设置最小高度约束**

   ```python
   # 数值区域需要保证文字可见
   self.values_container.setMinimumHeight(60)
   
   # 16进制显示区域
   self.hex_container.setMinimumHeight(30)
   self.hex_container.setMaximumHeight(40)
   ```
5. **QSplitter 中的组件设置**

   ```python
   # 为 splitter 中的每个组件设置最小高度
   main_splitter.setMinimumHeight(400)
   
   # 为 splitter 中的子组件设置约束
   self.image_canvas.setMinimumHeight(200)
   self.color_card_panel.setMinimumHeight(200)
   ```

**实践：**

- 始终为自定义组件设置 `sizePolicy`
- 最小尺寸应根据内容实际需求设置，不宜过大
- 使用 `setMinimumHeight()` 和 `setMaximumHeight()` 组合代替 `setFixedHeight()`
- 在 QSplitter 中，为每个子组件设置合理的最小尺寸
- 测试时尝试将窗口压缩到最小尺寸，检查是否有重叠

### 10.3 控件尺寸参考

|控件 |推荐尺寸 |紧凑尺寸 |说明 |
|:---:|:---:|:---:|:---|
|主窗口 |940×660 |- |默认尺寸 |
|主窗口最小 |800×550 |- |保证内容完整显示 |
|画布最小 |300×200 |300×150 |图片显示区域 |
|色卡面板最小高度 |200 |130 |保证色卡内容可见 |
|单个色卡最小高度 |160 |120 |包含色块+文字+16进制 |
|色块高度范围 |40-80 |30-80 |可压缩范围 |
|数值区域最小高度 |60 |45 |HSB/LAB等数值显示 |
|16进制区域最小高度 |30 |26 |16进制码显示区 |
|取色点半径 |12px |- |便于拖动操作 |
|按钮高度 |28-32 |24 |根据空间调整 |


### 10.4 网格布局自适应宽度经验

**问题描述：**
当使用 QGridLayout 显示多行色卡，且每行色卡数量不同时（如第一行6个，第三行4个），无法实现每行独立占满整行宽度。

**根本原因：**
- QGridLayout 的所有行共享相同的列宽
- 不同行的列数不同会导致拉伸效果不一致
- 设置 `setColumnStretch` 只在列数相同时有效

**解决方案：**
改用 **垂直布局 + 水平布局** 的组合方式：

```python
# 外层使用垂直布局
self.cards_layout = QVBoxLayout()
self.cards_layout.setSpacing(10)

# 计算每行显示的列数
columns = self._calculate_columns(len(colors))

# 按行创建色卡
current_row_layout = None
for i, color in enumerate(colors):
    # 每行开始时创建新的水平布局
    if i % columns == 0:
        current_row_layout = QHBoxLayout()
        current_row_layout.setContentsMargins(0, 0, 0, 0)
        current_row_layout.setSpacing(10)
        self.cards_layout.addLayout(current_row_layout)
    
    card = ColorCard()
    # ... 设置卡片属性 ...
    
    # 添加到当前行的水平布局，设置stretch=1使色卡均匀分布
    current_row_layout.addWidget(card, stretch=1)
```

**清空布局的方法：**

```python
def _clear_color_cards(self):
    """清空所有色卡"""
    # 清空色卡列表
    for card in self._color_cards:
        card.deleteLater()
    self._color_cards.clear()
    
    # 清空所有行布局
    while self.cards_layout.count():
        item = self.cards_layout.takeAt(0)
        if item.layout():
            # 删除行布局中的所有色卡
            while item.layout().count():
                child = item.layout().takeAt(0)
                if child.widget():
                    child.widget().deleteLater()
```

**决策原则：**
- 每行列数相同 → 使用 QGridLayout
- 每行列数不同 → 使用垂直+水平组合布局

---

## 11. 交互设计规范

### 11.1 取色点交互

- 鼠标悬停：显示手型光标
- 拖动时：实时更新颜色值
- 边界限制：限制在图片显示区域内

### 11.2 快捷键规范

|快捷键 |功能 |
|:---:|:---:|
|Ctrl + O |打开图片 |
|Ctrl + Q |退出程序 |

---

## 12. 版本管理规范

### 12.1 版本号格式

- 格式：`主版本.次版本.修订版本`
- 示例：`1.0.0`
- 主版本：重大功能更新
- 次版本：新增功能
- 修订版本：bug 修复

### 12.2 提交信息规范

**格式：** `[类型] 详细描述`

**类型：**

- `新功能`：新增功能或特性
- `修复`：修复代码中的错误
- `优化`：性能或体验改进
- `重构`：代码结构调整
- `文档`：修改或新增文档
- `样式`：界面样式、颜色、布局等视觉相关修改
- `内容调整`：如替换链接、修改文本等

**示例：**

- `[新功能] 新增用户管理功能`
- `[修复] 修复登录功能的验证逻辑错误`
- `[重构] 提取 BaseCanvas 基类，消除重复代码`
- `[文档] 更新 README.md 和开发规范`
- `[样式] 统一图片显示区域和色环背景色为纯黑色`


---

## 13. 更新日志格式规范

### 13.1 更新日志结构

**文件位置：** 项目根目录 `CHANGELOG.md`

**版本格式：**

```markdown
# 🎨 取色卡 v{主版本}.{次版本} 更新日志

## ✨ 新增功能

**{功能模块名称}**
- 新增{功能描述}
- ...

## 🔧 问题修复

- 修复{问题描述}
- ...

## 🎨 界面优化

- {优化描述}
- ...

## ⚡ 性能提升

- {优化描述}
- ...

## 🏗️ 代码重构

- {重构描述}
- ...
```

### 13.2 分类规范

| 分类 | Emoji | 说明 | 示例 |
|:---:|:---:|:---:|:---|
| 新增功能 | ✨ | 新功能、新特性 | 新增色盲模拟预览功能 |
| 问题修复 | 🔧 | Bug修复 | 修复全屏按钮窗口状态保存问题 |
| 界面优化 | 🎨 | UI样式、布局调整 | 优化图标和交互体验 |
| 性能提升 | ⚡ | 性能优化 | 优化应用启动速度 |
| 代码重构 | 🏗️ | 代码结构调整 | 重命名配色管理相关类 |
| 文档更新 | 📝 | 文档修改 | 修正版权和官网信息 |
| 内容调整 | 📋 | 内容修改 | 为图标增加圆角裁切 |

### 13.3 内容组织原则

**功能模块分组：**
- 将相关的功能按模块分组，使用粗体标注模块名称
- 示例：色彩分析增强、配色管理、界面优化等

**条目排序：**
1. 同一分类内，按重要性或相关性排序
2. 相关的修复和优化可合并描述

**表述规范：**
- 使用动词开头：新增、修复、优化、调整、重构
- 描述简洁清晰，避免过于技术化的术语
- 涉及文件或类名时，使用代码格式标注

### 13.4 版本号格式

- 格式：`主版本.次版本.修订版本`
- 示例：`1.2.0`
- 主版本：重大功能更新或架构变更
- 次版本：新增功能
- 修订版本：Bug修复和微调

### 13.5 完整示例

```markdown
# 🎨 取色卡 v1.2 更新日志

## ✨ 新增功能

**色彩分析增强**
- 新增色彩提取页面高饱和度/高明度区域显示功能，支持自定义阈值配置
- RGB直方图添加通道切换按钮，支持单通道或全通道显示
- 在色环周围显示色相名称标签

**配色预览面板**
- 新增配色预览面板，支持10种场景的预览
- 支持导入SVG文件预览
- 右键菜单可删除颜色和复制HEX值

## 🔧 问题修复

- 修复增加色彩提取采样点数后新色卡信息不更新的问题
- 修复全屏按钮窗口状态保存与最大化混淆的问题
- 修复Win10深色模式适配问题

## 🎨 界面优化

- 移除收藏页面操作按钮的Tooltip
- 优化图标和交互体验，禁用原生右键菜单

## ⚡ 性能提升

- 优化应用启动速度：色轮缓存和配色方案颜色延迟生成

## 🏗️ 代码重构

- 将色卡收藏面板重命名为配色管理，配色方案面板重命名为配色生成
- 统一配色管理导入导出JSON格式
```

---

## 14. 配置管理规范

### 14.1 配置管理模块

使用 `core/config.py` 统一管理应用程序状态。

- 配置文件：JSON 格式，存储在用户主目录下的 `.color_card/config.json`
- 使用单例模式获取全局配置管理器实例

### 14.2 配置项说明

|配置键 |类型 |默认值 |说明 |
|:---:|:---:|:---:|:---|
|`settings.hex_visible` |bool |true |是否显示16进制颜色值 |
|`settings.color_modes` |list |["HSB", "LAB"] |色卡中显示的色彩模式 |
|`settings.color_sample_count` |int |5 |色彩提取采样点数量 |
|`window.width` |int |940 |窗口宽度 |
|`window.height` |int |660 |窗口高度 |
|`window.is_maximized` |bool |false |窗口是否最大化 |
|`window.is_fullscreen` |bool |false |窗口是否全屏 |
|`favorites` |list |[] |收藏的配色列表 |

### 14.3 使用示例

```python
from core import get_config_manager

config_manager = get_config_manager()
config = config_manager.load()

# 获取配置项
hex_visible = config_manager.get('settings.hex_visible', True)

# 设置配置项
config_manager.set('settings.hex_visible', False)
config_manager.save()
```


---

## 15. 调试规范

### 15.1 日志管理

**基本原则：**

- 使用 `print()` 语句进行调试
- 关键操作应记录调试信息，便于调试和问题追踪


### 15.2 AI辅助调试

**日志查看流程：**


1. 应用程序启动失败时，查看控制台输出定位问题
2. 功能执行出现异常时，分析错误信息
3. 结合代码上下文，理解错误原因
4. 根据日志信息制定修复方案


---

## 16. 重构规范

### 16.1 重构原则


1. **保持功能不变**：重构过程中不改变现有功能
2. **渐进式重构**：分阶段进行，每阶段可独立验证
3. **先整理后重构**：先规范现有代码，再提取基类，最后重组目录
4. **代码清理同步**：修改代码时同步清理相关重复代码

### 16.2 基类提取规范

**步骤：**


1. 分析相似组件的公共逻辑
2. 设计基类接口（抽象方法）
3. 迁移第一个子类，验证基类设计
4. 迁移其他子类
5. 全面测试验证

**示例：**

```python
# 基类定义
class BaseCanvas(QWidget):
    def _draw_overlay(self, painter: QPainter):
        """绘制叠加内容（子类必须实现）"""
        raise NotImplementedError("子类必须实现 _draw_overlay 方法")

# 子类实现
class ImageCanvas(BaseCanvas):
    def _draw_overlay(self, painter: QPainter):
        """绘制取色点"""
        # 具体实现...
```

### 16.3 模块合并规范

**合并原则：**

- 将紧密相关的类合并到同一文件
- 避免过度拆分，提高代码可维护性
- 保持模块化，但减少文件数量

**示例：**

- `cards.py`：合并 ColorCard、LuminanceCard 及相关基类
- `histograms.py`：合并 LuminanceHistogramWidget、RGBHistogramWidget 及基类
- `canvases.py`：合并 BaseCanvas、ImageCanvas、LuminanceCanvas


---

## 17. 开发经验总结

> **详细内容请参阅**：[开发经验总结.md](开发经验总结.md)

开发经验总结包含以下内容：

- 配色生成功能开发经验
- 布局设计最佳实践
- 收藏功能开发经验
- 导入导出功能开发经验
- MessageBox使用最佳实践
- 配置数据迁移实践
- 内置色彩多段显示经验

---

## 18. 开源许可证管理规范

### 18.1 许可证管理概述

本项目采用 **GPLv3** 作为主许可证，使用了多个第三方库和开发工具，每个都有其自己的开源许可证。完整的许可证管理是开源项目合规性的重要组成部分。

**涉及的许可证类型：**

|类型 |许可证 |用途 |
|:---:|:---:|:---:|
|主项目 |GPLv3 |取色卡项目本身 |
|第三方库 |LGPL-3.0 |PySide6 |
|第三方库 |GPLv3 |PySide6-Fluent-Widgets |
|第三方库 |MIT |Pillow |
|第三方库 |Apache-2.0 |requests |
|第三方库 |BSD-3-Clause |numpy |
|第三方库 |MIT |Open Color |
|第三方库 |MIT |Tailwind CSS Colors |
|第三方库 |MIT |Nice Color Palettes |
|工具链 |MIT |auto-py-to-exe |
|工具链 |GPLv2+ |UPX |
|工具链 |Modified BSD |Inno Setup |

### 18.2 许可证文件管理

**必须维护的许可证文件：**


1. **LICENSE** - 主许可证文本文件
   - 包含完整的 GPLv3 许可证文本
   - 包含所有第三方库的完整许可证信息
   - 包含开发工具链的完整许可证信息
   - 使用统一的文本格式（`====` 和 `----` 分隔线）
2. **file/LICENSE.html** - HTML 格式的许可证文件
   - 用于应用程序内显示
   - 包含格式化的 HTML 样式
   - 与文本版 LICENSE 内容保持一致

### 18.3 第三方库许可证信息收集规范

**收集内容清单：**

|信息项 |说明 |示例 |
|:---:|:---|:---|
|库名称 |完整的库名称 |PySide6 |
|版本要求 |项目使用的版本范围 |>=6.0.0 |
|许可证类型 |SPDX 标识符 |LGPL-3.0 |
|版权所有 |作者或组织名称 |The Qt Company |
|项目地址 |官方网站或仓库地址 |https://www.qt.io/ |
|完整许可证文本 |官方许可证全文 |从官方网站获取 |

**收集渠道：**

- 官方 GitHub 仓库的 LICENSE 文件
- 官方网站许可证页面
- PyPI 项目页面的元数据
- 源码包中的 LICENSE 文件

### 18.4 许可证文本格式规范

**文本版 LICENSE 格式：**

```
================================================================================
第三方库许可证
--------------------------------------------------------------------------------
本项目使用了以下第三方库，每个库都有其自己的开源许可证：

================================================================================
1. 库名称 (许可证类型)
--------------------------------------------------------------------------------
版权所有：作者/组织名称
项目地址：https://example.com/
许可证：完整许可证名称

--------------------------------------------------------------------------------
[完整的许可证文本]

================================================================================
2. 下一个库...
```

**格式要求：**

- 使用 `====`（80个字符）作为章节分隔线
- 使用 `----`（80个字符）作为子章节分隔线
- 每个库独立成节，编号排序
- 许可证文本保持原始格式，不修改内容
- LGPL 许可证需注明引用 GPL 的条款

### 18.5 关于窗口许可证显示规范

**关于对话框必须包含的信息：**

```python
def _get_about_text(self):
    return """
    【开源项目使用说明】
      • 本程序基于 PySide6 架构开发
        版权所有：The Qt Company
        许可证：LGPL v3
        官网：https://www.qt.io/

      • 本程序 UI 组件使用 PySide6-Fluent-Widgets
        版权所有：zhiyiYo
        许可证：GPLv3
        项目地址：https://github.com/zhiyiYo/PyQt-Fluent-Widgets
    
    【开发工具链】
      • 本程序使用 auto-py-to-exe 工具打包
        版权所有：Brent Vollebregt
        许可证：MIT
        项目地址：https://github.com/brentvollebregt/auto-py-to-exe
    """
```

**显示要求：**

- 每个库必须包含：版权所有、许可证类型、项目地址
- 按类别分组（开源项目、开发工具链）
- 格式统一，便于阅读

### 18.6 许可证兼容性检查

**兼容性原则：**

|主许可证 |兼容的许可证 |不兼容的许可证 |
|:---:|:---:|:---:|
|GPLv3 |LGPL-3.0, MIT, Apache-2.0, BSD |专有许可证 |

**检查清单：**

- [ ] 所有第三方许可证与 GPLv3 兼容
- [ ] 所有许可证文本完整且最新
- [ ] 所有版权信息准确无误
- [ ] 所有项目链接可访问
- [ ] LGPL 引用 GPL 的说明清晰

### 18.7 许可证更新流程

**新增第三方库时的步骤：**


1. **信息收集**
   - 收集库名称、版本、许可证类型
   - 获取版权所有者信息
   - 获取项目地址
   - 下载完整许可证文本
2. **兼容性验证**
   - 确认许可证与 GPLv3 兼容
   - 检查许可证版本是否最新
3. **文件更新**
   - 更新 LICENSE 文本文件
   - 更新 file/LICENSE.html
   - 更新关于窗口的 `_get_about_text()`
4.  **验证测试**
   - 检查文本格式是否正确
   - 验证链接可访问性
   - 确认所有文件内容一致

### 18.8 常见许可证文本获取地址

|许可证 |官方地址 |
|:---:|:---|
|GPLv3 |https://www.gnu.org/licenses/gpl-3.0.txt |
|LGPLv3 |https://www.gnu.org/licenses/lgpl-3.0.txt |
|MIT |https://opensource.org/licenses/MIT |
|Apache-2.0 |https://www.apache.org/licenses/LICENSE-2.0.txt |
|BSD-3-Clause |https://opensource.org/licenses/BSD-3-Clause |
|GPLv2 |https://www.gnu.org/licenses/gpl-2.0.txt |

### 18.9 注意事项

**必须避免的问题：**


1. **不要遗漏版权声明**
   - 每个第三方库都必须有明确的版权声明
   - 不能只列出库名和许可证类型
2. **不要修改许可证文本**
   - 保持许可证文本的原始内容
   - 不要删除或添加任何内容
3. **不要遗漏工具链**
   - 打包工具、压缩工具、安装程序制作工具都需要声明
   - 这些工具的许可证同样需要完整列出
4. **保持格式一致**
   - LICENSE 和 LICENSE.html 内容要一致
   - 使用统一的格式风格
5. **LGPL 特殊处理**
   - LGPL 是 GPL 的补充，需要明确说明引用关系
   - 在 LGPL 章节开头说明其引用了 GPL 的条款

---

## 19. 附录

### 19.1  规范维护

**本规范将根据项目发展进行更新，以适应新的功能需求和技术变化。**

### 19.2 版本历史   

|版本 |日期 |变更内容 |
|:---:|:---:|:---:|
|3.13 |2026-02-18 |重构设置界面模块：将 `ui/interfaces.py` 重命名为 `ui/settings.py`；更新 `ui/__init__.py` 和 `ui/main_window.py` 的导入路径；更新项目结构和开发规范 |
|3.12 |2026-02-18 |重构配色预览模块：将 `ColorPreviewInterface` 从 `interfaces.py` 与 `preview_widgets.py` 合并到 `ui/color_preview.py`；删除 `ui/preview_widgets.py`；更新 `ui/__init__.py` 和 `ui/main_window.py` 的导入路径；清理未使用的导入（QFontMetrics、SpinBox）；更新项目结构和开发规范 |
|3.11 |2026-02-18 |修复SVG配色预览颜色映射逻辑：修改 `apply_intelligent_mapping()` 方法，使固定颜色元素不消耗配色；修改 `_has_background_element()` 方法，新增 class="background" 和 element_type == BACKGROUND 检测条件；更新第9.7.3节映射策略规范，明确背景元素检测标准和无背景时的配色分配逻辑 |
|3.10 |2026-02-17 |重构配色管理和预设色彩模块：将 `palette_management_widgets.py` + `PaletteManagementInterface` 合并到 `ui/palette_management.py`；将 `preset_color_widgets.py` + `PresetColorInterface` 合并到 `ui/preset_color.py`；清理 `ui/interfaces.py` 删除已迁移的类；清理未使用的导入；新增 `utils/layout.py` 布局工具模块，提取 `calculate_grid_columns` 公共函数；更新项目结构和开发规范 |
|3.9 |2026-02-17 |重构 interfaces.py：将 `LuminanceExtractInterface` 迁移到独立的 `ui/luminance_extract.py` 文件；将 `ColorGenerationInterface` 和 `generation_widgets.py` 合并到 `ui/color_generation.py`；删除 `ui/generation_widgets.py`；清理冗余导入（移除未使用的 `typing.List`、`Slider` 导入，优化类型提示为内置泛型）；更新 `ui/__init__.py` 和 `ui/main_window.py` 的导入路径；更新项目结构和开发规范 |
|3.8 |2026-02-17 |拆分 interfaces.py：将 `ColorExtractInterface` 和 `DominantColorExtractor` 迁移到独立的 `ui/color_extract.py` 文件；更新 `ui/__init__.py` 和 `ui/main_window.py` 的导入路径；清理 `ui/interfaces.py` 中未使用的导入；更新项目结构和开发规范 |
|3.7 |2026-02-17 |创建图片状态中介者：新建 `core/image_mediator.py` 模块，创建 `ImageMediator` 类统一管理图片状态；消除 `main_window.py` 中的 `_is_clearing` 标志和直接同步方法；添加 `clear_all()` 统一清空方法规范，避免同步时遗漏组件清理；更新项目结构和开发规范 |
|3.6 |2026-02-17 |提取通用分组逻辑：创建 `core/grouping.py` 模块，集中管理分组配置（GROUPING_THRESHOLDS、generate_groups、should_use_batch_loading）；从 `core/config.py` 和 `ui/palette_management_widgets.py` 移除重复代码；更新项目结构 |
|3.5 |2026-02-17 |图片加载优化：重构 `ProgressiveImageLoader` 实现分离加载策略，阶段1快速解码显示尺寸图片（1920px），阶段2后台解码完整图片用于直方图计算；信号重命名 `blurry_loaded`→`display_ready`、`full_loaded`→`full_ready`；大图片显示速度提升50%+ |
|3.4 |2026-02-17 |重构异步加载线程：创建 `core/async_loader.py` 通用分批加载基类 `BaseBatchLoader`，重构 `FavoriteGroupLoaderThread` 和 `GroupLoaderThread` 使用新基类；删除 `ui/canvases.py` 中未使用的 `ImageLoader` 死代码；更新项目结构 |
|3.3 |2026-02-16 |新增SVG固定颜色属性规范：支持 `data-fixed-color` 属性标记不参与配色映射的元素，添加使用示例和场景推荐（第9.7.5节）；更新版本历史 |
|3.2 |2026-02-16 |配色预览重构完成：采用纯SVG模板模式，删除 preview_scenes/ 目录，新增 scenes_data/ 目录，新增布局系统（BaseLayout、SingleLayout、ScrollVLayout等），新增右键删除菜单，更新场景配置化规范（第9章） |
|3.1 |2026-02-16 |新增第8章配色数据JSON格式规范：说明统一的 palettes 格式、groups 字段、社区贡献指南；章节序号顺延调整 |
|3.0 |2026-02-13 |文档重构：拆分为核心原则、完整版、经验总结三个独立文档；合并第9章和第10章布局规范；第14章开发经验总结独立为 `开发经验总结.md` |
|2.21 |2026-02-11 |优化内置色彩和配色管理的色卡布局：将 QGridLayout 改为 QVBoxLayout + QHBoxLayout 组合布局，实现每行色卡数量不同时仍能自适应占满整行宽度；新增网格布局自适应宽度经验（第10章），包含问题分析、解决方案、代码示例和决策原则 |
|2.20 |2026-02-11 |完善配色预览场景功能：新增 brand（品牌）、poster（海报）、pattern（图案）、magazine（杂志排版）四个配置化场景；所有场景完全配置化，从 `scenes.json` 加载；清理 `ui/preview_widgets.py` 中的硬编码文本，UI/Web 场景文本支持通过配置自定义；删除废弃的 `MobileUIPreview` 和 `WebPreview` 类，统一使用 `ConfigurablePreviewScene`；更新开发规范文档（第8章场景类型规范） |
|2.19 |2026-02-11 |新增SVG智能配色映射功能：创建 `core/svg_color_mapper.py` 核心模块，实现 SVG 解析、元素分类、智能配色映射；支持智能配色映射模式；支持 CSS 类样式解析（Illustrator 导出的 SVG 常用格式）；基于元素面积的智能配色映射算法；检测 SVG 是否有背景元素，为透明背景自动添加背景矩形；更新 `SVGPreviewWidget` 支持新的配色映射功能；更新项目结构和开发规范 |
|2.18 |2026-02-10 |新增场景配置化功能：创建 `preview_scenes/` 目录和 `scenes.json` 配置文件；新增 `SceneConfigManager` 场景配置管理器，支持场景的导入导出；新增 `BasePreviewScene` 场景基类和 `PreviewSceneFactory` 场景工厂；实现 `MobileUIPreview` 手机UI预览和 `WebPreview` 网页预览组件；更新 `PreviewSceneSelector` 从配置动态加载场景列表；所有场景支持导入导出配置；更新项目结构和开发规范（第8章） |
|2.17 |2026-02-10 |重命名"配色方案"为"配色生成"，"色彩管理"为"配色管理"：将 `scheme_widgets.py` 重命名为 `generation_widgets.py`，类名 `SchemeColorInfoCard` 改为 `GenerationColorInfoCard`，`SchemeColorPanel` 改为 `GenerationColorPanel`；将 `color_management_widgets.py` 重命名为 `palette_management_widgets.py`，类名 `ColorManagementSchemeCard` 改为 `PaletteManagementCard`，`ColorManagementSchemeList` 改为 `PaletteManagementList`；更新所有相关引用、导航栏显示和文档 |
|2.16 |2026-02-10 |新增配色预览功能：创建 ui/preview_widgets.py 配色预览组件模块，包含可拖拽颜色圆点、插画预览、排版预览等组件；新增 ColorPreviewInterface 界面，支持从配色管理页面跳转预览配色在不同场景下的应用效果 |
|2.15 |2026-02-09 |优化应用启动速度：色轮缓存和配色生成颜色改用延迟生成，避免阻塞启动；新增应用启动优化策略规范（7.3节） |
|2.14 |2026-02-09 |重命名"色卡收藏"面板为"色彩管理"：将 `favorite_widgets.py` 重命名为 `color_management_widgets.py`，类名 `FavoritesInterface` 改为 `ColorManagementInterface`，更新所有相关引用和导航栏显示 |
|2.13 |2026-02-09 |优化配色方案随机算法：所有配色方案生成函数添加 `base_saturation` 参数，支持基于基准饱和度的随机变化，更新配色方案算法设计规范（14.1.1节） |
|2.12 |2026-02-09 |修复HSB色轮明度计算问题：滑块范围改为10-100直接对应B值百分比，统一色轮和色块面板的全局明度值逻辑，更新色轮交互设计规范（14.1.4节） |
|2.11 |2026-02-08 |新增开源许可证管理规范（第15章），总结版权完善计划执行经验，包含许可证收集、格式规范、兼容性检查、更新流程等完整规范 |
|2.10 |2026-02-07 |新增信号循环预防规范（5.3节）、QThread取消机制（7.3节）；实现双面板独立图片导入、分阶段图片加载（模糊预览→完整图片→更新直方图）、进度显示功能 |
|2.9 |2026-02-07 |新增主题颜色管理规范（5.5节），创建 ui/theme_colors.py 统一颜色管理，消除所有硬编码颜色值 |
|2.8 |2026-02-06 |新增工具栏/按钮容器间距规范，补充 QSplitter 分隔条样式注意事项 |
|2.7 |2026-02-06 |补充渐进式压缩设计原则和实际案例，更新控件尺寸参考表（增加紧凑尺寸列），完善布局压缩的最佳实践 |
|2.6 |2026-02-06 |新增防止布局重叠的规范（8.2节），包含minimumSize、sizePolicy、固定尺寸替代方案等最佳实践，更新控件尺寸参考表 |
|2.5 |2026-02-06 |新增收藏功能（收藏配色方案、批量导入导出、收藏管理），新增MessageBox使用规范、配置数据迁移实践、动态卡片管理 |
|2.4 |2026-02-06 |配色生成面板UI优化（色轮容器化、自适应大小、QSplitter布局），新增布局设计最佳实践经验 |
|2.3 |2026-02-06 |新增配色生成功能（5种配色算法、可交互色环、配色生成组件），更新项目结构，新增开发经验总结章节 |
|2.2 |2026-02-05 |重构项目结构，提取公共基类（BaseCanvas、BaseCard、BaseHistogram），扁平化目录结构，更新文档 |
|2.1 |2026-02-04 |借鉴BetterGI 星轨开发规范，新增导入规范、代码清理原则、异常处理规范、性能优化建议、调试规范 |
|2.0 |2026-02-04 |重构文档结构，精简冗余内容，优化版本号体系 |
|1.0 |2026-02-03 |初始版本，建立基础开发规范 |