# Color Card 开发规范

## 1. 概述

### 1.1 项目简介

Color Card（取色卡）是一个基于 PySide6 开发的图片颜色分析工具，用于从图片中提取颜色信息和分析明度分布，支持多种色彩模式显示。

**核心功能：**
- 图片导入（JPG、PNG、BMP、GIF）
- 色彩提取：5个可拖动取色点，实时显示色彩值
- 多色彩模式：HSB、LAB、HSL、CMYK、RGB
- 明度提取与直方图可视化
- 双面板数据同步

### 1.2 开发环境

- **操作系统**：Windows 10/11
- **Python 版本**：3.11+
- **GUI 框架**：PySide6 + PySide6-Fluent-Widgets
- **推荐 IDE**：VS Code、PyCharm、Trae

### 1.3 项目结构

```
color_card/
├── main.py                 # 程序入口
├── version.py              # 版本管理模块
├── requirements.txt        # 项目依赖
├── README.md               # 项目文档
├── LICENSE                 # 开源许可证
├── 开发规范.md              # 本文件
├── core/                   # 核心功能模块目录
│   ├── __init__.py
│   ├── color.py           # 颜色处理模块（颜色转换、明度计算、配色方案算法）
│   ├── colorblind.py      # 色盲模拟模块（色盲类型定义、LMS色彩空间转换、色盲模拟算法）
│   ├── color_data.py      # 颜色数据管理模块（延迟加载各颜色库数据）
│   ├── config.py          # 配置管理模块
│   └── contrast.py        # 对比度检查模块（WCAG对比度计算、等级判断）
├── ui/                     # UI模块目录（扁平化结构）
│   ├── __init__.py        # 统一导出接口
│   ├── main_window.py     # 主窗口类
│   ├── canvases.py        # 画布模块（BaseCanvas、ImageCanvas、LuminanceCanvas）
│   ├── cards.py           # 卡片组件模块（ColorCard、LuminanceCard及基类）
│   ├── histograms.py      # 直方图组件模块
│   ├── color_picker.py    # 颜色选择器模块
│   ├── color_wheel.py     # 颜色轮模块（HSBColorWheel、InteractiveColorWheel）
│   ├── scheme_widgets.py  # 配色方案组件模块（SchemeColorInfoCard、SchemeColorPanel）
│   ├── color_management_widgets.py # 色彩管理组件模块（ColorManagementColorCard、ColorManagementSchemeCard、ColorManagementSchemeList）
│   ├── preset_color_widgets.py # 内置色彩组件模块（PresetColorCard、PresetColorSchemeCard、PresetColorList）
│   ├── preview_widgets.py # 配色预览组件模块（DraggableColorDot、ColorDotBar、IllustrationPreview、TypographyPreview、PreviewToolbar、MixedPreviewPanel）
│   ├── zoom_viewer.py     # 缩放查看器模块
│   ├── interfaces.py      # 界面面板模块（ColorExtractInterface、LuminanceExtractInterface、SettingsInterface、ColorSchemeInterface、ColorManagementInterface、PresetColorInterface、ColorPreviewInterface）
│   └── theme_colors.py    # 主题颜色管理模块（统一颜色管理、主题感知颜色获取）
├── dialogs/               # 对话框模块目录
│   ├── __init__.py
│   ├── about_dialog.py    # 关于对话框
│   ├── colorblind_dialog.py # 色盲模拟预览对话框
│   ├── contrast_dialog.py # 对比度检查对话框
│   └── update_dialog.py   # 更新检查对话框
├── utils/                 # 工具函数模块目录
│   ├── __init__.py
│   ├── icon.py            # 图标工具模块
│   └── platform.py        # 平台相关工具模块
└── color_data/            # 颜色数据目录（JSON格式）
    ├── open_color.json    # Open Color 颜色库
    ├── tailwind_colors.json # Tailwind CSS 颜色库
    ├── material_design.json # Material Design 颜色库
    ├── nord.json          # Nord 颜色库
    ├── dracula.json       # Dracula 颜色库
    ├── colorbrewer.json   # ColorBrewer 颜色库
    ├── radix_colors.json  # Radix Colors 颜色库
    └── nice_palettes.json # Nice Color Palettes 配色方案
```

---

## 2. 代码组织规范

### 2.1 文件命名规范

- 采用小写字母和下划线命名，如 `color_utils.py`
- 核心功能模块使用清晰的描述性名称
- 合并后的模块使用复数形式命名，如 `cards.py`、`histograms.py`、`canvases.py`

### 2.2 模块划分

| 模块类型 | 职责 | 示例文件 |
|:---:|:---:|:---:|
| 入口模块 | 应用程序入口 | `main.py` |
| 核心模块 | 颜色处理、配置管理 | `core/color.py`, `core/config.py` |
| UI 模块 | 界面组件和面板 | `ui/canvases.py`, `ui/cards.py` |
| 对话框模块 | 弹出对话框 | `dialogs/about_dialog.py` |
| 工具模块 | 通用功能 | `utils/icon.py`, `utils/platform.py` |

### 2.3 目录结构原则

**扁平化结构（2级目录）：**

```
color_card/           ← 第1级
├── core/            ← 第2级
├── ui/              ← 第2级（扁平化，直接包含所有UI文件）
├── dialogs/         ← 第2级
└── utils/           ← 第2级
```

**设计原则：**
- 避免过度嵌套（不超过2级目录）
- 将紧密相关的类合并到同一文件，减少文件数量
- 保持功能模块化，职责明确

### 2.4 导入规范

**导入顺序：** 标准库 → 第三方库 → 项目模块

**规范要求：**
- 按模块类型分组导入，添加清晰的分组注释
- 定期清理未使用的导入
- 合并同一模块的多次导入
- 优先使用绝对导入

```python
# 标准库导入
import sys
import math
from pathlib import Path

# 第三方库导入
from PySide6.QtWidgets import QApplication, QMainWindow
from PySide6.QtCore import Qt, Signal
from qfluentwidgets import FluentWindow

# 项目模块导入
from core import get_color_info, get_config_manager
from ui import MainWindow
```

**导入清理示例：**
```python
# 修改前
from styles import UnifiedStyleHelper
from styles import get_global_font_manager

# 修改后
from styles import UnifiedStyleHelper, get_global_font_manager
```

---

## 3. 代码编写规范

### 3.1 基本规范

- 遵循 **PEP 8** 代码风格规范
- 使用 4 个空格缩进
- 行长度限制在 100 字符以内
- 保持代码简洁，删除无用的调试代码和临时测试代码

### 3.2 代码清理原则

**修改代码时应同步进行以下清理：**
- 删除未使用的变量、函数、导入和注释
- 合并重复的逻辑和相似的功能
- 检查并清除相关的重复冗余代码
- 保持代码整洁，提高代码复用性

**清理示例：**
```python
# 修改前
import json
import re

def calculate():
    temp = 0  # 未使用的变量
    return result

# 修改后（删除未使用的导入和变量）
def calculate():
    return result
```

### 3.3 命名规范

| 类型 | 规范 | 示例 |
|:---:|:---:|:---:|
| 类名 | 驼峰命名法 | `ColorPicker`, `ImageCanvas` |
| 函数/方法 | 小写+下划线 | `extract_color()` |
| 变量 | 小写+下划线 | `picker_positions` |
| 常量 | 大写+下划线 | `PICKER_RADIUS = 12` |
| 私有属性 | 单下划线前缀 | `_dragging` |

### 3.4 异常处理规范

**基本原则：**
- 避免使用裸 `except:` 或 `except Exception:`
- 应指定具体异常类型
- 提供详细的错误信息，便于调试

**示例：**
```python
# 错误示例
except Exception:
    pass

# 正确示例
except (OSError, ValueError) as e:
    error_msg = f"文件读取失败: {str(e)}"
    print(error_msg)
```

### 3.5 文档字符串规范

**基本原则：**
- 所有公共类和方法必须添加文档字符串
- 使用简洁的中文描述，避免冗余
- 类文档字符串保持简洁（单行或简短段落）
- 方法文档字符串包含 Args、Returns 说明

**精简示例：**
```python
# 类文档字符串（简洁）
class ImageCanvas(QWidget):
    """图片显示画布，支持取色点拖动"""
    pass

# 方法文档字符串（完整但简洁）
def set_image(self, image_path):
    """加载并显示图片
    
    Args:
        image_path: 图片文件的完整路径
    """
    pass

# 带返回值的文档字符串
def get_color_info(self, r, g, b):
    """获取颜色信息
    
    Args:
        r: 红色通道值 (0-255)
        g: 绿色通道值 (0-255)
        b: 蓝色通道值 (0-255)
    
    Returns:
        dict: 包含RGB、HSB、LAB、HEX颜色信息的字典
    """
    pass
```

### 3.6 信号命名规范

- 信号名使用小写+下划线
- 添加注释说明信号参数

```python
class ImageCanvas(QWidget):
    color_picked = Signal(int, tuple)      # 信号：索引, RGB颜色
    image_loaded = Signal(str)              # 信号：图片路径
    image_cleared = Signal()                # 信号：图片已清空
```

### 3.7 主题与样式规范

#### 3.7.1 主题切换实现规范

**使用 qfluentwidgets 的主题系统：**
- 使用 `setTheme(Theme.LIGHT/DARK)` 切换主题
- 使用 `isDarkTheme()` 检测当前主题
- 使用 `qconfig.themeChangedFinished` 信号监听主题变化

**示例代码：**
```python
from qfluentwidgets import setTheme, Theme, isDarkTheme, qconfig

# 切换主题
def toggle_theme():
    if isDarkTheme():
        setTheme(Theme.LIGHT)
    else:
        setTheme(Theme.DARK)

# 监听主题变化
qconfig.themeChangedFinished.connect(self._update_styles)
```

#### 3.7.2 颜色管理规范

**集中管理颜色值：**
- 所有颜色值应定义在 `theme_colors.py` 中
- 使用函数返回 QColor，支持主题感知
- 避免在组件中硬编码颜色值

**颜色函数命名规范：**
```python
# 背景颜色

def get_card_background_color():
    return QColor(42, 42, 42) if isDarkTheme() else QColor(255, 255, 255)

# 文本颜色

def get_text_color(secondary=False):
    if isDarkTheme():
        return QColor(160, 160, 160) if secondary else QColor(255, 255, 255)
    else:
        return QColor(120, 120, 120) if secondary else QColor(40, 40, 40)
```

#### 3.7.3 主题自适应组件实现

**必须实现 `_update_styles()` 方法：**
- 在 `__init__` 中调用 `_update_styles()` 初始化样式
- 连接 `qconfig.themeChangedFinished` 信号
- 根据 `isDarkTheme()` 返回不同颜色值

**示例：**
```python
class MyWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
        self._update_styles()
        qconfig.themeChangedFinished.connect(self._update_styles)

    def _update_styles(self):
        """更新样式以适配主题"""
        if isDarkTheme():
            label_color = "#ffffff"
            value_color = "#ffffff"
        else:
            label_color = "#333333"
            value_color = "#333333"

        self.label.setStyleSheet(f"color: {label_color};")
```

#### 3.7.4 样式表使用规范

**避免使用 `!important`：**
- 优先使用组件特定的选择器
- 如必须使用，确保在主题切换后重新应用

**自定义标题栏按钮样式：**
```python
# 在主题切换后重新应用样式

def _toggle_theme(self):
    if isDarkTheme():
        setTheme(Theme.LIGHT)
    else:
        setTheme(Theme.DARK)
    # 重新应用自定义样式
    self._apply_custom_style()
```

#### 3.7.5 Windows 原生标题栏深色模式

**使用 Windows DWM API 设置原生标题栏主题：**

对于继承自 `QDialog` 的对话框，使用 Windows DWM (Desktop Window Manager) API 设置原生标题栏的沉浸式深色模式。

**实现步骤：**

1. **创建工具函数**（放在 `utils/platform.py`）：
```python
import ctypes
import sys

DWMWA_USE_IMMERSIVE_DARK_MODE = 20

def set_window_title_bar_theme(window, is_dark=False):
    """为窗口设置标题栏主题（Windows 10+）"""
    try:
        if sys.platform != "win32":
            return False
        
        window_handle = window.windowHandle()
        if not window_handle:
            return False
        
        hwnd = int(window_handle.winId())
        value = ctypes.c_int(1 if is_dark else 0)
        
        result = ctypes.windll.dwmapi.DwmSetWindowAttribute(
            hwnd,
            DWMWA_USE_IMMERSIVE_DARK_MODE,
            ctypes.byref(value),
            ctypes.sizeof(value)
        )
        return result == 0
    except Exception:
        return False
```

2. **在对话框中应用**（使用 `showEvent` 避免闪烁）：
```python
from qfluentwidgets import isDarkTheme, qconfig
from utils import set_window_title_bar_theme

class MyDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        # ... 其他初始化代码 ...
        
        # 监听主题变化（用于更新已打开的对话框）
        qconfig.themeChangedFinished.connect(self._update_title_bar_theme)
    
    def showEvent(self, event):
        """窗口显示前设置标题栏主题，避免闪烁"""
        self._update_title_bar_theme()
        super().showEvent(event)
    
    def _update_title_bar_theme(self):
        """更新标题栏主题"""
        set_window_title_bar_theme(self, isDarkTheme())
```

**关键要点：**
- 使用 `showEvent` 在窗口显示前设置标题栏主题，避免闪烁
- 连接 `qconfig.themeChangedFinished` 信号，支持已打开对话框的主题切换
- 仅支持 Windows 10 版本 2004 (Build 19041) 及以上，Windows 11 完全支持
- 非 Windows 平台静默跳过，不影响程序运行

---

## 4. 基类设计规范

### 4.1 画布基类 (BaseCanvas)

**文件位置：** `ui/canvases.py`

**职责：**
- 提供图片加载、显示的基础功能
- 实现坐标转换（画布坐标 ↔ 图片坐标）
- 管理图片相对坐标系统
- 提供右键菜单框架

**子类必须实现的方法：**
```python
def _on_image_loaded(self):
    """图片加载后的处理（子类重写）"""
    pass

def _on_image_cleared(self):
    """图片清空后的处理（子类重写）"""
    pass

def _draw_overlay(self, painter: QPainter):
    """绘制叠加内容（子类必须实现）"""
    raise NotImplementedError("子类必须实现 _draw_overlay 方法")
```

### 4.2 卡片基类 (BaseCard / BaseCardPanel)

**文件位置：** `ui/cards.py`

**职责：**
- 提供统一的卡片接口
- 管理卡片列表（BaseCardPanel）
- 支持批量清空卡片

**设计原则：**
- 保持接口简洁（setup_ui, clear）
- 灵活的卡片创建方法
- 清晰的职责分离

### 4.3 直方图基类 (BaseHistogram)

**文件位置：** `ui/histograms.py`

**职责：**
- 提供通用的数据管理（set_data, clear）
- 提供通用的绘制框架（paintEvent）
- 定义抽象方法接口

**子类必须实现的方法：**
```python
def _draw_histogram(self, painter: QPainter):
    """绘制直方图（子类必须实现）"""
    raise NotImplementedError("子类必须实现 _draw_histogram 方法")

def _draw_custom_overlay(self, painter: QPainter):
    """绘制自定义叠加内容（子类重写）"""
    pass

def _draw_labels(self, painter: QPainter):
    """绘制标签（子类重写）"""
    pass
```

### 4.4 基类设计原则

1. **单一职责**：每个基类只负责一类功能
2. **接口清晰**：抽象方法明确，子类职责清晰
3. **可扩展性**：便于添加新的子类实现
4. **代码复用**：提取公共逻辑，消除重复代码

---

## 5. PySide6 开发规范

### 5.1 Fluent Widgets 使用规范

- 主窗口继承 `FluentWindow`
- 使用 `setTheme()` 设置主题
- 使用 `setThemeColor()` 设置主题色

```python
from qfluentwidgets import FluentWindow, setTheme, Theme, FluentIcon

setTheme(Theme.AUTO)
setThemeColor('#0078d4')

class MainWindow(FluentWindow):
    def setup_navigation(self):
        self.addSubInterface(
            self.interface,
            FluentIcon.PALETTE,
            "界面名称"
        )
```

### 5.2 界面组织规范

- 每个功能模块创建独立的 `QWidget` 子类
- 界面类使用 `setObjectName()` 设置唯一标识

```python
class ColorExtractInterface(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName('colorExtractInterface')
        self.setup_ui()
        self.setup_connections()
```

### 5.3 信号与槽

- 信号连接应在初始化时完成
- 槽函数命名使用 `on_` 前缀
- **防止双向同步循环**：当两个面板需要相互同步数据时，使用标志位或参数控制信号发射，避免无限循环

```python
# 信号连接
self.image_canvas.color_picked.connect(self.on_color_picked)

# 槽函数实现
def on_color_picked(self, index, rgb):
    """颜色提取回调"""
    pass

# 防止双向同步循环的示例
def set_image_data(self, pixmap, image, emit_sync=True):
    """设置图片数据
    
    Args:
        pixmap: QPixmap 对象
        image: QImage 对象
        emit_sync: 是否发射同步信号（默认True，从其他面板同步时设为False）
    """
    self._original_pixmap = pixmap
    self._image = image
    
    # 只在独立导入时发射同步信号，防止双向循环
    if emit_sync:
        self.image_loaded.emit(file_path)
        self.image_data_loaded.emit(pixmap, image)

# 从其他面板同步时禁用信号发射
# 面板A导入图片 → 同步到面板B（emit_sync=False）
# 面板B不会发射信号回到面板A，打破循环
```

### 5.4 自定义控件规范

- 继承自合适的 QWidget 子类
- 重写 `paintEvent` 实现自定义绘制

```python
class ColorPicker(QWidget):
    """可拖动的圆形取色点"""
    
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        # 绘制代码...
```

### 5.5 样式设置规范

#### 5.5.1 颜色管理规范

**核心原则：禁止在组件中直接使用硬编码颜色值**

所有颜色必须通过 `ui/theme_colors.py` 模块统一管理：

```python
# 正确用法 - 从主题颜色模块导入
from ui.theme_colors import get_text_color, get_canvas_background_color

# 获取主题感知的文本颜色
text_color = get_text_color()

# 获取固定颜色（如图片显示器背景）
bg_color = get_canvas_background_color()  # 固定灰黑色 #2a2a2a
```

**禁止的做法：**
```python
# 错误 - 硬编码颜色值
painter.setPen(QColor(255, 255, 255))
widget.setStyleSheet("background-color: #2a2a2a;")
```

#### 5.5.2 主题颜色模块 (ui/theme_colors.py)

**设计原则：**
- **集中管理**：所有颜色值集中在 theme_colors.py 中定义
- **主题感知**：颜色函数根据当前主题（深色/浅色）自动返回对应颜色
- **分类清晰**：按用途分类（背景色、文本色、边框色、控件颜色等）

**颜色分类：**

| 分类 | 函数示例 | 说明 |
|:---:|:---|:---|
| 背景色 | `get_canvas_background_color()` | 图片显示器背景（固定 #2a2a2a） |
| 背景色 | `get_card_background_color()` | 卡片背景（主题感知） |
| 背景色 | `get_histogram_background_color()` | 直方图背景（固定 #2a2a2a） |
| 文本色 | `get_text_color()` | 主文本颜色（主题感知） |
| 文本色 | `get_secondary_text_color()` | 次要文本颜色（主题感知） |
| 文本色 | `get_title_color()` | 标题颜色（主题感知） |
| 边框色 | `get_border_color()` | 边框颜色（主题感知） |
| 控件色 | `get_picker_border_color()` | 取色点边框颜色 |
| 控件色 | `get_picker_fill_color()` | 取色点填充颜色 |
| Zone色 | `get_zone_background_color()` | Zone框背景颜色 |
| Zone色 | `get_zone_text_color()` | Zone框文字颜色 |

**添加新颜色的步骤：**
1. 在 `ui/theme_colors.py` 中添加颜色函数
2. 根据用途选择合适的分类
3. 确定是固定颜色还是主题感知颜色
4. 在相关组件中使用新函数

#### 5.5.3 主题设置

- 使用 `setTheme()` 设置全局主题
- 使用 `isDarkTheme()` 检测当前主题
- 使用 `setThemeColor()` 设置主题色

```python
from qfluentwidgets import FluentWindow, setTheme, Theme, FluentIcon, setThemeColor

setTheme(Theme.AUTO)
setThemeColor('#0078d4')

class MainWindow(FluentWindow):
    pass
```

### 5.6 右键菜单规范

- 使用 `RoundMenu` 创建 Fluent 风格的右键菜单
- 使用 `Action` 创建菜单项

```python
from qfluentwidgets import RoundMenu, Action, FluentIcon

def contextMenuEvent(self, event):
    menu = RoundMenu("")
    change_action = Action(FluentIcon.PHOTO, "更换图片")
    menu.addAction(change_action)
    menu.exec(event.globalPos())
```

---

## 6. 颜色处理规范

### 6.1 颜色空间转换

- 所有颜色转换函数放在 `core/color.py`
- 返回结果包含完整的颜色信息

```python
def get_color_info(r, g, b):
    """获取颜色的完整信息"""
    return {
        'rgb': (r, g, b),
        'hsb': (h, s, v),
        'lab': (l, a, b),
        'hex': rgb_to_hex(r, g, b)
    }
```

### 6.2 明度计算规范

使用 Rec. 709 标准计算亮度值，包含 sRGB Gamma 校正。

```python
def get_luminance(r: int, g: int, b: int) -> int:
    """计算像素的明度值 (0-255)
    
    使用 Rec. 709 标准计算亮度值，包含 sRGB Gamma 校正
    这是 Lightroom、Photoshop 等专业软件使用的标准方法
    """
    # 步骤1: 归一化到 0-1 范围
    r_norm, g_norm, b_norm = r / 255.0, g / 255.0, b / 255.0

    # 步骤2: sRGB Gamma 解码（转换到线性空间）
    def srgb_to_linear(c):
        if c <= 0.04045:
            return c / 12.92
        else:
            return ((c + 0.055) / 1.055) ** 2.4

    r_linear = srgb_to_linear(r_norm)
    g_linear = srgb_to_linear(g_norm)
    b_linear = srgb_to_linear(b_norm)

    # 步骤3: 在线性空间应用 Rec. 709 权重
    luminance_linear = 0.2126 * r_linear + 0.7152 * g_linear + 0.0722 * b_linear

    # 步骤4-5: 编码回 sRGB 空间并转换到 0-255
    # ...
```

### 6.3 Zone 分区规范

采用 Adobe 官方标准的 5 个明度区域：

| 区域 | 明度范围 | 英文名 | 描述 |
|:---:|:---:|:---:|:---|
| 黑色 | 0%–10% | Blacks | 黑点区域，最暗的部分 |
| 阴影 | 10%–30% | Shadows | 阴影区域，较暗的色调 |
| 中间调 | 30%–70% | Midtones | 中间亮度区域，由 Exposure/Contrast 负责调整 |
| 高光 | 70%–90% | Highlights | 高光区域，较亮的色调 |
| 白色 | 90%–100% | Whites | 白点区域，最亮的部分 |

**技术映射（0-255 值到 Adobe 区域）：**

| Zone | 明度范围 | Adobe 区域 |
|:---:|:---:|:---:|
| Zone 0 | 0-25 | 黑色(Blacks) |
| Zone 1 | 26-51 | 黑色(Blacks) |
| Zone 2 | 52-76 | 阴影(Shadows) |
| Zone 3 | 77-102 | 中间调(Midtones) |
| Zone 4 | 103-128 | 中间调(Midtones) |
| Zone 5 | 129-153 | 中间调(Midtones) |
| Zone 6 | 154-179 | 中间调(Midtones) |
| Zone 7 | 180-204 | 高光(Highlights) |
| Zone 8 | 205-255 | 白色(Whites) |

---

## 7. 图片处理规范

### 7.1 图片加载规范

- 保留原始高分辨率图片
- 使用 `QPixmap` 用于显示，`QImage` 用于像素读取
- 使用多线程异步加载大图片

### 7.2 坐标映射规范

**核心原则：** 采样点位置使用**图片相对坐标**（归一化坐标 0.0-1.0）存储。

| 坐标类型 | 说明 | 范围 |
|:---:|:---|:---:|
| 相对坐标 | 相对于图片的归一化坐标 | 0.0-1.0 |
| 画布坐标 | 相对于画布控件的像素坐标 | 像素值 |

```python
# 相对坐标 → 画布坐标
canvas_x = disp_x + rel_x * disp_w

# 画布坐标 → 相对坐标
rel_x = (canvas_x - disp_x) / disp_w
```

### 7.3 性能优化规范

**基本策略：**
- 使用 `QThread` 在子线程读取图片文件
- 使用 `QTimer.singleShot()` 延迟执行耗时操作
- 直方图计算使用采样优化

**QThread 取消机制：**
- 使用标志位机制实现线程取消，避免使用 `wait()` 阻塞UI线程
- 在 `run()` 方法的关键检查点检查取消标志
- 不等待旧线程结束，立即启动新线程

```python
class ImageLoader(QThread):
    """图片加载线程（支持取消）"""
    
    def __init__(self, image_path: str) -> None:
        super().__init__()
        self._image_path = image_path
        self._is_cancelled = False  # 取消标志
    
    def cancel(self) -> None:
        """请求取消加载（线程安全）"""
        self._is_cancelled = True
    
    def _check_cancelled(self) -> bool:
        """检查是否被取消"""
        return self._is_cancelled
    
    def run(self) -> None:
        """在子线程中加载图片"""
        try:
            with Image.open(self._image_path) as pil_image:
                # 关键检查点1
                if self._check_cancelled():
                    return
                
                # 耗时操作前检查
                if self._check_cancelled():
                    return
                
                # 执行耗时操作...
                
                # 关键检查点2
                if self._check_cancelled():
                    return
                    
        except Exception as e:
            if not self._check_cancelled():
                self.error.emit(str(e))

# 使用示例（非阻塞切换）
def set_image(self, image_path: str) -> None:
    # 取消旧线程（非阻塞）
    if self._loader is not None:
        self._loader.cancel()
        # 注意：不调用 wait()，避免阻塞UI线程
        self._loader = None
    
    # 立即启动新线程
    self._loader = ImageLoader(image_path)
    self._loader.start()
```

**UI性能优化：**
- 批量更新UI时使用 `setUpdatesEnabled(False/True)` 包裹更新操作
- 避免在循环中频繁更新UI，先收集数据再批量更新
- 使用 `try-finally` 确保 `setUpdatesEnabled(True)` 一定会执行

```python
# 批量更新UI示例
def update_table_data(self):
    self.table.setUpdatesEnabled(False)
    try:
        for row in range(self.table.rowCount()):
            self.table.setItem(row, 0, item)
    finally:
        self.table.setUpdatesEnabled(True)
```

**数据结构优化：**
- 将列表转换为集合，将查找时间复杂度从 O(n) 降到 O(1)
- 缓存计算结果，避免重复计算和I/O操作
- 缓存应在数据变化时自动失效，确保数据一致性

**应用启动优化策略：**

- **界面预创建策略**：启动时创建所有界面，避免切换时的视觉闪烁
  - 优点：切换流畅，无延迟
  - 缺点：启动时间增加

- **组件缓存延迟生成**：耗时计算（如色轮逐像素渲染）延迟到首次绘制时执行
  - 使用 `QTimer.singleShot(0, self._generate_cache)` 异步生成
  - 生成期间先显示简单背景，完成后刷新

**示例 - 色轮缓存延迟生成：**
```python
def paintEvent(self, event):
    painter = QPainter(self)
    painter.setRenderHint(QPainter.RenderHint.Antialiasing)

    # 检查是否需要重新生成缓存
    if not self._cache_valid:
        # 延迟生成缓存，避免阻塞启动
        if not self._pending_generation:
            self._pending_generation = True
            QTimer.singleShot(0, self._generate_wheel_cache_async)
        # 绘制简单背景
        painter.fillRect(self.rect(), self._get_theme_colors()['bg'])
    elif self._wheel_cache:
        # 绘制缓存的色环背景
        painter.drawPixmap(0, 0, self._wheel_cache)

    # 绘制其他内容...

def _generate_wheel_cache_async(self):
    """异步生成色轮缓存"""
    self._pending_generation = False
    self._generate_wheel_cache()
    self.update()
```

**决策原则：**
- 界面结构简单 → 预创建所有界面
- 界面结构复杂/组件初始化耗时 → 延迟创建（需确保切换无闪烁）
- 绘制密集型组件（色轮、直方图） → 延迟生成缓存

---

## 8. 界面布局规范

### 8.1 布局原则

- 使用布局管理器（QVBoxLayout, QHBoxLayout）
- 避免使用固定尺寸，优先使用 size policy

### 8.2 防止布局重叠的规范

**问题描述：**
当窗口被压缩（尤其是垂直方向）时，组件之间可能出现重叠，导致界面显示异常。

**根本原因：**
1. 组件设置了过大的 `minimumSize`，导致无法压缩
2. 缺少 `sizePolicy` 设置，组件无法正确响应布局变化
3. 使用 `setFixedHeight()` 等固定尺寸方法，阻止了自动调整

**解决方案：**

1. **设置合理的 minimumSize**
   ```python
   # 错误示例：最小尺寸过大，导致无法压缩
   self.setMinimumSize(600, 400)
   
   # 正确示例：根据内容设置合理的最小尺寸
   self.setMinimumSize(300, 200)
   ```

2. **使用 sizePolicy 控制扩展行为**
   ```python
   from PySide6.QtWidgets import QSizePolicy
   
   # 允许组件在水平和垂直方向上都充分扩展和压缩
   self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
   
   # 色卡面板：水平扩展，垂直优先压缩
   self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
   ```

3. **避免使用固定尺寸，使用最小/最大尺寸范围**
   ```python
   # 错误示例：固定高度，无法调整
   self.color_block.setFixedHeight(80)
   
   # 正确示例：允许在一定范围内调整
   self.color_block.setMinimumHeight(40)
   self.color_block.setMaximumHeight(80)
   ```

4. **为关键区域设置最小高度约束**
   ```python
   # 数值区域需要保证文字可见
   self.values_container.setMinimumHeight(60)
   
   # 16进制显示区域
   self.hex_container.setMinimumHeight(30)
   self.hex_container.setMaximumHeight(40)
   ```

5. **QSplitter 中的组件设置**
   ```python
   # 为 splitter 中的每个组件设置最小高度
   main_splitter.setMinimumHeight(400)
   
   # 为 splitter 中的子组件设置约束
   self.image_canvas.setMinimumHeight(200)
   self.color_card_panel.setMinimumHeight(200)
   ```

**最佳实践：**
- 始终为自定义组件设置 `sizePolicy`
- 最小尺寸应根据内容实际需求设置，不宜过大
- 使用 `setMinimumHeight()` 和 `setMaximumHeight()` 组合代替 `setFixedHeight()`
- 在 QSplitter 中，为每个子组件设置合理的最小尺寸
- 测试时尝试将窗口压缩到最小尺寸，检查是否有重叠

### 8.3 控件尺寸参考

| 控件 | 推荐尺寸 | 紧凑尺寸 | 说明 |
|:---:|:---:|:---:|:---|
| 主窗口 | 940×660 | - | 默认尺寸 |
| 主窗口最小 | 800×550 | - | 保证内容完整显示 |
| 画布最小 | 300×200 | 300×150 | 图片显示区域 |
| 色卡面板最小高度 | 200 | 130 | 保证色卡内容可见 |
| 单个色卡最小高度 | 160 | 120 | 包含色块+文字+16进制 |
| 色块高度范围 | 40-80 | 30-80 | 可压缩范围 |
| 数值区域最小高度 | 60 | 45 | HSB/LAB等数值显示 |
| 16进制区域最小高度 | 30 | 26 | 16进制码显示区 |
| 取色点半径 | 12px | - | 便于拖动操作 |
| 按钮高度 | 28-32 | 24 | 根据空间调整 |

---

## 9. 交互设计规范

### 9.1 取色点交互

- 鼠标悬停：显示手型光标
- 拖动时：实时更新颜色值
- 边界限制：限制在图片显示区域内

### 9.2 快捷键规范

| 快捷键 | 功能 |
|:---:|:---:|
| Ctrl + O | 打开图片 |
| Ctrl + Q | 退出程序 |

---

## 10. 版本管理规范

### 10.1 版本号格式

- 格式：`主版本.次版本.修订版本`
- 示例：`1.0.0`
- 主版本：重大功能更新
- 次版本：新增功能
- 修订版本：bug 修复

### 10.2 提交信息规范

**格式：** `[类型] 详细描述`

**类型：**
- `新功能`：新增功能或特性
- `修复`：修复代码中的错误
- `优化`：性能或体验改进
- `重构`：代码结构调整
- `文档`：修改或新增文档
- `样式`：界面样式、颜色、布局等视觉相关修改
- `内容调整`：如替换链接、修改文本等

**示例：**
- `[新功能] 新增用户管理功能`
- `[修复] 修复登录功能的验证逻辑错误`
- `[重构] 提取 BaseCanvas 基类，消除重复代码`
- `[文档] 更新 README.md 和开发规范`
- `[样式] 统一图片显示区域和色环背景色为纯黑色`

---

## 11. 配置管理规范

### 11.1 配置管理模块

使用 `core/config.py` 统一管理应用程序状态。

- 配置文件：JSON 格式，存储在用户主目录下的 `.color_card/config.json`
- 使用单例模式获取全局配置管理器实例

### 11.2 配置项说明

| 配置键 | 类型 | 默认值 | 说明 |
|:---:|:---:|:---:|:---|
| `settings.hex_visible` | bool | true | 是否显示16进制颜色值 |
| `settings.color_modes` | list | ["HSB", "LAB"] | 色卡中显示的色彩模式 |
| `settings.color_sample_count` | int | 5 | 色彩提取采样点数量 |
| `window.width` | int | 940 | 窗口宽度 |
| `window.height` | int | 660 | 窗口高度 |
| `window.is_maximized` | bool | false | 窗口是否最大化 |
| `window.is_fullscreen` | bool | false | 窗口是否全屏 |
| `favorites` | list | [] | 收藏的配色方案列表 |

### 11.3 使用示例

```python
from core import get_config_manager

config_manager = get_config_manager()
config = config_manager.load()

# 获取配置项
hex_visible = config_manager.get('settings.hex_visible', True)

# 设置配置项
config_manager.set('settings.hex_visible', False)
config_manager.save()
```

---

## 12. 调试规范

### 12.1 日志管理

**基本原则：**
- 使用 `print()` 语句进行调试（项目当前阶段）
- 关键操作应记录调试信息，便于调试和问题追踪

**说明：**
根据开发规范，本项目**保留 `print()` 调试语句**，原因如下：
1. 项目仍处于开发迭代阶段，后续功能修改需要调试支持
2. 调试语句有助于快速定位运行时问题
3. 方便其他开发者理解和调试代码
4. 开源发布时可根据需要决定是否保留（生产环境建议使用 `logging` 模块）

### 12.2 AI辅助调试

**日志查看流程：**
1. 应用程序启动失败时，查看控制台输出定位问题
2. 功能执行出现异常时，分析错误信息
3. 结合代码上下文，理解错误原因
4. 根据日志信息制定修复方案

---

## 13. 重构规范

### 13.1 重构原则

1. **保持功能不变**：重构过程中不改变现有功能
2. **渐进式重构**：分阶段进行，每阶段可独立验证
3. **先整理后重构**：先规范现有代码，再提取基类，最后重组目录
4. **代码清理同步**：修改代码时同步清理相关重复代码

### 13.2 基类提取规范

**步骤：**
1. 分析相似组件的公共逻辑
2. 设计基类接口（抽象方法）
3. 迁移第一个子类，验证基类设计
4. 迁移其他子类
5. 全面测试验证

**示例：**
```python
# 基类定义
class BaseCanvas(QWidget):
    def _draw_overlay(self, painter: QPainter):
        """绘制叠加内容（子类必须实现）"""
        raise NotImplementedError("子类必须实现 _draw_overlay 方法")

# 子类实现
class ImageCanvas(BaseCanvas):
    def _draw_overlay(self, painter: QPainter):
        """绘制取色点"""
        # 具体实现...
```

### 13.3 模块合并规范

**合并原则：**
- 将紧密相关的类合并到同一文件
- 避免过度拆分，提高代码可维护性
- 保持模块化，但减少文件数量

**示例：**
- `cards.py`：合并 ColorCard、LuminanceCard 及相关基类
- `histograms.py`：合并 LuminanceHistogramWidget、RGBHistogramWidget 及基类
- `canvases.py`：合并 BaseCanvas、ImageCanvas、LuminanceCanvas

---

## 14. 开发经验总结

### 14.1 配色方案功能开发经验

在实现配色方案功能过程中，总结了以下宝贵经验：

#### 14.1.1 算法设计原则

**配色方案算法参数设计：**
- 不同配色方案的采样点数量应根据色彩理论确定
- 同色系：4个（同一色相，不同饱和度）
- 邻近色：4个（基准色±30°范围内）
- 互补色：5个（基准色一侧3个，互补色一侧2个）
- 分离补色：3个（基准色+两个分离补色）
- 双补色：4个（两组互补色）

**饱和度参数设计：**
- 所有配色方案生成函数应接受 `base_saturation` 参数（默认100）
- 基于基准饱和度生成变化的饱和度序列，而非固定值
- 保持色彩和谐性的同时，支持随机饱和度变化

```python
def generate_monochromatic(hue: float, count: int = 4, base_saturation: float = 100):
    # 基于基准饱和度生成递减序列
    saturations = [
        base_saturation,
        max(20, base_saturation * 0.75),
        max(20, base_saturation * 0.5),
        max(20, base_saturation * 0.25)
    ]
```

**算法实现注意事项：**
- 函数签名要统一，避免参数错位（如 `angle` 和 `count` 的顺序）
- 使用明确的 `if-elif` 分支调用不同生成器，而非字典映射
- 色相计算注意取模运算 `(hue + 180) % 360`
- 饱和度计算确保最小值不低于20，保证颜色可见性

#### 14.1.2 UI组件设计经验

**动态卡片数量管理：**
```python
# 在初始化时根据当前状态设置卡片数量
def _update_card_count(self):
    scheme_counts = {
        'monochromatic': 4,
        'analogous': 4,
        'complementary': 5,
        'split_complementary': 3,
        'double_complementary': 4
    }
    count = scheme_counts.get(self._current_scheme, 5)
    self.color_panel.set_card_count(count)
```

**组件样式统一：**
- 复用现有组件的样式逻辑（如 `ColorModeContainer`）
- 提取公共样式函数（`get_text_color`, `get_placeholder_color` 等）
- 保持卡片布局一致，便于用户认知

#### 14.1.3 配置管理最佳实践

**设置同步机制：**
- 使用信号槽机制进行跨界面通信
- 设置界面发送信号，主窗口中转，目标界面接收
- 避免直接引用，降低耦合度

```python
# 设置界面发送信号
self.hex_display_changed.connect(
    self.color_scheme_interface.update_display_settings
)

# 目标界面提供更新方法
def update_display_settings(self, hex_visible=None, color_modes=None):
    if hex_visible is not None:
        self.color_panel.set_hex_visible(hex_visible)
```

#### 14.1.4 色轮交互设计

**明度调整与色轮联动：**
- 全局明度值直接对应HSB色彩空间的B值（Brightness）
- 滑块范围：10-100，直接对应B值百分比
- 明度降低时，采样点向中心移动；明度增加时，向外移动
- 色轮本身的颜色亮度也随之变化
- 所有采样点使用统一的全局明度值，忽略原始配色方案中的B值差异

```python
# 全局明度值直接作为HSB的B值
def _generate_wheel_cache(self):
    brightness_value = self._global_brightness / 100.0
    # ... 使用 brightness_value 作为HSB的V值

def _draw_scheme_points(self, painter):
    global_brightness_value = self._global_brightness
    # 所有采样点使用统一的明度值
    adjusted_b = global_brightness_value
```

#### 14.1.5 qfluentwidgets 使用注意事项

**ComboBox 数据存储：**
- `addItem(text, data)` 不会存储数据（data为None）
- 需要使用 `setItemData(index, data)` 单独设置

```python
# 错误用法
combo.addItem("同色系", "monochromatic")  # data为None

# 正确用法
combo.addItem("同色系")
combo.setItemData(0, "monochromatic")
```

#### 14.1.6 布局设计最佳实践

**QSplitter 使用经验：**
- 使用 `setHandleWidth(0)` 隐藏分隔条，保持界面整洁
- 使用 `QSplitter` 分隔区域可避免窗口压缩时组件重叠
- **注意**：所有 QSplitter 都应该设置 `setHandleWidth(0)`，否则会出现灰色分隔条
- 示例：垂直分割上下两个面板

```python
splitter = QSplitter(Qt.Orientation.Vertical)
splitter.setHandleWidth(0)  # 隐藏分隔条
splitter.addWidget(upper_widget)
splitter.addWidget(lower_widget)
```

**工具栏/按钮容器间距规范：**
- 工具栏容器应该设置合理的边距，避免按钮紧贴边缘
- 推荐设置：`setContentsMargins(0, 8, 0, 8)` 给上下留出 8px 间距
- 容器高度应该与边距协调，如边距 8px 时，最大高度应 >= 50px

```python
# 工具栏容器设置示例
toolbar = QWidget()
toolbar.setMaximumHeight(50)  # 高度要足够容纳边距
toolbar.setStyleSheet("background: transparent;")  # 透明背景
layout = QHBoxLayout(toolbar)
layout.setContentsMargins(0, 8, 0, 8)  # 上下各 8px 边距
layout.setSpacing(10)
```

**布局拉伸与对齐的冲突：**
- `layout.setAlignment(Qt.AlignmentFlag.AlignCenter)` 会阻止子控件拉伸填满父布局
- 需要拉伸填满时，应移除对齐设置，使用 `stretch` 参数控制比例

```python
# 错误：设置了AlignCenter，子控件无法拉伸
layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
layout.addWidget(widget)

# 正确：移除AlignCenter，使用stretch参数
layout.addWidget(widget, stretch=1)
```

**控件自适应大小的关键设置：**
- 父布局：`addWidget(widget, stretch=1)` 
- 子控件：`setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)`
- 移除固定尺寸限制，改用 `setMinimumSize()` 设置最小尺寸

```python
# 子控件设置
widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
widget.setMinimumSize(200, 200)  # 设置最小尺寸，而非固定尺寸

# 父布局设置
layout.addWidget(widget, stretch=1)  # stretch=1让控件占据所有可用空间
```

**多层嵌套布局的拉伸传递：**
- 每一层布局都需要设置 `stretch` 参数，才能让拉伸效果传递到最内层控件
- 示例：外层容器 → 内层容器 → 实际控件

```python
# 外层布局
outer_layout.addWidget(inner_container, stretch=1)

# 内层布局
inner_layout.addWidget(actual_widget, stretch=1)
```

**避免重叠的布局策略：**
- 使用 `QSplitter` 分隔区域，而不是普通布局
- 设置合理的 `setMinimumHeight()`，避免控件被压缩到无法显示
- 对于复杂面板，考虑使用 `QScrollArea` 提供滚动支持

**渐进式压缩设计原则：**
当窗口需要被压缩到很小时，应该设计多层次的压缩策略：

1. **第一阶段：正常压缩**
   - 保持所有内容可见，按比例缩小各区域
   - 设置合理的 `minimumHeight`，确保基本可读性

2. **第二阶段：紧凑模式**
   - 降低 `minimumHeight` 到更小值（如从160降到120）
   - 减小间距（`setSpacing` 从5降到3）
   - 减小边距（`setContentsMargins` 减小）
   - 缩小控件尺寸（按钮高度从28降到24）

3. **第三阶段：极限压缩**
   - 使用 `QScrollArea` 包裹内容
   - 或者隐藏非关键信息
   - 设置窗口绝对最小尺寸 `setMinimumSize()`

**实际案例 - 色卡面板压缩：**
```python
# 原始设置（容易导致重叠）
self.setMinimumHeight(160)
self.color_block.setMinimumHeight(40)
self.values_container.setMinimumHeight(60)
self.hex_container.setMinimumHeight(30)
layout.setSpacing(5)

# 优化后的设置（支持渐进式压缩）
self.setMinimumHeight(120)  # 降低整体最小高度
self.color_block.setMinimumHeight(30)  # 色块可以更小
self.values_container.setMinimumHeight(45)  # 数值区域压缩
self.hex_container.setMinimumHeight(26)  # 16进制区域压缩
layout.setSpacing(3)  # 减小间距
# 同时调整按钮尺寸和边距
```

**关键经验：**
- 不要只降低一个组件的最小高度，要**整体协调降低**
- 压缩时同步减小**间距、边距、控件尺寸**
- 测试时应该**逐步压缩窗口**，观察每个阶段的显示效果
- 如果某个区域内容仍然重叠，说明该区域的 `minimumHeight` 还是过大

#### 14.1.7 收藏功能开发经验

**动态卡片数量管理：**
- 收藏项的色卡数量应根据实际保存的颜色数量动态创建
- 避免固定数量的卡片，提高空间利用率和视觉一致性

```python
def _load_favorite_data(self):
    """加载收藏数据并动态创建色卡"""
    colors = self._favorite_data.get('colors', [])
    self._clear_color_cards()
    self._create_color_cards(len(colors))
    for i, card in enumerate(self._color_cards):
        if i < len(colors):
            card.update_color(colors[i])
```

**跨界面实时刷新机制：**
- 收藏添加后需要立即在其他界面可见
- 使用主窗口中转信号，避免界面间直接引用

```python
# 主窗口提供刷新方法
def refresh_favorites(self):
    """刷新收藏列表显示"""
    if hasattr(self, 'favorites_interface'):
        self.favorites_interface.refresh_favorites()

# 添加收藏后调用刷新
self.main_window.refresh_favorites()
```

#### 14.1.8 导入导出功能开发经验

**JSON数据格式设计：**
- 包含版本号便于后续数据迁移
- 包含导出时间戳便于追踪
- 数据与元数据分离

```python
def export_favorites(self, file_path: str) -> bool:
    """导出收藏数据到JSON文件"""
    favorites = self.get('favorites', [])
    export_data = {
        "version": "1.0",
        "export_time": datetime.now().isoformat(),
        "favorites": favorites
    }
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(export_data, f, ensure_ascii=False, indent=2)
```

**导入模式选择：**
- 提供追加和替换两种模式
- 使用MessageBox进行用户确认
- 数据验证后再导入

```python
def import_favorites(self, file_path: str, mode: str = 'append') -> tuple:
    """导入收藏数据
    
    Returns:
        tuple: (success: bool, count: int, error_msg: str)
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # 验证数据格式
        if 'favorites' not in data:
            return False, 0, "无效的数据格式"
        
        imported = data['favorites']
        
        if mode == 'replace':
            self.set('favorites', imported)
        else:  # append
            existing = self.get('favorites', [])
            existing.extend(imported)
            self.set('favorites', existing)
        
        self.save()
        return True, len(imported), ""
    except Exception as e:
        return False, 0, str(e)
```

#### 14.1.9 MessageBox使用最佳实践

**关键原则：不要手动断开信号连接**
- qfluentwidgets的MessageBox内部使用信号槽机制管理按钮点击
- 手动调用`disconnect()`会破坏内部机制，导致按钮无响应

```python
# 错误用法 - 会导致按钮无响应
msg_box = MessageBox("标题", "内容", self)
result = msg_box.exec()
msg_box.yesButton.clicked.disconnect()  # 不要这样做！
msg_box.cancelButton.clicked.disconnect()  # 不要这样做！

# 正确用法 - 直接获取结果
msg_box = MessageBox("选择导入模式", "请选择导入方式", self)
msg_box.yesButton.setText("追加")
msg_box.cancelButton.setText("替换")
result = msg_box.exec()
if result == 1:  # 点击了yesButton
    mode = 'append'
else:  # 点击了cancelButton或关闭对话框
    mode = 'replace'
```

**自定义按钮文本：**
- 使用`setText()`方法修改默认按钮文本
- 通过`exec()`返回值判断用户选择（1表示确认，0表示取消）

#### 14.1.10 配置数据迁移实践

**向后兼容性处理：**
- 添加版本号便于识别旧数据格式
- 提供迁移方法自动升级旧数据

```python
def _migrate_favorites_data(self):
    """迁移收藏数据到新版格式"""
    favorites = self.get('favorites', [])
    migrated = []
    
    for fav in favorites:
        # 检查是否为旧格式（没有id字段）
        if 'id' not in fav:
            migrated.append({
                'id': datetime.now().isoformat(),
                'name': fav.get('name', '未命名'),
                'colors': fav.get('colors', []),
                'created_at': datetime.now().isoformat(),
                'source': fav.get('source', 'unknown')
            })
        else:
            migrated.append(fav)
    
    if migrated != favorites:
        self.set('favorites', migrated)
        self.save()
```

#### 14.1.11 内置色彩多段显示经验

**问题背景：**
内置色彩面板中的配色方案颜色数量不一（4-24个），需要在有限空间内合理显示所有颜色。

**显示模式分类：**

| 显示模式 | 适用场景 | 颜色分配 | 切换方式 |
|:---:|:---|:---|:---|
| `single` | 颜色数量少（≤4个） | 直接显示所有颜色 | 无切换按钮 |
| `sequential` | 标准顺序色（10-12个） | 两段均分显示 | 浅色组/深色组切换 |
| `triple` | 颜色较多（12-16个） | 三段均分显示 | 前半/中间/后半循环切换 |
| `quad` | 颜色很多（24个） | 四段均分显示（每段6个） | 第一段/第二段/第三段/第四段循环切换 |
| `diverging` | 发散色（ColorBrewer） | 以中间为界分左右 | 左半/右半切换 |
| `qualitative` | 定性色（ColorBrewer） | 两段均分显示 | 前半/后半切换 |

**实现要点：**

1. **动态分配颜色数量**
   ```python
   # sequential 模式根据总颜色数动态分配
   half_count = total_colors // 2
   if self._shade_mode == 'light':
       colors = [colors_dict.get(i, '') for i in range(half_count)]
   else:
       colors = [colors_dict.get(i, '') for i in range(half_count, total_colors)]
   ```

2. **系列类型判断**
   ```python
   def _get_series_type(self) -> str:
       # 颜色数量较多的使用多段式显示
       if self._series_key.startswith(('catppuccin', 'gruvbox')):
           return 'quad'  # 24个颜色，四段式
       if self._series_key.startswith(('rose_pine', 'solarized')):
           return 'triple'  # 12-16个颜色，三段式
       if self._series_key.startswith(('nord', 'dracula')):
           return 'single'  # 4个颜色，单组显示
       # 其他默认为 sequential
       return 'sequential'
   ```

3. **切换逻辑实现**
   ```python
   def _on_toggle_shade_mode(self):
       if self._series_type == 'quad':
           # 四段式循环：light -> medium -> dark -> ultra_dark -> light
           if self._shade_mode == 'light':
               self._shade_mode = 'medium'
           elif self._shade_mode == 'medium':
               self._shade_mode = 'dark'
           elif self._shade_mode == 'dark':
               self._shade_mode = 'ultra_dark'
           else:
               self._shade_mode = 'light'
       # ... 其他模式
   ```

**关键经验：**

1. **根据颜色数量选择显示模式**
   - ≤4个颜色：使用 `single` 模式，直接显示
   - 5-10个颜色：使用 `sequential` 模式，两段显示
   - 11-16个颜色：使用 `triple` 模式，三段显示
   - ≥20个颜色：使用 `quad` 模式，四段显示

2. **保持切换按钮一致性**
   - 除 `single` 模式外，其他模式都显示切换按钮
   - 按钮使用循环切换逻辑，避免用户迷失

3. **标签命名规范**
   - 两段式：浅色组/深色组
   - 三段式：前半/中间/后半
   - 四段式：第一段/第二段/第三段/第四段

4. **动态计算优于固定值**
   - 使用 `total_colors // n` 计算每段数量，而非硬编码
   - 这样同一模式可以适配不同颜色数量的系列

---

## 15. 开源许可证管理规范

### 15.1 许可证管理概述

本项目采用 **GPLv3** 作为主许可证，使用了多个第三方库和开发工具，每个都有其自己的开源许可证。完整的许可证管理是开源项目合规性的重要组成部分。

**涉及的许可证类型：**
| 类型 | 许可证 | 用途 |
|:---:|:---:|:---:|
| 主项目 | GPLv3 | 取色卡项目本身 |
| 第三方库 | LGPL-3.0 | PySide6 |
| 第三方库 | GPLv3 | PySide6-Fluent-Widgets |
| 第三方库 | MIT | Pillow |
| 第三方库 | Apache-2.0 | requests |
| 第三方库 | BSD-3-Clause | numpy |
| 第三方库 | MIT | Open Color |
| 第三方库 | MIT | Tailwind CSS Colors |
| 第三方库 | MIT | Nice Color Palettes |
| 工具链 | MIT | auto-py-to-exe |
| 工具链 | GPLv2+ | UPX |
| 工具链 | Modified BSD | Inno Setup |

### 15.2 许可证文件管理

**必须维护的许可证文件：**

1. **LICENSE** - 主许可证文本文件
   - 包含完整的 GPLv3 许可证文本
   - 包含所有第三方库的完整许可证信息
   - 包含开发工具链的完整许可证信息
   - 使用统一的文本格式（`====` 和 `----` 分隔线）

2. **file/LICENSE.html** - HTML 格式的许可证文件
   - 用于应用程序内显示
   - 包含格式化的 HTML 样式
   - 与文本版 LICENSE 内容保持一致

3. **版权完善计划.md** - 许可证管理计划文档
   - 记录许可证完善的各个阶段
   - 跟踪执行进度
   - 保存执行记录和验证结果

### 15.3 第三方库许可证信息收集规范

**收集内容清单：**

| 信息项 | 说明 | 示例 |
|:---:|:---|:---|
| 库名称 | 完整的库名称 | PySide6 |
| 版本要求 | 项目使用的版本范围 | >=6.0.0 |
| 许可证类型 |  SPDX 标识符 | LGPL-3.0 |
| 版权所有 | 作者或组织名称 | The Qt Company |
| 项目地址 | 官方网站或仓库地址 | https://www.qt.io/ |
| 完整许可证文本 | 官方许可证全文 | 从官方网站获取 |

**收集渠道：**
- 官方 GitHub 仓库的 LICENSE 文件
- 官方网站许可证页面
- PyPI 项目页面的元数据
- 源码包中的 LICENSE 文件

### 15.4 许可证文本格式规范

**文本版 LICENSE 格式：**

```
================================================================================
第三方库许可证
--------------------------------------------------------------------------------
本项目使用了以下第三方库，每个库都有其自己的开源许可证：

================================================================================
1. 库名称 (许可证类型)
--------------------------------------------------------------------------------
版权所有：作者/组织名称
项目地址：https://example.com/
许可证：完整许可证名称

--------------------------------------------------------------------------------
[完整的许可证文本]

================================================================================
2. 下一个库...
```

**格式要求：**
- 使用 `====`（80个字符）作为章节分隔线
- 使用 `----`（80个字符）作为子章节分隔线
- 每个库独立成节，编号排序
- 许可证文本保持原始格式，不修改内容
- LGPL 许可证需注明引用 GPL 的条款

### 15.5 关于窗口许可证显示规范

**关于对话框必须包含的信息：**

```python
def _get_about_text(self):
    return """
    【开源项目使用说明】
      • 本程序基于 PySide6 架构开发
        版权所有：The Qt Company
        许可证：LGPL v3
        项目地址：https://www.qt.io/

      • 本程序 UI 组件使用 PySide6-Fluent-Widgets
        版权所有：zhiyiYo
        许可证：GPLv3
        项目地址：https://github.com/zhiyiYo/PyQt-Fluent-Widgets
    
    【开发工具链】
      • 本程序使用 auto-py-to-exe 工具打包
        版权所有：Brent Vollebregt
        许可证：MIT
        项目地址：https://github.com/brentvollebregt/auto-py-to-exe
    """
```

**显示要求：**
- 每个库必须包含：版权所有、许可证类型、项目地址
- 按类别分组（开源项目、开发工具链）
- 格式统一，便于阅读

### 15.6 许可证兼容性检查

**兼容性原则：**

| 主许可证 | 兼容的许可证 | 不兼容的许可证 |
|:---:|:---:|:---:|
| GPLv3 | LGPL-3.0, MIT, Apache-2.0, BSD | 专有许可证 |

**检查清单：**
- [ ] 所有第三方许可证与 GPLv3 兼容
- [ ] 所有许可证文本完整且最新
- [ ] 所有版权信息准确无误
- [ ] 所有项目链接可访问
- [ ] LGPL 引用 GPL 的说明清晰

### 15.7 许可证更新流程

**新增第三方库时的步骤：**

1. **信息收集**
   - 收集库名称、版本、许可证类型
   - 获取版权所有者信息
   - 获取项目地址
   - 下载完整许可证文本

2. **兼容性验证**
   - 确认许可证与 GPLv3 兼容
   - 检查许可证版本是否最新

3. **文件更新**
   - 更新 LICENSE 文本文件
   - 更新 file/LICENSE.html
   - 更新关于窗口的 `_get_about_text()`

4. **文档更新**
   - 更新版权完善计划.md
   - 记录更新日期和变更内容

5. **验证测试**
   - 检查文本格式是否正确
   - 验证链接可访问性
   - 确认所有文件内容一致

### 15.8 常见许可证文本获取地址

| 许可证 | 官方地址 |
|:---:|:---|
| GPLv3 | https://www.gnu.org/licenses/gpl-3.0.txt |
| LGPLv3 | https://www.gnu.org/licenses/lgpl-3.0.txt |
| MIT | https://opensource.org/licenses/MIT |
| Apache-2.0 | https://www.apache.org/licenses/LICENSE-2.0.txt |
| BSD-3-Clause | https://opensource.org/licenses/BSD-3-Clause |
| GPLv2 | https://www.gnu.org/licenses/gpl-2.0.txt |

### 15.9 注意事项

**必须避免的问题：**

1. **不要遗漏版权声明**
   - 每个第三方库都必须有明确的版权声明
   - 不能只列出库名和许可证类型

2. **不要修改许可证文本**
   - 保持许可证文本的原始内容
   - 不要删除或添加任何内容

3. **不要遗漏工具链**
   - 打包工具、压缩工具、安装程序制作工具都需要声明
   - 这些工具的许可证同样需要完整列出

4. **保持格式一致**
   - LICENSE 和 LICENSE.html 内容要一致
   - 使用统一的格式风格

5. **LGPL 特殊处理**
   - LGPL 是 GPL 的补充，需要明确说明引用关系
   - 在 LGPL 章节开头说明其引用了 GPL 的条款

### 15.10 经验总结

**本次版权完善的主要经验：**

1. **提前规划**
   - 制定详细的版权完善计划
   - 分阶段执行，逐步完善
   - 建立执行记录，跟踪进度

2. **统一格式**
   - 建立统一的文本格式规范
   - 所有许可证文件格式保持一致
   - 便于维护和更新

3. **完整收集**
   - 不仅收集第三方库，还要收集工具链
   - 每个组件都要有完整的版权信息
   - 建立 THIRD_PARTY_LICENSES.md 汇总文档

4. **引用优化**
   - 对于使用相同许可证的组件，可以引用主许可证
   - 避免重复粘贴相同的许可证文本
   - LGPL 需要明确说明引用 GPL 的条款

5. **持续维护**
   - 新增依赖时同步更新许可证信息
   - 定期检查许可证信息的准确性
   - 保持与项目实际使用的依赖一致

---

## 16. 附录

### 16.1 扩展开发建议

**潜在功能扩展：**
- 历史记录功能
- 配色规则检查
- 图片批量处理

**代码扩展原则：**
- 保持组件化设计
- 新功能应放在独立模块
- 使用信号槽进行组件通信

### 16.2 规范维护

**本规范将根据项目发展进行更新，以适应新的功能需求和技术变化。**

### 16.3 版本历史

| 版本 | 日期 | 变更内容 |
|:---:|:---:|:---:|
| 2.16 | 2026-02-10 | 新增配色预览功能：创建 ui/preview_widgets.py 配色预览组件模块，包含可拖拽颜色圆点、插画预览、排版预览等组件；新增 ColorPreviewInterface 界面，支持从色彩管理页面跳转预览配色方案在不同场景下的应用效果 |
| 2.15 | 2026-02-09 | 优化应用启动速度：色轮缓存和配色方案颜色改用延迟生成，避免阻塞启动；新增应用启动优化策略规范（7.3节） |
| 2.14 | 2026-02-09 | 重命名"色卡收藏"面板为"色彩管理"：将 `favorite_widgets.py` 重命名为 `color_management_widgets.py`，类名 `FavoritesInterface` 改为 `ColorManagementInterface`，更新所有相关引用和导航栏显示 |
| 2.13 | 2026-02-09 | 优化配色方案随机算法：所有配色方案生成函数添加 `base_saturation` 参数，支持基于基准饱和度的随机变化，更新配色方案算法设计规范（14.1.1节） |
| 2.12 | 2026-02-09 | 修复HSB色轮明度计算问题：滑块范围改为10-100直接对应B值百分比，统一色轮和色块面板的全局明度值逻辑，更新色轮交互设计规范（14.1.4节） |
| 2.11 | 2026-02-08 | 新增开源许可证管理规范（第15章），总结版权完善计划执行经验，包含许可证收集、格式规范、兼容性检查、更新流程等完整规范 |
| 2.10 | 2026-02-07 | 新增信号循环预防规范（5.3节）、QThread取消机制（7.3节）；实现双面板独立图片导入、分阶段图片加载（模糊预览→完整图片→更新直方图）、进度显示功能 |
| 2.9 | 2026-02-07 | 新增主题颜色管理规范（5.5节），创建 ui/theme_colors.py 统一颜色管理，消除所有硬编码颜色值 |
| 2.8 | 2026-02-06 | 新增工具栏/按钮容器间距规范，补充 QSplitter 分隔条样式注意事项 |
| 2.7 | 2026-02-06 | 补充渐进式压缩设计原则和实际案例，更新控件尺寸参考表（增加紧凑尺寸列），完善布局压缩的最佳实践 |
| 2.6 | 2026-02-06 | 新增防止布局重叠的规范（8.2节），包含minimumSize、sizePolicy、固定尺寸替代方案等最佳实践，更新控件尺寸参考表 |
| 2.5 | 2026-02-06 | 新增收藏功能（收藏配色方案、批量导入导出、收藏管理），新增MessageBox使用规范、配置数据迁移实践、动态卡片管理 |
| 2.4 | 2026-02-06 | 配色方案面板UI优化（色轮容器化、自适应大小、QSplitter布局），新增布局设计最佳实践经验 |
| 2.3 | 2026-02-06 | 新增配色方案功能（5种配色算法、可交互色环、配色方案组件），更新项目结构，新增开发经验总结章节 |
| 2.2 | 2026-02-05 | 重构项目结构，提取公共基类（BaseCanvas、BaseCard、BaseHistogram），扁平化目录结构，更新文档 |
| 2.1 | 2026-02-04 | 借鉴BetterGI 星轨开发规范，新增导入规范、代码清理原则、异常处理规范、性能优化建议、调试规范 |
| 2.0 | 2026-02-04 | 重构文档结构，精简冗余内容，优化版本号体系 |
| 1.0 | 2026-02-03 | 初始版本，建立基础开发规范 |


